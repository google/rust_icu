/* automatically generated by rust-bindgen 0.59.1 */

pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type UBool = i8;
pub type UChar = u16;
pub type OldUChar = ::std::os::raw::c_ushort;
pub type UChar32 = i32;
pub type UVersionInfo = [u8; 4usize];
extern "C" {
    pub fn u_versionFromString_73(
        versionArray: *mut u8,
        versionString: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn u_versionFromUString_73(versionArray: *mut u8, versionString: *const UChar);
}
extern "C" {
    pub fn u_versionToString_73(versionArray: *mut u8, versionString: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn u_getVersion_73(versionArray: *mut u8);
}
pub type UDate = f64;
impl UErrorCode {
    pub const U_ERROR_WARNING_START: UErrorCode = UErrorCode::U_USING_FALLBACK_WARNING;
}
impl UErrorCode {
    pub const U_PARSE_ERROR_START: UErrorCode = UErrorCode::U_BAD_VARIABLE_DEFINITION;
}
impl UErrorCode {
    pub const U_FMT_PARSE_ERROR_START: UErrorCode = UErrorCode::U_UNEXPECTED_TOKEN;
}
impl UErrorCode {
    pub const U_MULTIPLE_DECIMAL_SEPERATORS: UErrorCode = UErrorCode::U_MULTIPLE_DECIMAL_SEPARATORS;
}
impl UErrorCode {
    pub const U_BRK_ERROR_START: UErrorCode = UErrorCode::U_BRK_INTERNAL_ERROR;
}
impl UErrorCode {
    pub const U_REGEX_ERROR_START: UErrorCode = UErrorCode::U_REGEX_INTERNAL_ERROR;
}
impl UErrorCode {
    pub const U_IDNA_ERROR_START: UErrorCode = UErrorCode::U_IDNA_PROHIBITED_ERROR;
}
impl UErrorCode {
    pub const U_STRINGPREP_PROHIBITED_ERROR: UErrorCode = UErrorCode::U_IDNA_PROHIBITED_ERROR;
}
impl UErrorCode {
    pub const U_STRINGPREP_UNASSIGNED_ERROR: UErrorCode = UErrorCode::U_IDNA_UNASSIGNED_ERROR;
}
impl UErrorCode {
    pub const U_STRINGPREP_CHECK_BIDI_ERROR: UErrorCode = UErrorCode::U_IDNA_CHECK_BIDI_ERROR;
}
impl UErrorCode {
    pub const U_PLUGIN_TOO_HIGH: UErrorCode = UErrorCode::U_PLUGIN_ERROR_START;
}
impl UErrorCode {
    pub const U_ERROR_LIMIT: UErrorCode = UErrorCode::U_PLUGIN_ERROR_LIMIT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UErrorCode {
    U_USING_FALLBACK_WARNING = - 128,
    U_USING_DEFAULT_WARNING = - 127,
    U_SAFECLONE_ALLOCATED_WARNING = - 126,
    U_STATE_OLD_WARNING = - 125,
    U_STRING_NOT_TERMINATED_WARNING = - 124,
    U_SORT_KEY_TOO_SHORT_WARNING = - 123,
    U_AMBIGUOUS_ALIAS_WARNING = - 122,
    U_DIFFERENT_UCA_VERSION = - 121,
    U_PLUGIN_CHANGED_LEVEL_WARNING = - 120,
    U_ERROR_WARNING_LIMIT = - 119,
    U_ZERO_ERROR = 0,
    U_ILLEGAL_ARGUMENT_ERROR = 1,
    U_MISSING_RESOURCE_ERROR = 2,
    U_INVALID_FORMAT_ERROR = 3,
    U_FILE_ACCESS_ERROR = 4,
    U_INTERNAL_PROGRAM_ERROR = 5,
    U_MESSAGE_PARSE_ERROR = 6,
    U_MEMORY_ALLOCATION_ERROR = 7,
    U_INDEX_OUTOFBOUNDS_ERROR = 8,
    U_PARSE_ERROR = 9,
    U_INVALID_CHAR_FOUND = 10,
    U_TRUNCATED_CHAR_FOUND = 11,
    U_ILLEGAL_CHAR_FOUND = 12,
    U_INVALID_TABLE_FORMAT = 13,
    U_INVALID_TABLE_FILE = 14,
    U_BUFFER_OVERFLOW_ERROR = 15,
    U_UNSUPPORTED_ERROR = 16,
    U_RESOURCE_TYPE_MISMATCH = 17,
    U_ILLEGAL_ESCAPE_SEQUENCE = 18,
    U_UNSUPPORTED_ESCAPE_SEQUENCE = 19,
    U_NO_SPACE_AVAILABLE = 20,
    U_CE_NOT_FOUND_ERROR = 21,
    U_PRIMARY_TOO_LONG_ERROR = 22,
    U_STATE_TOO_OLD_ERROR = 23,
    U_TOO_MANY_ALIASES_ERROR = 24,
    U_ENUM_OUT_OF_SYNC_ERROR = 25,
    U_INVARIANT_CONVERSION_ERROR = 26,
    U_INVALID_STATE_ERROR = 27,
    U_COLLATOR_VERSION_MISMATCH = 28,
    U_USELESS_COLLATOR_ERROR = 29,
    U_NO_WRITE_PERMISSION = 30,
    U_INPUT_TOO_LONG_ERROR = 31,
    U_STANDARD_ERROR_LIMIT = 32,
    U_BAD_VARIABLE_DEFINITION = 65536,
    U_MALFORMED_RULE = 65537,
    U_MALFORMED_SET = 65538,
    U_MALFORMED_SYMBOL_REFERENCE = 65539,
    U_MALFORMED_UNICODE_ESCAPE = 65540,
    U_MALFORMED_VARIABLE_DEFINITION = 65541,
    U_MALFORMED_VARIABLE_REFERENCE = 65542,
    U_MISMATCHED_SEGMENT_DELIMITERS = 65543,
    U_MISPLACED_ANCHOR_START = 65544,
    U_MISPLACED_CURSOR_OFFSET = 65545,
    U_MISPLACED_QUANTIFIER = 65546,
    U_MISSING_OPERATOR = 65547,
    U_MISSING_SEGMENT_CLOSE = 65548,
    U_MULTIPLE_ANTE_CONTEXTS = 65549,
    U_MULTIPLE_CURSORS = 65550,
    U_MULTIPLE_POST_CONTEXTS = 65551,
    U_TRAILING_BACKSLASH = 65552,
    U_UNDEFINED_SEGMENT_REFERENCE = 65553,
    U_UNDEFINED_VARIABLE = 65554,
    U_UNQUOTED_SPECIAL = 65555,
    U_UNTERMINATED_QUOTE = 65556,
    U_RULE_MASK_ERROR = 65557,
    U_MISPLACED_COMPOUND_FILTER = 65558,
    U_MULTIPLE_COMPOUND_FILTERS = 65559,
    U_INVALID_RBT_SYNTAX = 65560,
    U_INVALID_PROPERTY_PATTERN = 65561,
    U_MALFORMED_PRAGMA = 65562,
    U_UNCLOSED_SEGMENT = 65563,
    U_ILLEGAL_CHAR_IN_SEGMENT = 65564,
    U_VARIABLE_RANGE_EXHAUSTED = 65565,
    U_VARIABLE_RANGE_OVERLAP = 65566,
    U_ILLEGAL_CHARACTER = 65567,
    U_INTERNAL_TRANSLITERATOR_ERROR = 65568,
    U_INVALID_ID = 65569,
    U_INVALID_FUNCTION = 65570,
    U_PARSE_ERROR_LIMIT = 65571,
    U_UNEXPECTED_TOKEN = 65792,
    U_MULTIPLE_DECIMAL_SEPARATORS = 65793,
    U_MULTIPLE_EXPONENTIAL_SYMBOLS = 65794,
    U_MALFORMED_EXPONENTIAL_PATTERN = 65795,
    U_MULTIPLE_PERCENT_SYMBOLS = 65796,
    U_MULTIPLE_PERMILL_SYMBOLS = 65797,
    U_MULTIPLE_PAD_SPECIFIERS = 65798,
    U_PATTERN_SYNTAX_ERROR = 65799,
    U_ILLEGAL_PAD_POSITION = 65800,
    U_UNMATCHED_BRACES = 65801,
    U_UNSUPPORTED_PROPERTY = 65802,
    U_UNSUPPORTED_ATTRIBUTE = 65803,
    U_ARGUMENT_TYPE_MISMATCH = 65804,
    U_DUPLICATE_KEYWORD = 65805,
    U_UNDEFINED_KEYWORD = 65806,
    U_DEFAULT_KEYWORD_MISSING = 65807,
    U_DECIMAL_NUMBER_SYNTAX_ERROR = 65808,
    U_FORMAT_INEXACT_ERROR = 65809,
    U_NUMBER_ARG_OUTOFBOUNDS_ERROR = 65810,
    U_NUMBER_SKELETON_SYNTAX_ERROR = 65811,
    U_FMT_PARSE_ERROR_LIMIT = 65812,
    U_BRK_INTERNAL_ERROR = 66048,
    U_BRK_HEX_DIGITS_EXPECTED = 66049,
    U_BRK_SEMICOLON_EXPECTED = 66050,
    U_BRK_RULE_SYNTAX = 66051,
    U_BRK_UNCLOSED_SET = 66052,
    U_BRK_ASSIGN_ERROR = 66053,
    U_BRK_VARIABLE_REDFINITION = 66054,
    U_BRK_MISMATCHED_PAREN = 66055,
    U_BRK_NEW_LINE_IN_QUOTED_STRING = 66056,
    U_BRK_UNDEFINED_VARIABLE = 66057,
    U_BRK_INIT_ERROR = 66058,
    U_BRK_RULE_EMPTY_SET = 66059,
    U_BRK_UNRECOGNIZED_OPTION = 66060,
    U_BRK_MALFORMED_RULE_TAG = 66061,
    U_BRK_ERROR_LIMIT = 66062,
    U_REGEX_INTERNAL_ERROR = 66304,
    U_REGEX_RULE_SYNTAX = 66305,
    U_REGEX_INVALID_STATE = 66306,
    U_REGEX_BAD_ESCAPE_SEQUENCE = 66307,
    U_REGEX_PROPERTY_SYNTAX = 66308,
    U_REGEX_UNIMPLEMENTED = 66309,
    U_REGEX_MISMATCHED_PAREN = 66310,
    U_REGEX_NUMBER_TOO_BIG = 66311,
    U_REGEX_BAD_INTERVAL = 66312,
    U_REGEX_MAX_LT_MIN = 66313,
    U_REGEX_INVALID_BACK_REF = 66314,
    U_REGEX_INVALID_FLAG = 66315,
    U_REGEX_LOOK_BEHIND_LIMIT = 66316,
    U_REGEX_SET_CONTAINS_STRING = 66317,
    U_REGEX_OCTAL_TOO_BIG = 66318,
    U_REGEX_MISSING_CLOSE_BRACKET = 66319,
    U_REGEX_INVALID_RANGE = 66320,
    U_REGEX_STACK_OVERFLOW = 66321,
    U_REGEX_TIME_OUT = 66322,
    U_REGEX_STOPPED_BY_CALLER = 66323,
    U_REGEX_PATTERN_TOO_BIG = 66324,
    U_REGEX_INVALID_CAPTURE_GROUP_NAME = 66325,
    U_REGEX_ERROR_LIMIT = 66326,
    U_IDNA_PROHIBITED_ERROR = 66560,
    U_IDNA_UNASSIGNED_ERROR = 66561,
    U_IDNA_CHECK_BIDI_ERROR = 66562,
    U_IDNA_STD3_ASCII_RULES_ERROR = 66563,
    U_IDNA_ACE_PREFIX_ERROR = 66564,
    U_IDNA_VERIFICATION_ERROR = 66565,
    U_IDNA_LABEL_TOO_LONG_ERROR = 66566,
    U_IDNA_ZERO_LENGTH_LABEL_ERROR = 66567,
    U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR = 66568,
    U_IDNA_ERROR_LIMIT = 66569,
    U_PLUGIN_ERROR_START = 66816,
    U_PLUGIN_DIDNT_SET_LEVEL = 66817,
    U_PLUGIN_ERROR_LIMIT = 66818,
}
extern "C" {
    pub fn u_errorName_73(code: UErrorCode) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UEnumeration {
    _unused: [u8; 0],
}
extern "C" {
    pub fn uenum_close_73(en: *mut UEnumeration);
}
extern "C" {
    pub fn uenum_count_73(en: *mut UEnumeration, status: *mut UErrorCode) -> i32;
}
extern "C" {
    pub fn uenum_unext_73(
        en: *mut UEnumeration,
        resultLength: *mut i32,
        status: *mut UErrorCode,
    ) -> *const UChar;
}
extern "C" {
    pub fn uenum_next_73(
        en: *mut UEnumeration,
        resultLength: *mut i32,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uenum_reset_73(en: *mut UEnumeration, status: *mut UErrorCode);
}
extern "C" {
    pub fn uenum_openUCharStringsEnumeration_73(
        strings: *const *const UChar,
        count: i32,
        ec: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn uenum_openCharStringsEnumeration_73(
        strings: *const *const ::std::os::raw::c_char,
        count: i32,
        ec: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum ULocDataLocaleType {
    ULOC_ACTUAL_LOCALE = 0,
    ULOC_VALID_LOCALE = 1,
    ULOC_REQUESTED_LOCALE = 2,
    ULOC_DATA_LOCALE_TYPE_LIMIT = 3,
}
extern "C" {
    pub fn uloc_getDefault_73() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_setDefault_73(localeID: *const ::std::os::raw::c_char, status: *mut UErrorCode);
}
extern "C" {
    pub fn uloc_getLanguage_73(
        localeID: *const ::std::os::raw::c_char,
        language: *mut ::std::os::raw::c_char,
        languageCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getScript_73(
        localeID: *const ::std::os::raw::c_char,
        script: *mut ::std::os::raw::c_char,
        scriptCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getCountry_73(
        localeID: *const ::std::os::raw::c_char,
        country: *mut ::std::os::raw::c_char,
        countryCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getVariant_73(
        localeID: *const ::std::os::raw::c_char,
        variant: *mut ::std::os::raw::c_char,
        variantCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getName_73(
        localeID: *const ::std::os::raw::c_char,
        name: *mut ::std::os::raw::c_char,
        nameCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_canonicalize_73(
        localeID: *const ::std::os::raw::c_char,
        name: *mut ::std::os::raw::c_char,
        nameCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getISO3Language_73(
        localeID: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_getISO3Country_73(
        localeID: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_getLCID_73(localeID: *const ::std::os::raw::c_char) -> u32;
}
extern "C" {
    pub fn uloc_getDisplayLanguage_73(
        locale: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        language: *mut UChar,
        languageCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayScript_73(
        locale: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        script: *mut UChar,
        scriptCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayCountry_73(
        locale: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        country: *mut UChar,
        countryCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayVariant_73(
        locale: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        variant: *mut UChar,
        variantCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayKeyword_73(
        keyword: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        dest: *mut UChar,
        destCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayKeywordValue_73(
        locale: *const ::std::os::raw::c_char,
        keyword: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        dest: *mut UChar,
        destCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayName_73(
        localeID: *const ::std::os::raw::c_char,
        inLocaleID: *const ::std::os::raw::c_char,
        result: *mut UChar,
        maxResultSize: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getAvailable_73(n: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_countAvailable_73() -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum ULocAvailableType {
    ULOC_AVAILABLE_DEFAULT = 0,
    ULOC_AVAILABLE_ONLY_LEGACY_ALIASES = 1,
    ULOC_AVAILABLE_WITH_LEGACY_ALIASES = 2,
    ULOC_AVAILABLE_COUNT = 3,
}
extern "C" {
    pub fn uloc_openAvailableByType_73(
        type_: ULocAvailableType,
        status: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn uloc_getISOLanguages_73() -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_getISOCountries_73() -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_getParent_73(
        localeID: *const ::std::os::raw::c_char,
        parent: *mut ::std::os::raw::c_char,
        parentCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getBaseName_73(
        localeID: *const ::std::os::raw::c_char,
        name: *mut ::std::os::raw::c_char,
        nameCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_openKeywords_73(
        localeID: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn uloc_getKeywordValue_73(
        localeID: *const ::std::os::raw::c_char,
        keywordName: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        bufferCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_setKeywordValue_73(
        keywordName: *const ::std::os::raw::c_char,
        keywordValue: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        bufferCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_isRightToLeft_73(locale: *const ::std::os::raw::c_char) -> UBool;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum ULayoutType {
    ULOC_LAYOUT_LTR = 0,
    ULOC_LAYOUT_RTL = 1,
    ULOC_LAYOUT_TTB = 2,
    ULOC_LAYOUT_BTT = 3,
    ULOC_LAYOUT_UNKNOWN = 4,
}
extern "C" {
    pub fn uloc_getCharacterOrientation_73(
        localeId: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> ULayoutType;
}
extern "C" {
    pub fn uloc_getLineOrientation_73(
        localeId: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> ULayoutType;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UAcceptResult {
    ULOC_ACCEPT_FAILED = 0,
    ULOC_ACCEPT_VALID = 1,
    ULOC_ACCEPT_FALLBACK = 2,
}
extern "C" {
    pub fn uloc_acceptLanguageFromHTTP_73(
        result: *mut ::std::os::raw::c_char,
        resultAvailable: i32,
        outResult: *mut UAcceptResult,
        httpAcceptLanguage: *const ::std::os::raw::c_char,
        availableLocales: *mut UEnumeration,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_acceptLanguage_73(
        result: *mut ::std::os::raw::c_char,
        resultAvailable: i32,
        outResult: *mut UAcceptResult,
        acceptList: *mut *const ::std::os::raw::c_char,
        acceptListCount: i32,
        availableLocales: *mut UEnumeration,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getLocaleForLCID_73(
        hostID: u32,
        locale: *mut ::std::os::raw::c_char,
        localeCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_addLikelySubtags_73(
        localeID: *const ::std::os::raw::c_char,
        maximizedLocaleID: *mut ::std::os::raw::c_char,
        maximizedLocaleIDCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_minimizeSubtags_73(
        localeID: *const ::std::os::raw::c_char,
        minimizedLocaleID: *mut ::std::os::raw::c_char,
        minimizedLocaleIDCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_forLanguageTag_73(
        langtag: *const ::std::os::raw::c_char,
        localeID: *mut ::std::os::raw::c_char,
        localeIDCapacity: i32,
        parsedLength: *mut i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_toLanguageTag_73(
        localeID: *const ::std::os::raw::c_char,
        langtag: *mut ::std::os::raw::c_char,
        langtagCapacity: i32,
        strict: UBool,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_toUnicodeLocaleKey_73(
        keyword: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_toUnicodeLocaleType_73(
        keyword: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_toLegacyKey_73(
        keyword: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_toLegacyType_73(
        keyword: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UCPMap {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UCPMapRangeOption {
    UCPMAP_RANGE_NORMAL = 0,
    UCPMAP_RANGE_FIXED_LEAD_SURROGATES = 1,
    UCPMAP_RANGE_FIXED_ALL_SURROGATES = 2,
}
extern "C" {
    pub fn ucpmap_get_73(map: *const UCPMap, c: UChar32) -> u32;
}
pub type UCPMapValueFilter =
    ::std::option::Option<
        unsafe extern "C" fn(context: *const ::std::os::raw::c_void, value: u32)
                             -> u32,
    >;
extern "C" {
    pub fn ucpmap_getRange_73(
        map: *const UCPMap,
        start: UChar32,
        option: UCPMapRangeOption,
        surrogateValue: u32,
        filter: UCPMapValueFilter,
        context: *const ::std::os::raw::c_void,
        pValue: *mut u32,
    ) -> UChar32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USet {
    _unused: [u8; 0],
}
impl UProperty {
    pub const UCHAR_BINARY_START: UProperty = UProperty::UCHAR_ALPHABETIC;
}
impl UProperty {
    pub const UCHAR_INT_START: UProperty = UProperty::UCHAR_BIDI_CLASS;
}
impl UProperty {
    pub const UCHAR_MASK_START: UProperty = UProperty::UCHAR_GENERAL_CATEGORY_MASK;
}
impl UProperty {
    pub const UCHAR_DOUBLE_START: UProperty = UProperty::UCHAR_NUMERIC_VALUE;
}
impl UProperty {
    pub const UCHAR_STRING_START: UProperty = UProperty::UCHAR_AGE;
}
impl UProperty {
    pub const UCHAR_OTHER_PROPERTY_START: UProperty = UProperty::UCHAR_SCRIPT_EXTENSIONS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UProperty {
    UCHAR_ALPHABETIC = 0,
    UCHAR_ASCII_HEX_DIGIT = 1,
    UCHAR_BIDI_CONTROL = 2,
    UCHAR_BIDI_MIRRORED = 3,
    UCHAR_DASH = 4,
    UCHAR_DEFAULT_IGNORABLE_CODE_POINT = 5,
    UCHAR_DEPRECATED = 6,
    UCHAR_DIACRITIC = 7,
    UCHAR_EXTENDER = 8,
    UCHAR_FULL_COMPOSITION_EXCLUSION = 9,
    UCHAR_GRAPHEME_BASE = 10,
    UCHAR_GRAPHEME_EXTEND = 11,
    UCHAR_GRAPHEME_LINK = 12,
    UCHAR_HEX_DIGIT = 13,
    UCHAR_HYPHEN = 14,
    UCHAR_ID_CONTINUE = 15,
    UCHAR_ID_START = 16,
    UCHAR_IDEOGRAPHIC = 17,
    UCHAR_IDS_BINARY_OPERATOR = 18,
    UCHAR_IDS_TRINARY_OPERATOR = 19,
    UCHAR_JOIN_CONTROL = 20,
    UCHAR_LOGICAL_ORDER_EXCEPTION = 21,
    UCHAR_LOWERCASE = 22,
    UCHAR_MATH = 23,
    UCHAR_NONCHARACTER_CODE_POINT = 24,
    UCHAR_QUOTATION_MARK = 25,
    UCHAR_RADICAL = 26,
    UCHAR_SOFT_DOTTED = 27,
    UCHAR_TERMINAL_PUNCTUATION = 28,
    UCHAR_UNIFIED_IDEOGRAPH = 29,
    UCHAR_UPPERCASE = 30,
    UCHAR_WHITE_SPACE = 31,
    UCHAR_XID_CONTINUE = 32,
    UCHAR_XID_START = 33,
    UCHAR_CASE_SENSITIVE = 34,
    UCHAR_S_TERM = 35,
    UCHAR_VARIATION_SELECTOR = 36,
    UCHAR_NFD_INERT = 37,
    UCHAR_NFKD_INERT = 38,
    UCHAR_NFC_INERT = 39,
    UCHAR_NFKC_INERT = 40,
    UCHAR_SEGMENT_STARTER = 41,
    UCHAR_PATTERN_SYNTAX = 42,
    UCHAR_PATTERN_WHITE_SPACE = 43,
    UCHAR_POSIX_ALNUM = 44,
    UCHAR_POSIX_BLANK = 45,
    UCHAR_POSIX_GRAPH = 46,
    UCHAR_POSIX_PRINT = 47,
    UCHAR_POSIX_XDIGIT = 48,
    UCHAR_CASED = 49,
    UCHAR_CASE_IGNORABLE = 50,
    UCHAR_CHANGES_WHEN_LOWERCASED = 51,
    UCHAR_CHANGES_WHEN_UPPERCASED = 52,
    UCHAR_CHANGES_WHEN_TITLECASED = 53,
    UCHAR_CHANGES_WHEN_CASEFOLDED = 54,
    UCHAR_CHANGES_WHEN_CASEMAPPED = 55,
    UCHAR_CHANGES_WHEN_NFKC_CASEFOLDED = 56,
    UCHAR_EMOJI = 57,
    UCHAR_EMOJI_PRESENTATION = 58,
    UCHAR_EMOJI_MODIFIER = 59,
    UCHAR_EMOJI_MODIFIER_BASE = 60,
    UCHAR_EMOJI_COMPONENT = 61,
    UCHAR_REGIONAL_INDICATOR = 62,
    UCHAR_PREPENDED_CONCATENATION_MARK = 63,
    UCHAR_EXTENDED_PICTOGRAPHIC = 64,
    UCHAR_BASIC_EMOJI = 65,
    UCHAR_EMOJI_KEYCAP_SEQUENCE = 66,
    UCHAR_RGI_EMOJI_MODIFIER_SEQUENCE = 67,
    UCHAR_RGI_EMOJI_FLAG_SEQUENCE = 68,
    UCHAR_RGI_EMOJI_TAG_SEQUENCE = 69,
    UCHAR_RGI_EMOJI_ZWJ_SEQUENCE = 70,
    UCHAR_RGI_EMOJI = 71,
    UCHAR_BINARY_LIMIT = 72,
    UCHAR_BIDI_CLASS = 4096,
    UCHAR_BLOCK = 4097,
    UCHAR_CANONICAL_COMBINING_CLASS = 4098,
    UCHAR_DECOMPOSITION_TYPE = 4099,
    UCHAR_EAST_ASIAN_WIDTH = 4100,
    UCHAR_GENERAL_CATEGORY = 4101,
    UCHAR_JOINING_GROUP = 4102,
    UCHAR_JOINING_TYPE = 4103,
    UCHAR_LINE_BREAK = 4104,
    UCHAR_NUMERIC_TYPE = 4105,
    UCHAR_SCRIPT = 4106,
    UCHAR_HANGUL_SYLLABLE_TYPE = 4107,
    UCHAR_NFD_QUICK_CHECK = 4108,
    UCHAR_NFKD_QUICK_CHECK = 4109,
    UCHAR_NFC_QUICK_CHECK = 4110,
    UCHAR_NFKC_QUICK_CHECK = 4111,
    UCHAR_LEAD_CANONICAL_COMBINING_CLASS = 4112,
    UCHAR_TRAIL_CANONICAL_COMBINING_CLASS = 4113,
    UCHAR_GRAPHEME_CLUSTER_BREAK = 4114,
    UCHAR_SENTENCE_BREAK = 4115,
    UCHAR_WORD_BREAK = 4116,
    UCHAR_BIDI_PAIRED_BRACKET_TYPE = 4117,
    UCHAR_INDIC_POSITIONAL_CATEGORY = 4118,
    UCHAR_INDIC_SYLLABIC_CATEGORY = 4119,
    UCHAR_VERTICAL_ORIENTATION = 4120,
    UCHAR_INT_LIMIT = 4121,
    UCHAR_GENERAL_CATEGORY_MASK = 8192,
    UCHAR_MASK_LIMIT = 8193,
    UCHAR_NUMERIC_VALUE = 12288,
    UCHAR_DOUBLE_LIMIT = 12289,
    UCHAR_AGE = 16384,
    UCHAR_BIDI_MIRRORING_GLYPH = 16385,
    UCHAR_CASE_FOLDING = 16386,
    UCHAR_ISO_COMMENT = 16387,
    UCHAR_LOWERCASE_MAPPING = 16388,
    UCHAR_NAME = 16389,
    UCHAR_SIMPLE_CASE_FOLDING = 16390,
    UCHAR_SIMPLE_LOWERCASE_MAPPING = 16391,
    UCHAR_SIMPLE_TITLECASE_MAPPING = 16392,
    UCHAR_SIMPLE_UPPERCASE_MAPPING = 16393,
    UCHAR_TITLECASE_MAPPING = 16394,
    UCHAR_UNICODE_1_NAME = 16395,
    UCHAR_UPPERCASE_MAPPING = 16396,
    UCHAR_BIDI_PAIRED_BRACKET = 16397,
    UCHAR_STRING_LIMIT = 16398,
    UCHAR_SCRIPT_EXTENSIONS = 28672,
    UCHAR_OTHER_PROPERTY_LIMIT = 28673,
    UCHAR_INVALID_CODE = - 1,
}
impl UCharCategory {
    pub const U_GENERAL_OTHER_TYPES: UCharCategory = UCharCategory::U_UNASSIGNED;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UCharCategory {
    U_UNASSIGNED = 0,
    U_UPPERCASE_LETTER = 1,
    U_LOWERCASE_LETTER = 2,
    U_TITLECASE_LETTER = 3,
    U_MODIFIER_LETTER = 4,
    U_OTHER_LETTER = 5,
    U_NON_SPACING_MARK = 6,
    U_ENCLOSING_MARK = 7,
    U_COMBINING_SPACING_MARK = 8,
    U_DECIMAL_DIGIT_NUMBER = 9,
    U_LETTER_NUMBER = 10,
    U_OTHER_NUMBER = 11,
    U_SPACE_SEPARATOR = 12,
    U_LINE_SEPARATOR = 13,
    U_PARAGRAPH_SEPARATOR = 14,
    U_CONTROL_CHAR = 15,
    U_FORMAT_CHAR = 16,
    U_PRIVATE_USE_CHAR = 17,
    U_SURROGATE = 18,
    U_DASH_PUNCTUATION = 19,
    U_START_PUNCTUATION = 20,
    U_END_PUNCTUATION = 21,
    U_CONNECTOR_PUNCTUATION = 22,
    U_OTHER_PUNCTUATION = 23,
    U_MATH_SYMBOL = 24,
    U_CURRENCY_SYMBOL = 25,
    U_MODIFIER_SYMBOL = 26,
    U_OTHER_SYMBOL = 27,
    U_INITIAL_PUNCTUATION = 28,
    U_FINAL_PUNCTUATION = 29,
    U_CHAR_CATEGORY_COUNT = 30,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UCharDirection {
    U_LEFT_TO_RIGHT = 0,
    U_RIGHT_TO_LEFT = 1,
    U_EUROPEAN_NUMBER = 2,
    U_EUROPEAN_NUMBER_SEPARATOR = 3,
    U_EUROPEAN_NUMBER_TERMINATOR = 4,
    U_ARABIC_NUMBER = 5,
    U_COMMON_NUMBER_SEPARATOR = 6,
    U_BLOCK_SEPARATOR = 7,
    U_SEGMENT_SEPARATOR = 8,
    U_WHITE_SPACE_NEUTRAL = 9,
    U_OTHER_NEUTRAL = 10,
    U_LEFT_TO_RIGHT_EMBEDDING = 11,
    U_LEFT_TO_RIGHT_OVERRIDE = 12,
    U_RIGHT_TO_LEFT_ARABIC = 13,
    U_RIGHT_TO_LEFT_EMBEDDING = 14,
    U_RIGHT_TO_LEFT_OVERRIDE = 15,
    U_POP_DIRECTIONAL_FORMAT = 16,
    U_DIR_NON_SPACING_MARK = 17,
    U_BOUNDARY_NEUTRAL = 18,
    U_FIRST_STRONG_ISOLATE = 19,
    U_LEFT_TO_RIGHT_ISOLATE = 20,
    U_RIGHT_TO_LEFT_ISOLATE = 21,
    U_POP_DIRECTIONAL_ISOLATE = 22,
    U_CHAR_DIRECTION_COUNT = 23,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UCharNameChoice {
    U_UNICODE_CHAR_NAME = 0,
    U_UNICODE_10_CHAR_NAME = 1,
    U_EXTENDED_CHAR_NAME = 2,
    U_CHAR_NAME_ALIAS = 3,
    U_CHAR_NAME_CHOICE_COUNT = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UPropertyNameChoice {
    U_SHORT_PROPERTY_NAME = 0,
    U_LONG_PROPERTY_NAME = 1,
    U_PROPERTY_NAME_CHOICE_COUNT = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UWordBreakValues {
    U_WB_OTHER = 0,
    U_WB_ALETTER = 1,
    U_WB_FORMAT = 2,
    U_WB_KATAKANA = 3,
    U_WB_MIDLETTER = 4,
    U_WB_MIDNUM = 5,
    U_WB_NUMERIC = 6,
    U_WB_EXTENDNUMLET = 7,
    U_WB_CR = 8,
    U_WB_EXTEND = 9,
    U_WB_LF = 10,
    U_WB_MIDNUMLET = 11,
    U_WB_NEWLINE = 12,
    U_WB_REGIONAL_INDICATOR = 13,
    U_WB_HEBREW_LETTER = 14,
    U_WB_SINGLE_QUOTE = 15,
    U_WB_DOUBLE_QUOTE = 16,
    U_WB_E_BASE = 17,
    U_WB_E_BASE_GAZ = 18,
    U_WB_E_MODIFIER = 19,
    U_WB_GLUE_AFTER_ZWJ = 20,
    U_WB_ZWJ = 21,
    U_WB_WSEGSPACE = 22,
    U_WB_COUNT = 23,
}
extern "C" {
    pub fn u_hasBinaryProperty_73(c: UChar32, which: UProperty) -> UBool;
}
extern "C" {
    pub fn u_stringHasBinaryProperty_73(s: *const UChar, length: i32, which: UProperty) -> UBool;
}
extern "C" {
    pub fn u_getBinaryPropertySet_73(
        property: UProperty,
        pErrorCode: *mut UErrorCode,
    ) -> *const USet;
}
extern "C" {
    pub fn u_isUAlphabetic_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isULowercase_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isUUppercase_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isUWhiteSpace_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_getIntPropertyValue_73(c: UChar32, which: UProperty) -> i32;
}
extern "C" {
    pub fn u_getIntPropertyMinValue_73(which: UProperty) -> i32;
}
extern "C" {
    pub fn u_getIntPropertyMaxValue_73(which: UProperty) -> i32;
}
extern "C" {
    pub fn u_getIntPropertyMap_73(
        property: UProperty,
        pErrorCode: *mut UErrorCode,
    ) -> *const UCPMap;
}
extern "C" {
    pub fn u_getNumericValue_73(c: UChar32) -> f64;
}
extern "C" {
    pub fn u_islower_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isupper_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_istitle_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isdigit_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isalpha_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isalnum_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isxdigit_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_ispunct_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isgraph_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isblank_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isdefined_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isspace_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isJavaSpaceChar_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isWhitespace_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_iscntrl_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isISOControl_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isprint_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isbase_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_charDirection_73(c: UChar32) -> UCharDirection;
}
extern "C" {
    pub fn u_isMirrored_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_charMirror_73(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_getBidiPairedBracket_73(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_charType_73(c: UChar32) -> i8;
}
pub type UCharEnumTypeRange =
    ::std::option::Option<
        unsafe extern "C" fn(context: *const ::std::os::raw::c_void,
                             start: UChar32,
                             limit: UChar32,
                             type_: UCharCategory)
                             -> UBool,
    >;
extern "C" {
    pub fn u_enumCharTypes_73(
        enumRange: UCharEnumTypeRange,
        context: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn u_getCombiningClass_73(c: UChar32) -> u8;
}
extern "C" {
    pub fn u_charDigitValue_73(c: UChar32) -> i32;
}
extern "C" {
    pub fn u_charName_73(
        code: UChar32,
        nameChoice: UCharNameChoice,
        buffer: *mut ::std::os::raw::c_char,
        bufferLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_getISOComment_73(
        c: UChar32,
        dest: *mut ::std::os::raw::c_char,
        destCapacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_charFromName_73(
        nameChoice: UCharNameChoice,
        name: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> UChar32;
}
pub type UEnumCharNamesFn =
    ::std::option::Option<
        unsafe extern "C" fn(context: *mut ::std::os::raw::c_void,
                             code: UChar32,
                             nameChoice: UCharNameChoice,
                             name: *const ::std::os::raw::c_char,
                             length: i32)
                             -> UBool,
    >;
extern "C" {
    pub fn u_enumCharNames_73(
        start: UChar32,
        limit: UChar32,
        fn_: UEnumCharNamesFn,
        context: *mut ::std::os::raw::c_void,
        nameChoice: UCharNameChoice,
        pErrorCode: *mut UErrorCode,
    );
}
extern "C" {
    pub fn u_getPropertyName_73(
        property: UProperty,
        nameChoice: UPropertyNameChoice,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_getPropertyEnum_73(alias: *const ::std::os::raw::c_char) -> UProperty;
}
extern "C" {
    pub fn u_getPropertyValueName_73(
        property: UProperty,
        value: i32,
        nameChoice: UPropertyNameChoice,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_getPropertyValueEnum_73(
        property: UProperty,
        alias: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    pub fn u_isIDStart_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isIDPart_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isIDIgnorable_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isJavaIDStart_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isJavaIDPart_73(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_tolower_73(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_toupper_73(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_totitle_73(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_foldCase_73(c: UChar32, options: u32) -> UChar32;
}
extern "C" {
    pub fn u_digit_73(ch: UChar32, radix: i8) -> i32;
}
extern "C" {
    pub fn u_forDigit_73(digit: i32, radix: i8) -> UChar32;
}
extern "C" {
    pub fn u_charAge_73(c: UChar32, versionArray: *mut u8);
}
extern "C" {
    pub fn u_getUnicodeVersion_73(versionArray: *mut u8);
}
extern "C" {
    pub fn u_getFC_NFKC_Closure_73(
        c: UChar32,
        dest: *mut UChar,
        destCapacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn utext_close_73(ut: *mut UText) -> *mut UText;
}
extern "C" {
    pub fn utext_openUTF8_73(
        ut: *mut UText,
        s: *const ::std::os::raw::c_char,
        length: i64,
        status: *mut UErrorCode,
    ) -> *mut UText;
}
extern "C" {
    pub fn utext_openUChars_73(
        ut: *mut UText,
        s: *const UChar,
        length: i64,
        status: *mut UErrorCode,
    ) -> *mut UText;
}
extern "C" {
    pub fn utext_clone_73(
        dest: *mut UText,
        src: *const UText,
        deep: UBool,
        readOnly: UBool,
        status: *mut UErrorCode,
    ) -> *mut UText;
}
extern "C" {
    pub fn utext_equals_73(a: *const UText, b: *const UText) -> UBool;
}
extern "C" {
    pub fn utext_nativeLength_73(ut: *mut UText) -> i64;
}
extern "C" {
    pub fn utext_isLengthExpensive_73(ut: *const UText) -> UBool;
}
extern "C" {
    pub fn utext_char32At_73(ut: *mut UText, nativeIndex: i64) -> UChar32;
}
extern "C" {
    pub fn utext_current32_73(ut: *mut UText) -> UChar32;
}
extern "C" {
    pub fn utext_next32_73(ut: *mut UText) -> UChar32;
}
extern "C" {
    pub fn utext_previous32_73(ut: *mut UText) -> UChar32;
}
extern "C" {
    pub fn utext_next32From_73(ut: *mut UText, nativeIndex: i64) -> UChar32;
}
extern "C" {
    pub fn utext_previous32From_73(ut: *mut UText, nativeIndex: i64) -> UChar32;
}
extern "C" {
    pub fn utext_getNativeIndex_73(ut: *const UText) -> i64;
}
extern "C" {
    pub fn utext_setNativeIndex_73(ut: *mut UText, nativeIndex: i64);
}
extern "C" {
    pub fn utext_moveIndex32_73(ut: *mut UText, delta: i32) -> UBool;
}
extern "C" {
    pub fn utext_getPreviousNativeIndex_73(ut: *mut UText) -> i64;
}
extern "C" {
    pub fn utext_extract_73(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        dest: *mut UChar,
        destCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn utext_isWritable_73(ut: *const UText) -> UBool;
}
extern "C" {
    pub fn utext_hasMetaData_73(ut: *const UText) -> UBool;
}
extern "C" {
    pub fn utext_replace_73(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        replacementText: *const UChar,
        replacementLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn utext_copy_73(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        destIndex: i64,
        move_: UBool,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn utext_freeze_73(ut: *mut UText);
}
pub type UTextClone = ::std::option::Option<
    unsafe extern "C" fn(dest: *mut UText,
                         src: *const UText,
                         deep: UBool,
                         status: *mut UErrorCode)
                         -> *mut UText,
>;
pub type UTextNativeLength = ::std::option::Option<unsafe extern "C" fn(ut: *mut UText) -> i64>;
pub type UTextAccess = ::std::option::Option<
    unsafe extern "C" fn(ut: *mut UText,
                         nativeIndex: i64,
                         forward: UBool)
                         -> UBool,
>;
pub type UTextExtract = ::std::option::Option<
    unsafe extern "C" fn(ut: *mut UText,
                         nativeStart: i64,
                         nativeLimit: i64,
                         dest: *mut UChar,
                         destCapacity: i32,
                         status: *mut UErrorCode)
                         -> i32,
>;
pub type UTextReplace = ::std::option::Option<
    unsafe extern "C" fn(ut: *mut UText,
                         nativeStart: i64,
                         nativeLimit: i64,
                         replacementText: *const UChar,
                         replacmentLength: i32,
                         status: *mut UErrorCode)
                         -> i32,
>;
pub type UTextCopy = ::std::option::Option<
    unsafe extern "C" fn(ut: *mut UText,
                         nativeStart: i64,
                         nativeLimit: i64,
                         nativeDest: i64,
                         move_: UBool,
                         status: *mut UErrorCode),
>;
pub type UTextMapOffsetToNative = ::std::option::Option<
    unsafe extern "C" fn(ut: *const UText)
                         -> i64,
>;
pub type UTextMapNativeIndexToUTF16 = ::std::option::Option<
    unsafe extern "C" fn(ut: *const UText,
                         nativeIndex: i64)
                         -> i32,
>;
pub type UTextClose = ::std::option::Option<unsafe extern "C" fn(ut: *mut UText)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UTextFuncs {
    pub tableSize: i32,
    pub reserved1: i32,
    pub reserved2: i32,
    pub reserved3: i32,
    pub clone: UTextClone,
    pub nativeLength: UTextNativeLength,
    pub access: UTextAccess,
    pub extract: UTextExtract,
    pub replace: UTextReplace,
    pub copy: UTextCopy,
    pub mapOffsetToNative: UTextMapOffsetToNative,
    pub mapNativeIndexToUTF16: UTextMapNativeIndexToUTF16,
    pub close: UTextClose,
    pub spare1: UTextClose,
    pub spare2: UTextClose,
    pub spare3: UTextClose,
}
#[test]
fn bindgen_test_layout_UTextFuncs() {
    assert_eq!(
        ::std::mem::size_of::<UTextFuncs>(),
        112usize,
        concat!("Size of: ", stringify!(UTextFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<UTextFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(UTextFuncs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).tableSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(tableSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).reserved1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).reserved2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).reserved3 as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).clone as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(clone)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).nativeLength as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(nativeLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).access as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(access)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).extract as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(extract)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).replace as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(replace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).copy as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(copy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).mapOffsetToNative as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(mapOffsetToNative)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).mapNativeIndexToUTF16 as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(mapNativeIndexToUTF16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).close as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(close)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).spare1 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(spare1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).spare2 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(spare2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).spare3 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(spare3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UText {
    pub magic: u32,
    pub flags: i32,
    pub providerProperties: i32,
    pub sizeOfStruct: i32,
    pub chunkNativeLimit: i64,
    pub extraSize: i32,
    pub nativeIndexingLimit: i32,
    pub chunkNativeStart: i64,
    pub chunkOffset: i32,
    pub chunkLength: i32,
    pub chunkContents: *const UChar,
    pub pFuncs: *const UTextFuncs,
    pub pExtra: *mut ::std::os::raw::c_void,
    pub context: *const ::std::os::raw::c_void,
    pub p: *const ::std::os::raw::c_void,
    pub q: *const ::std::os::raw::c_void,
    pub r: *const ::std::os::raw::c_void,
    pub privP: *mut ::std::os::raw::c_void,
    pub a: i64,
    pub b: i32,
    pub c: i32,
    pub privA: i64,
    pub privB: i32,
    pub privC: i32,
}
#[test]
fn bindgen_test_layout_UText() {
    assert_eq!(
        ::std::mem::size_of::<UText>(),
        144usize,
        concat!("Size of: ", stringify!(UText))
    );
    assert_eq!(
        ::std::mem::align_of::<UText>(),
        8usize,
        concat!("Alignment of ", stringify!(UText))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).providerProperties as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(providerProperties)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).sizeOfStruct as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(sizeOfStruct)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkNativeLimit as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(chunkNativeLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).extraSize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(extraSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).nativeIndexingLimit as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(nativeIndexingLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkNativeStart as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(chunkNativeStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkOffset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(chunkOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkLength as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(chunkLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkContents as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(chunkContents)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).pFuncs as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(pFuncs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).pExtra as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(pExtra)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).context as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).p as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).q as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(q))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).r as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).privP as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(privP)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).a as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(a))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).b as *const _ as usize },
        120usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(b))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).c as *const _ as usize },
        124usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(c))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).privA as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(privA)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).privB as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(privB)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).privC as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(UText),
            "::",
            stringify!(privC)
        )
    );
}
impl Default for UText {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn utext_setup_73(ut: *mut UText, extraSpace: i32, status: *mut UErrorCode) -> *mut UText;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UBreakIterator {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UParseError {
    pub line: i32,
    pub offset: i32,
    pub preContext: [UChar; 16usize],
    pub postContext: [UChar; 16usize],
}
#[test]
fn bindgen_test_layout_UParseError() {
    assert_eq!(
        ::std::mem::size_of::<UParseError>(),
        72usize,
        concat!("Size of: ", stringify!(UParseError))
    );
    assert_eq!(
        ::std::mem::align_of::<UParseError>(),
        4usize,
        concat!("Alignment of ", stringify!(UParseError))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UParseError>())).line as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UParseError),
            "::",
            stringify!(line)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UParseError>())).offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UParseError),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UParseError>())).preContext as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UParseError),
            "::",
            stringify!(preContext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UParseError>())).postContext as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UParseError),
            "::",
            stringify!(postContext)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UBreakIteratorType {
    UBRK_CHARACTER = 0,
    UBRK_WORD = 1,
    UBRK_LINE = 2,
    UBRK_SENTENCE = 3,
    UBRK_TITLE = 4,
    UBRK_COUNT = 5,
}
impl UWordBreak {
    pub const UBRK_WORD_NUMBER: UWordBreak = UWordBreak::UBRK_WORD_NONE_LIMIT;
}
impl UWordBreak {
    pub const UBRK_WORD_LETTER: UWordBreak = UWordBreak::UBRK_WORD_NUMBER_LIMIT;
}
impl UWordBreak {
    pub const UBRK_WORD_KANA: UWordBreak = UWordBreak::UBRK_WORD_LETTER_LIMIT;
}
impl UWordBreak {
    pub const UBRK_WORD_IDEO: UWordBreak = UWordBreak::UBRK_WORD_KANA_LIMIT;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UWordBreak {
    UBRK_WORD_NONE = 0,
    UBRK_WORD_NONE_LIMIT = 100,
    UBRK_WORD_NUMBER_LIMIT = 200,
    UBRK_WORD_LETTER_LIMIT = 300,
    UBRK_WORD_KANA_LIMIT = 400,
    UBRK_WORD_IDEO_LIMIT = 500,
}
impl ULineBreakTag {
    pub const UBRK_LINE_HARD: ULineBreakTag = ULineBreakTag::UBRK_LINE_SOFT_LIMIT;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum ULineBreakTag {
    UBRK_LINE_SOFT = 0,
    UBRK_LINE_SOFT_LIMIT = 100,
    UBRK_LINE_HARD_LIMIT = 200,
}
impl USentenceBreakTag {
    pub const UBRK_SENTENCE_SEP: USentenceBreakTag = USentenceBreakTag::UBRK_SENTENCE_TERM_LIMIT;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum USentenceBreakTag {
    UBRK_SENTENCE_TERM = 0,
    UBRK_SENTENCE_TERM_LIMIT = 100,
    UBRK_SENTENCE_SEP_LIMIT = 200,
}
extern "C" {
    pub fn ubrk_open_73(
        type_: UBreakIteratorType,
        locale: *const ::std::os::raw::c_char,
        text: *const UChar,
        textLength: i32,
        status: *mut UErrorCode,
    ) -> *mut UBreakIterator;
}
extern "C" {
    pub fn ubrk_openRules_73(
        rules: *const UChar,
        rulesLength: i32,
        text: *const UChar,
        textLength: i32,
        parseErr: *mut UParseError,
        status: *mut UErrorCode,
    ) -> *mut UBreakIterator;
}
extern "C" {
    pub fn ubrk_openBinaryRules_73(
        binaryRules: *const u8,
        rulesLength: i32,
        text: *const UChar,
        textLength: i32,
        status: *mut UErrorCode,
    ) -> *mut UBreakIterator;
}
extern "C" {
    pub fn ubrk_safeClone_73(
        bi: *const UBreakIterator,
        stackBuffer: *mut ::std::os::raw::c_void,
        pBufferSize: *mut i32,
        status: *mut UErrorCode,
    ) -> *mut UBreakIterator;
}
extern "C" {
    pub fn ubrk_clone_73(bi: *const UBreakIterator, status: *mut UErrorCode)
        -> *mut UBreakIterator;
}
extern "C" {
    pub fn ubrk_close_73(bi: *mut UBreakIterator);
}
extern "C" {
    pub fn ubrk_setText_73(
        bi: *mut UBreakIterator,
        text: *const UChar,
        textLength: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ubrk_setUText_73(bi: *mut UBreakIterator, text: *mut UText, status: *mut UErrorCode);
}
extern "C" {
    pub fn ubrk_current_73(bi: *const UBreakIterator) -> i32;
}
extern "C" {
    pub fn ubrk_next_73(bi: *mut UBreakIterator) -> i32;
}
extern "C" {
    pub fn ubrk_previous_73(bi: *mut UBreakIterator) -> i32;
}
extern "C" {
    pub fn ubrk_first_73(bi: *mut UBreakIterator) -> i32;
}
extern "C" {
    pub fn ubrk_last_73(bi: *mut UBreakIterator) -> i32;
}
extern "C" {
    pub fn ubrk_preceding_73(bi: *mut UBreakIterator, offset: i32) -> i32;
}
extern "C" {
    pub fn ubrk_following_73(bi: *mut UBreakIterator, offset: i32) -> i32;
}
extern "C" {
    pub fn ubrk_getAvailable_73(index: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ubrk_countAvailable_73() -> i32;
}
extern "C" {
    pub fn ubrk_isBoundary_73(bi: *mut UBreakIterator, offset: i32) -> UBool;
}
extern "C" {
    pub fn ubrk_getRuleStatus_73(bi: *mut UBreakIterator) -> i32;
}
extern "C" {
    pub fn ubrk_getRuleStatusVec_73(
        bi: *mut UBreakIterator,
        fillInVec: *mut i32,
        capacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ubrk_getLocaleByType_73(
        bi: *const UBreakIterator,
        type_: ULocDataLocaleType,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ubrk_refreshUText_73(bi: *mut UBreakIterator, text: *mut UText, status: *mut UErrorCode);
}
extern "C" {
    pub fn ubrk_getBinaryRules_73(
        bi: *mut UBreakIterator,
        binaryRules: *mut u8,
        rulesCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
pub type UCalendar = *mut ::std::os::raw::c_void;
impl UCalendarType {
    pub const UCAL_DEFAULT: UCalendarType = UCalendarType::UCAL_TRADITIONAL;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UCalendarType {
    UCAL_TRADITIONAL = 0,
    UCAL_GREGORIAN = 1,
}
impl UCalendarDateFields {
    pub const UCAL_DAY_OF_MONTH: UCalendarDateFields = UCalendarDateFields::UCAL_DATE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UCalendarDateFields {
    UCAL_ERA = 0,
    UCAL_YEAR = 1,
    UCAL_MONTH = 2,
    UCAL_WEEK_OF_YEAR = 3,
    UCAL_WEEK_OF_MONTH = 4,
    UCAL_DATE = 5,
    UCAL_DAY_OF_YEAR = 6,
    UCAL_DAY_OF_WEEK = 7,
    UCAL_DAY_OF_WEEK_IN_MONTH = 8,
    UCAL_AM_PM = 9,
    UCAL_HOUR = 10,
    UCAL_HOUR_OF_DAY = 11,
    UCAL_MINUTE = 12,
    UCAL_SECOND = 13,
    UCAL_MILLISECOND = 14,
    UCAL_ZONE_OFFSET = 15,
    UCAL_DST_OFFSET = 16,
    UCAL_YEAR_WOY = 17,
    UCAL_DOW_LOCAL = 18,
    UCAL_EXTENDED_YEAR = 19,
    UCAL_JULIAN_DAY = 20,
    UCAL_MILLISECONDS_IN_DAY = 21,
    UCAL_IS_LEAP_MONTH = 22,
    UCAL_ORDINAL_MONTH = 23,
    UCAL_FIELD_COUNT = 24,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UCalendarDaysOfWeek {
    UCAL_SUNDAY = 1,
    UCAL_MONDAY = 2,
    UCAL_TUESDAY = 3,
    UCAL_WEDNESDAY = 4,
    UCAL_THURSDAY = 5,
    UCAL_FRIDAY = 6,
    UCAL_SATURDAY = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UCalendarMonths {
    UCAL_JANUARY = 0,
    UCAL_FEBRUARY = 1,
    UCAL_MARCH = 2,
    UCAL_APRIL = 3,
    UCAL_MAY = 4,
    UCAL_JUNE = 5,
    UCAL_JULY = 6,
    UCAL_AUGUST = 7,
    UCAL_SEPTEMBER = 8,
    UCAL_OCTOBER = 9,
    UCAL_NOVEMBER = 10,
    UCAL_DECEMBER = 11,
    UCAL_UNDECIMBER = 12,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UCalendarAMPMs {
    UCAL_AM = 0,
    UCAL_PM = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum USystemTimeZoneType {
    UCAL_ZONE_TYPE_ANY = 0,
    UCAL_ZONE_TYPE_CANONICAL = 1,
    UCAL_ZONE_TYPE_CANONICAL_LOCATION = 2,
}
extern "C" {
    pub fn ucal_openTimeZoneIDEnumeration_73(
        zoneType: USystemTimeZoneType,
        region: *const ::std::os::raw::c_char,
        rawOffset: *const i32,
        ec: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucal_openTimeZones_73(ec: *mut UErrorCode) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucal_openCountryTimeZones_73(
        country: *const ::std::os::raw::c_char,
        ec: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucal_getDefaultTimeZone_73(
        result: *mut UChar,
        resultCapacity: i32,
        ec: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_setDefaultTimeZone_73(zoneID: *const UChar, ec: *mut UErrorCode);
}
extern "C" {
    pub fn ucal_getHostTimeZone_73(
        result: *mut UChar,
        resultCapacity: i32,
        ec: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_getDSTSavings_73(zoneID: *const UChar, ec: *mut UErrorCode) -> i32;
}
extern "C" {
    pub fn ucal_getNow_73() -> UDate;
}
extern "C" {
    pub fn ucal_open_73(
        zoneID: *const UChar,
        len: i32,
        locale: *const ::std::os::raw::c_char,
        type_: UCalendarType,
        status: *mut UErrorCode,
    ) -> *mut UCalendar;
}
extern "C" {
    pub fn ucal_close_73(cal: *mut UCalendar);
}
extern "C" {
    pub fn ucal_clone_73(cal: *const UCalendar, status: *mut UErrorCode) -> *mut UCalendar;
}
extern "C" {
    pub fn ucal_setTimeZone_73(
        cal: *mut UCalendar,
        zoneID: *const UChar,
        len: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_getTimeZoneID_73(
        cal: *const UCalendar,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UCalendarDisplayNameType {
    UCAL_STANDARD = 0,
    UCAL_SHORT_STANDARD = 1,
    UCAL_DST = 2,
    UCAL_SHORT_DST = 3,
}
extern "C" {
    pub fn ucal_getTimeZoneDisplayName_73(
        cal: *const UCalendar,
        type_: UCalendarDisplayNameType,
        locale: *const ::std::os::raw::c_char,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_inDaylightTime_73(cal: *const UCalendar, status: *mut UErrorCode) -> UBool;
}
extern "C" {
    pub fn ucal_setGregorianChange_73(
        cal: *mut UCalendar,
        date: UDate,
        pErrorCode: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_getGregorianChange_73(cal: *const UCalendar, pErrorCode: *mut UErrorCode) -> UDate;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UCalendarAttribute {
    UCAL_LENIENT = 0,
    UCAL_FIRST_DAY_OF_WEEK = 1,
    UCAL_MINIMAL_DAYS_IN_FIRST_WEEK = 2,
    UCAL_REPEATED_WALL_TIME = 3,
    UCAL_SKIPPED_WALL_TIME = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UCalendarWallTimeOption {
    UCAL_WALLTIME_LAST = 0,
    UCAL_WALLTIME_FIRST = 1,
    UCAL_WALLTIME_NEXT_VALID = 2,
}
extern "C" {
    pub fn ucal_getAttribute_73(cal: *const UCalendar, attr: UCalendarAttribute) -> i32;
}
extern "C" {
    pub fn ucal_setAttribute_73(cal: *mut UCalendar, attr: UCalendarAttribute, newValue: i32);
}
extern "C" {
    pub fn ucal_getAvailable_73(localeIndex: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucal_countAvailable_73() -> i32;
}
extern "C" {
    pub fn ucal_getMillis_73(cal: *const UCalendar, status: *mut UErrorCode) -> UDate;
}
extern "C" {
    pub fn ucal_setMillis_73(cal: *mut UCalendar, dateTime: UDate, status: *mut UErrorCode);
}
extern "C" {
    pub fn ucal_setDate_73(
        cal: *mut UCalendar,
        year: i32,
        month: i32,
        date: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_setDateTime_73(
        cal: *mut UCalendar,
        year: i32,
        month: i32,
        date: i32,
        hour: i32,
        minute: i32,
        second: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_equivalentTo_73(cal1: *const UCalendar, cal2: *const UCalendar) -> UBool;
}
extern "C" {
    pub fn ucal_add_73(
        cal: *mut UCalendar,
        field: UCalendarDateFields,
        amount: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_roll_73(
        cal: *mut UCalendar,
        field: UCalendarDateFields,
        amount: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_get_73(
        cal: *const UCalendar,
        field: UCalendarDateFields,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_set_73(cal: *mut UCalendar, field: UCalendarDateFields, value: i32);
}
extern "C" {
    pub fn ucal_isSet_73(cal: *const UCalendar, field: UCalendarDateFields) -> UBool;
}
extern "C" {
    pub fn ucal_clearField_73(cal: *mut UCalendar, field: UCalendarDateFields);
}
extern "C" {
    pub fn ucal_clear_73(calendar: *mut UCalendar);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UCalendarLimitType {
    UCAL_MINIMUM = 0,
    UCAL_MAXIMUM = 1,
    UCAL_GREATEST_MINIMUM = 2,
    UCAL_LEAST_MAXIMUM = 3,
    UCAL_ACTUAL_MINIMUM = 4,
    UCAL_ACTUAL_MAXIMUM = 5,
}
extern "C" {
    pub fn ucal_getLimit_73(
        cal: *const UCalendar,
        field: UCalendarDateFields,
        type_: UCalendarLimitType,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_getLocaleByType_73(
        cal: *const UCalendar,
        type_: ULocDataLocaleType,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucal_getTZDataVersion_73(status: *mut UErrorCode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucal_getCanonicalTimeZoneID_73(
        id: *const UChar,
        len: i32,
        result: *mut UChar,
        resultCapacity: i32,
        isSystemID: *mut UBool,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_getType_73(
        cal: *const UCalendar,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucal_getKeywordValuesForLocale_73(
        key: *const ::std::os::raw::c_char,
        locale: *const ::std::os::raw::c_char,
        commonlyUsed: UBool,
        status: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UCalendarWeekdayType {
    UCAL_WEEKDAY = 0,
    UCAL_WEEKEND = 1,
    UCAL_WEEKEND_ONSET = 2,
    UCAL_WEEKEND_CEASE = 3,
}
extern "C" {
    pub fn ucal_getDayOfWeekType_73(
        cal: *const UCalendar,
        dayOfWeek: UCalendarDaysOfWeek,
        status: *mut UErrorCode,
    ) -> UCalendarWeekdayType;
}
extern "C" {
    pub fn ucal_getWeekendTransition_73(
        cal: *const UCalendar,
        dayOfWeek: UCalendarDaysOfWeek,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_isWeekend_73(cal: *const UCalendar, date: UDate, status: *mut UErrorCode) -> UBool;
}
extern "C" {
    pub fn ucal_getFieldDifference_73(
        cal: *mut UCalendar,
        target: UDate,
        field: UCalendarDateFields,
        status: *mut UErrorCode,
    ) -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UTimeZoneTransitionType {
    UCAL_TZ_TRANSITION_NEXT = 0,
    UCAL_TZ_TRANSITION_NEXT_INCLUSIVE = 1,
    UCAL_TZ_TRANSITION_PREVIOUS = 2,
    UCAL_TZ_TRANSITION_PREVIOUS_INCLUSIVE = 3,
}
extern "C" {
    pub fn ucal_getTimeZoneTransitionDate_73(
        cal: *const UCalendar,
        type_: UTimeZoneTransitionType,
        transition: *mut UDate,
        status: *mut UErrorCode,
    ) -> UBool;
}
extern "C" {
    pub fn ucal_getWindowsTimeZoneID_73(
        id: *const UChar,
        len: i32,
        winid: *mut UChar,
        winidCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_getTimeZoneIDForWindowsID_73(
        winid: *const UChar,
        len: i32,
        region: *const ::std::os::raw::c_char,
        id: *mut UChar,
        idCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UTimeZoneLocalOption {
    UCAL_TZ_LOCAL_FORMER = 4,
    UCAL_TZ_LOCAL_LATTER = 12,
    UCAL_TZ_LOCAL_STANDARD_FORMER = 5,
    UCAL_TZ_LOCAL_STANDARD_LATTER = 13,
    UCAL_TZ_LOCAL_DAYLIGHT_FORMER = 7,
    UCAL_TZ_LOCAL_DAYLIGHT_LATTER = 15,
}
extern "C" {
    pub fn ucal_getTimeZoneOffsetFromLocal_73(
        cal: *const UCalendar,
        nonExistingTimeOpt: UTimeZoneLocalOption,
        duplicatedTimeOpt: UTimeZoneLocalOption,
        rawOffset: *mut i32,
        dstOffset: *mut i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn u_init_73(status: *mut UErrorCode);
}
extern "C" {
    pub fn u_cleanup_73();
}
pub type UMemAllocFn =
    ::std::option::Option<
        unsafe extern "C" fn(context: *const ::std::os::raw::c_void,
                             size: size_t)
                             -> *mut ::std::os::raw::c_void,
    >;
pub type UMemReallocFn =
    ::std::option::Option<
        unsafe extern "C" fn(context: *const ::std::os::raw::c_void,
                             mem: *mut ::std::os::raw::c_void,
                             size: size_t)
                             -> *mut ::std::os::raw::c_void,
    >;
pub type UMemFreeFn =
    ::std::option::Option<
        unsafe extern "C" fn(context: *const ::std::os::raw::c_void,
                             mem: *mut ::std::os::raw::c_void),
    >;
extern "C" {
    pub fn u_setMemoryFunctions_73(
        context: *const ::std::os::raw::c_void,
        a: UMemAllocFn,
        r: UMemReallocFn,
        f: UMemFreeFn,
        status: *mut UErrorCode,
    );
}
pub type UMTX = *mut ::std::os::raw::c_void;
pub type UMtxInitFn =
    ::std::option::Option<
        unsafe extern "C" fn(context: *const ::std::os::raw::c_void,
                             mutex: *mut UMTX,
                             status: *mut UErrorCode),
    >;
pub type UMtxFn =
    ::std::option::Option<
        unsafe extern "C" fn(context: *const ::std::os::raw::c_void,
                             mutex: *mut UMTX),
    >;
extern "C" {
    pub fn u_setMutexFunctions_73(
        context: *const ::std::os::raw::c_void,
        init: UMtxInitFn,
        destroy: UMtxFn,
        lock: UMtxFn,
        unlock: UMtxFn,
        status: *mut UErrorCode,
    );
}
pub type UMtxAtomicFn =
    ::std::option::Option<
        unsafe extern "C" fn(context: *const ::std::os::raw::c_void,
                             p: *mut i32)
                             -> i32,
    >;
extern "C" {
    pub fn u_setAtomicIncDecFunctions_73(
        context: *const ::std::os::raw::c_void,
        inc: UMtxAtomicFn,
        dec: UMtxAtomicFn,
        status: *mut UErrorCode,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UConverter {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UConverterCallbackReason {
    UCNV_UNASSIGNED = 0,
    UCNV_ILLEGAL = 1,
    UCNV_IRREGULAR = 2,
    UCNV_RESET = 3,
    UCNV_CLOSE = 4,
    UCNV_CLONE = 5,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UConverterFromUnicodeArgs {
    pub size: u16,
    pub flush: UBool,
    pub converter: *mut UConverter,
    pub source: *const UChar,
    pub sourceLimit: *const UChar,
    pub target: *mut ::std::os::raw::c_char,
    pub targetLimit: *const ::std::os::raw::c_char,
    pub offsets: *mut i32,
}
#[test]
fn bindgen_test_layout_UConverterFromUnicodeArgs() {
    assert_eq!(
        ::std::mem::size_of::<UConverterFromUnicodeArgs>(),
        56usize,
        concat!("Size of: ", stringify!(UConverterFromUnicodeArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<UConverterFromUnicodeArgs>(),
        8usize,
        concat!("Alignment of ", stringify!(UConverterFromUnicodeArgs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UConverterFromUnicodeArgs>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UConverterFromUnicodeArgs),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UConverterFromUnicodeArgs>())).flush as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(UConverterFromUnicodeArgs),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UConverterFromUnicodeArgs>())).converter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UConverterFromUnicodeArgs),
            "::",
            stringify!(converter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UConverterFromUnicodeArgs>())).source as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UConverterFromUnicodeArgs),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<UConverterFromUnicodeArgs>())).sourceLimit as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UConverterFromUnicodeArgs),
            "::",
            stringify!(sourceLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UConverterFromUnicodeArgs>())).target as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UConverterFromUnicodeArgs),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<UConverterFromUnicodeArgs>())).targetLimit as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UConverterFromUnicodeArgs),
            "::",
            stringify!(targetLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UConverterFromUnicodeArgs>())).offsets as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(UConverterFromUnicodeArgs),
            "::",
            stringify!(offsets)
        )
    );
}
impl Default for UConverterFromUnicodeArgs {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UConverterToUnicodeArgs {
    pub size: u16,
    pub flush: UBool,
    pub converter: *mut UConverter,
    pub source: *const ::std::os::raw::c_char,
    pub sourceLimit: *const ::std::os::raw::c_char,
    pub target: *mut UChar,
    pub targetLimit: *const UChar,
    pub offsets: *mut i32,
}
#[test]
fn bindgen_test_layout_UConverterToUnicodeArgs() {
    assert_eq!(
        ::std::mem::size_of::<UConverterToUnicodeArgs>(),
        56usize,
        concat!("Size of: ", stringify!(UConverterToUnicodeArgs))
    );
    assert_eq!(
        ::std::mem::align_of::<UConverterToUnicodeArgs>(),
        8usize,
        concat!("Alignment of ", stringify!(UConverterToUnicodeArgs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UConverterToUnicodeArgs>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UConverterToUnicodeArgs),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UConverterToUnicodeArgs>())).flush as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(UConverterToUnicodeArgs),
            "::",
            stringify!(flush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UConverterToUnicodeArgs>())).converter as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UConverterToUnicodeArgs),
            "::",
            stringify!(converter)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UConverterToUnicodeArgs>())).source as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UConverterToUnicodeArgs),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UConverterToUnicodeArgs>())).sourceLimit as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UConverterToUnicodeArgs),
            "::",
            stringify!(sourceLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UConverterToUnicodeArgs>())).target as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UConverterToUnicodeArgs),
            "::",
            stringify!(target)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UConverterToUnicodeArgs>())).targetLimit as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UConverterToUnicodeArgs),
            "::",
            stringify!(targetLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UConverterToUnicodeArgs>())).offsets as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(UConverterToUnicodeArgs),
            "::",
            stringify!(offsets)
        )
    );
}
impl Default for UConverterToUnicodeArgs {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl UConverterType {
    pub const UCNV_LMBCS_LAST: UConverterType = UConverterType::UCNV_LMBCS_19;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UConverterType {
    UCNV_UNSUPPORTED_CONVERTER = - 1,
    UCNV_SBCS = 0,
    UCNV_DBCS = 1,
    UCNV_MBCS = 2,
    UCNV_LATIN_1 = 3,
    UCNV_UTF8 = 4,
    UCNV_UTF16_BigEndian = 5,
    UCNV_UTF16_LittleEndian = 6,
    UCNV_UTF32_BigEndian = 7,
    UCNV_UTF32_LittleEndian = 8,
    UCNV_EBCDIC_STATEFUL = 9,
    UCNV_ISO_2022 = 10,
    UCNV_LMBCS_1 = 11,
    UCNV_LMBCS_2 = 12,
    UCNV_LMBCS_3 = 13,
    UCNV_LMBCS_4 = 14,
    UCNV_LMBCS_5 = 15,
    UCNV_LMBCS_6 = 16,
    UCNV_LMBCS_8 = 17,
    UCNV_LMBCS_11 = 18,
    UCNV_LMBCS_16 = 19,
    UCNV_LMBCS_17 = 20,
    UCNV_LMBCS_18 = 21,
    UCNV_LMBCS_19 = 22,
    UCNV_HZ = 23,
    UCNV_SCSU = 24,
    UCNV_ISCII = 25,
    UCNV_US_ASCII = 26,
    UCNV_UTF7 = 27,
    UCNV_BOCU1 = 28,
    UCNV_UTF16 = 29,
    UCNV_UTF32 = 30,
    UCNV_CESU8 = 31,
    UCNV_IMAP_MAILBOX = 32,
    UCNV_COMPOUND_TEXT = 33,
    UCNV_NUMBER_OF_SUPPORTED_CONVERTER_TYPES = 34,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UConverterPlatform {
    UCNV_UNKNOWN = - 1,
    UCNV_IBM = 0,
}
pub type UConverterToUCallback =
    ::std::option::Option<
        unsafe extern "C" fn(context: *const ::std::os::raw::c_void,
                             args: *mut UConverterToUnicodeArgs,
                             codeUnits: *const ::std::os::raw::c_char,
                             length: i32,
                             reason: UConverterCallbackReason,
                             pErrorCode: *mut UErrorCode),
    >;
pub type UConverterFromUCallback =
    ::std::option::Option<
        unsafe extern "C" fn(context: *const ::std::os::raw::c_void,
                             args: *mut UConverterFromUnicodeArgs,
                             codeUnits: *const UChar,
                             length: i32,
                             codePoint: UChar32,
                             reason: UConverterCallbackReason,
                             pErrorCode: *mut UErrorCode),
    >;
extern "C" {
    pub fn ucnv_compareNames_73(
        name1: *const ::std::os::raw::c_char,
        name2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ucnv_open_73(
        converterName: *const ::std::os::raw::c_char,
        err: *mut UErrorCode,
    ) -> *mut UConverter;
}
extern "C" {
    pub fn ucnv_openU_73(name: *const UChar, err: *mut UErrorCode) -> *mut UConverter;
}
extern "C" {
    pub fn ucnv_openCCSID_73(
        codepage: i32,
        platform: UConverterPlatform,
        err: *mut UErrorCode,
    ) -> *mut UConverter;
}
extern "C" {
    pub fn ucnv_openPackage_73(
        packageName: *const ::std::os::raw::c_char,
        converterName: *const ::std::os::raw::c_char,
        err: *mut UErrorCode,
    ) -> *mut UConverter;
}
extern "C" {
    pub fn ucnv_clone_73(cnv: *const UConverter, status: *mut UErrorCode) -> *mut UConverter;
}
extern "C" {
    pub fn ucnv_safeClone_73(
        cnv: *const UConverter,
        stackBuffer: *mut ::std::os::raw::c_void,
        pBufferSize: *mut i32,
        status: *mut UErrorCode,
    ) -> *mut UConverter;
}
extern "C" {
    pub fn ucnv_close_73(converter: *mut UConverter);
}
extern "C" {
    pub fn ucnv_getSubstChars_73(
        converter: *const UConverter,
        subChars: *mut ::std::os::raw::c_char,
        len: *mut i8,
        err: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucnv_setSubstChars_73(
        converter: *mut UConverter,
        subChars: *const ::std::os::raw::c_char,
        len: i8,
        err: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucnv_setSubstString_73(
        cnv: *mut UConverter,
        s: *const UChar,
        length: i32,
        err: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucnv_getInvalidChars_73(
        converter: *const UConverter,
        errBytes: *mut ::std::os::raw::c_char,
        len: *mut i8,
        err: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucnv_getInvalidUChars_73(
        converter: *const UConverter,
        errUChars: *mut UChar,
        len: *mut i8,
        err: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucnv_reset_73(converter: *mut UConverter);
}
extern "C" {
    pub fn ucnv_resetToUnicode_73(converter: *mut UConverter);
}
extern "C" {
    pub fn ucnv_resetFromUnicode_73(converter: *mut UConverter);
}
extern "C" {
    pub fn ucnv_getMaxCharSize_73(converter: *const UConverter) -> i8;
}
extern "C" {
    pub fn ucnv_getMinCharSize_73(converter: *const UConverter) -> i8;
}
extern "C" {
    pub fn ucnv_getDisplayName_73(
        converter: *const UConverter,
        displayLocale: *const ::std::os::raw::c_char,
        displayName: *mut UChar,
        displayNameCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucnv_getName_73(
        converter: *const UConverter,
        err: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucnv_getCCSID_73(converter: *const UConverter, err: *mut UErrorCode) -> i32;
}
extern "C" {
    pub fn ucnv_getPlatform_73(
        converter: *const UConverter,
        err: *mut UErrorCode,
    ) -> UConverterPlatform;
}
extern "C" {
    pub fn ucnv_getType_73(converter: *const UConverter) -> UConverterType;
}
extern "C" {
    pub fn ucnv_getStarters_73(
        converter: *const UConverter,
        starters: *mut UBool,
        err: *mut UErrorCode,
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UConverterUnicodeSet {
    UCNV_ROUNDTRIP_SET = 0,
    UCNV_ROUNDTRIP_AND_FALLBACK_SET = 1,
    UCNV_SET_COUNT = 2,
}
extern "C" {
    pub fn ucnv_getUnicodeSet_73(
        cnv: *const UConverter,
        setFillIn: *mut USet,
        whichSet: UConverterUnicodeSet,
        pErrorCode: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucnv_getToUCallBack_73(
        converter: *const UConverter,
        action: *mut UConverterToUCallback,
        context: *mut *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ucnv_getFromUCallBack_73(
        converter: *const UConverter,
        action: *mut UConverterFromUCallback,
        context: *mut *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn ucnv_setToUCallBack_73(
        converter: *mut UConverter,
        newAction: UConverterToUCallback,
        newContext: *const ::std::os::raw::c_void,
        oldAction: *mut UConverterToUCallback,
        oldContext: *mut *const ::std::os::raw::c_void,
        err: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucnv_setFromUCallBack_73(
        converter: *mut UConverter,
        newAction: UConverterFromUCallback,
        newContext: *const ::std::os::raw::c_void,
        oldAction: *mut UConverterFromUCallback,
        oldContext: *mut *const ::std::os::raw::c_void,
        err: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucnv_fromUnicode_73(
        converter: *mut UConverter,
        target: *mut *mut ::std::os::raw::c_char,
        targetLimit: *const ::std::os::raw::c_char,
        source: *mut *const UChar,
        sourceLimit: *const UChar,
        offsets: *mut i32,
        flush: UBool,
        err: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucnv_toUnicode_73(
        converter: *mut UConverter,
        target: *mut *mut UChar,
        targetLimit: *const UChar,
        source: *mut *const ::std::os::raw::c_char,
        sourceLimit: *const ::std::os::raw::c_char,
        offsets: *mut i32,
        flush: UBool,
        err: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucnv_fromUChars_73(
        cnv: *mut UConverter,
        dest: *mut ::std::os::raw::c_char,
        destCapacity: i32,
        src: *const UChar,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucnv_toUChars_73(
        cnv: *mut UConverter,
        dest: *mut UChar,
        destCapacity: i32,
        src: *const ::std::os::raw::c_char,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucnv_getNextUChar_73(
        converter: *mut UConverter,
        source: *mut *const ::std::os::raw::c_char,
        sourceLimit: *const ::std::os::raw::c_char,
        err: *mut UErrorCode,
    ) -> UChar32;
}
extern "C" {
    pub fn ucnv_convertEx_73(
        targetCnv: *mut UConverter,
        sourceCnv: *mut UConverter,
        target: *mut *mut ::std::os::raw::c_char,
        targetLimit: *const ::std::os::raw::c_char,
        source: *mut *const ::std::os::raw::c_char,
        sourceLimit: *const ::std::os::raw::c_char,
        pivotStart: *mut UChar,
        pivotSource: *mut *mut UChar,
        pivotTarget: *mut *mut UChar,
        pivotLimit: *const UChar,
        reset: UBool,
        flush: UBool,
        pErrorCode: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucnv_convert_73(
        toConverterName: *const ::std::os::raw::c_char,
        fromConverterName: *const ::std::os::raw::c_char,
        target: *mut ::std::os::raw::c_char,
        targetCapacity: i32,
        source: *const ::std::os::raw::c_char,
        sourceLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucnv_toAlgorithmic_73(
        algorithmicType: UConverterType,
        cnv: *mut UConverter,
        target: *mut ::std::os::raw::c_char,
        targetCapacity: i32,
        source: *const ::std::os::raw::c_char,
        sourceLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucnv_fromAlgorithmic_73(
        cnv: *mut UConverter,
        algorithmicType: UConverterType,
        target: *mut ::std::os::raw::c_char,
        targetCapacity: i32,
        source: *const ::std::os::raw::c_char,
        sourceLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucnv_flushCache_73() -> i32;
}
extern "C" {
    pub fn ucnv_countAvailable_73() -> i32;
}
extern "C" {
    pub fn ucnv_getAvailableName_73(n: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucnv_openAllNames_73(pErrorCode: *mut UErrorCode) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucnv_countAliases_73(
        alias: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> u16;
}
extern "C" {
    pub fn ucnv_getAlias_73(
        alias: *const ::std::os::raw::c_char,
        n: u16,
        pErrorCode: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucnv_getAliases_73(
        alias: *const ::std::os::raw::c_char,
        aliases: *mut *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucnv_openStandardNames_73(
        convName: *const ::std::os::raw::c_char,
        standard: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucnv_countStandards_73() -> u16;
}
extern "C" {
    pub fn ucnv_getStandard_73(
        n: u16,
        pErrorCode: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucnv_getStandardName_73(
        name: *const ::std::os::raw::c_char,
        standard: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucnv_getCanonicalName_73(
        alias: *const ::std::os::raw::c_char,
        standard: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucnv_getDefaultName_73() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucnv_setDefaultName_73(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn ucnv_fixFileSeparator_73(cnv: *const UConverter, source: *mut UChar, sourceLen: i32);
}
extern "C" {
    pub fn ucnv_isAmbiguous_73(cnv: *const UConverter) -> UBool;
}
extern "C" {
    pub fn ucnv_setFallback_73(cnv: *mut UConverter, usesFallback: UBool);
}
extern "C" {
    pub fn ucnv_usesFallback_73(cnv: *const UConverter) -> UBool;
}
extern "C" {
    pub fn ucnv_detectUnicodeSignature_73(
        source: *const ::std::os::raw::c_char,
        sourceLength: i32,
        signatureLength: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucnv_fromUCountPending_73(cnv: *const UConverter, status: *mut UErrorCode) -> i32;
}
extern "C" {
    pub fn ucnv_toUCountPending_73(cnv: *const UConverter, status: *mut UErrorCode) -> i32;
}
extern "C" {
    pub fn ucnv_isFixedWidth_73(cnv: *mut UConverter, status: *mut UErrorCode) -> UBool;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UCharIteratorOrigin {
    UITER_START = 0,
    UITER_CURRENT = 1,
    UITER_LIMIT = 2,
    UITER_ZERO = 3,
    UITER_LENGTH = 4,
}
pub type UCharIteratorGetIndex =
    ::std::option::Option<
        unsafe extern "C" fn(iter: *mut UCharIterator,
                             origin: UCharIteratorOrigin)
                             -> i32,
    >;
pub type UCharIteratorMove =
    ::std::option::Option<
        unsafe extern "C" fn(iter: *mut UCharIterator,
                             delta: i32,
                             origin: UCharIteratorOrigin)
                             -> i32,
    >;
pub type UCharIteratorHasNext =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UBool>;
pub type UCharIteratorHasPrevious =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UBool>;
pub type UCharIteratorCurrent =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UChar32>;
pub type UCharIteratorNext = ::std::option::Option<
    unsafe extern "C" fn(iter: *mut UCharIterator)
                         -> UChar32,
>;
pub type UCharIteratorPrevious =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UChar32>;
pub type UCharIteratorReserved =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator, something: i32) -> i32>;
pub type UCharIteratorGetState =
    ::std::option::Option<unsafe extern "C" fn(iter: *const UCharIterator) -> u32>;
pub type UCharIteratorSetState =
    ::std::option::Option<
        unsafe extern "C" fn(iter: *mut UCharIterator,
                             state: u32,
                             pErrorCode: *mut UErrorCode),
    >;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UCharIterator {
    pub context: *const ::std::os::raw::c_void,
    pub length: i32,
    pub start: i32,
    pub index: i32,
    pub limit: i32,
    pub reservedField: i32,
    pub getIndex: UCharIteratorGetIndex,
    pub move_: UCharIteratorMove,
    pub hasNext: UCharIteratorHasNext,
    pub hasPrevious: UCharIteratorHasPrevious,
    pub current: UCharIteratorCurrent,
    pub next: UCharIteratorNext,
    pub previous: UCharIteratorPrevious,
    pub reservedFn: UCharIteratorReserved,
    pub getState: UCharIteratorGetState,
    pub setState: UCharIteratorSetState,
}
#[test]
fn bindgen_test_layout_UCharIterator() {
    assert_eq!(
        ::std::mem::size_of::<UCharIterator>(),
        112usize,
        concat!("Size of: ", stringify!(UCharIterator))
    );
    assert_eq!(
        ::std::mem::align_of::<UCharIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(UCharIterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).start as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).index as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).limit as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).reservedField as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(reservedField)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).getIndex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(getIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).move_ as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(move_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).hasNext as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(hasNext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).hasPrevious as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(hasPrevious)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).current as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).next as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).previous as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(previous)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).reservedFn as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(reservedFn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).getState as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(getState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).setState as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(UCharIterator),
            "::",
            stringify!(setState)
        )
    );
}
impl Default for UCharIterator {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum USetSpanCondition {
    USET_SPAN_NOT_CONTAINED = 0,
    USET_SPAN_CONTAINED = 1,
    USET_SPAN_SIMPLE = 2,
    USET_SPAN_CONDITION_COUNT = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UNormalization2Mode {
    UNORM2_COMPOSE = 0,
    UNORM2_DECOMPOSE = 1,
    UNORM2_FCD = 2,
    UNORM2_COMPOSE_CONTIGUOUS = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UNormalizationCheckResult {
    UNORM_NO = 0,
    UNORM_YES = 1,
    UNORM_MAYBE = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UNormalizer2 {
    _unused: [u8; 0],
}
extern "C" {
    pub fn unorm2_getNFCInstance_73(pErrorCode: *mut UErrorCode) -> *const UNormalizer2;
}
extern "C" {
    pub fn unorm2_getNFDInstance_73(pErrorCode: *mut UErrorCode) -> *const UNormalizer2;
}
extern "C" {
    pub fn unorm2_getNFKCInstance_73(pErrorCode: *mut UErrorCode) -> *const UNormalizer2;
}
extern "C" {
    pub fn unorm2_getNFKDInstance_73(pErrorCode: *mut UErrorCode) -> *const UNormalizer2;
}
extern "C" {
    pub fn unorm2_getNFKCCasefoldInstance_73(pErrorCode: *mut UErrorCode) -> *const UNormalizer2;
}
extern "C" {
    pub fn unorm2_getInstance_73(
        packageName: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        mode: UNormalization2Mode,
        pErrorCode: *mut UErrorCode,
    ) -> *const UNormalizer2;
}
extern "C" {
    pub fn unorm2_openFiltered_73(
        norm2: *const UNormalizer2,
        filterSet: *const USet,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UNormalizer2;
}
extern "C" {
    pub fn unorm2_close_73(norm2: *mut UNormalizer2);
}
extern "C" {
    pub fn unorm2_normalize_73(
        norm2: *const UNormalizer2,
        src: *const UChar,
        length: i32,
        dest: *mut UChar,
        capacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unorm2_normalizeSecondAndAppend_73(
        norm2: *const UNormalizer2,
        first: *mut UChar,
        firstLength: i32,
        firstCapacity: i32,
        second: *const UChar,
        secondLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unorm2_append_73(
        norm2: *const UNormalizer2,
        first: *mut UChar,
        firstLength: i32,
        firstCapacity: i32,
        second: *const UChar,
        secondLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unorm2_getDecomposition_73(
        norm2: *const UNormalizer2,
        c: UChar32,
        decomposition: *mut UChar,
        capacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unorm2_getRawDecomposition_73(
        norm2: *const UNormalizer2,
        c: UChar32,
        decomposition: *mut UChar,
        capacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unorm2_composePair_73(norm2: *const UNormalizer2, a: UChar32, b: UChar32) -> UChar32;
}
extern "C" {
    pub fn unorm2_getCombiningClass_73(norm2: *const UNormalizer2, c: UChar32) -> u8;
}
extern "C" {
    pub fn unorm2_isNormalized_73(
        norm2: *const UNormalizer2,
        s: *const UChar,
        length: i32,
        pErrorCode: *mut UErrorCode,
    ) -> UBool;
}
extern "C" {
    pub fn unorm2_quickCheck_73(
        norm2: *const UNormalizer2,
        s: *const UChar,
        length: i32,
        pErrorCode: *mut UErrorCode,
    ) -> UNormalizationCheckResult;
}
extern "C" {
    pub fn unorm2_spanQuickCheckYes_73(
        norm2: *const UNormalizer2,
        s: *const UChar,
        length: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unorm2_hasBoundaryBefore_73(norm2: *const UNormalizer2, c: UChar32) -> UBool;
}
extern "C" {
    pub fn unorm2_hasBoundaryAfter_73(norm2: *const UNormalizer2, c: UChar32) -> UBool;
}
extern "C" {
    pub fn unorm2_isInert_73(norm2: *const UNormalizer2, c: UChar32) -> UBool;
}
impl UNormalizationMode {
    pub const UNORM_DEFAULT: UNormalizationMode = UNormalizationMode::UNORM_NFC;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UNormalizationMode {
    UNORM_NONE = 1,
    UNORM_NFD = 2,
    UNORM_NFKD = 3,
    UNORM_NFC = 4,
    UNORM_NFKC = 5,
    UNORM_FCD = 6,
    UNORM_MODE_COUNT = 7,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UCollator {
    _unused: [u8; 0],
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UCollationResult {
    UCOL_EQUAL = 0,
    UCOL_GREATER = 1,
    UCOL_LESS = - 1,
}
impl UColAttributeValue {
    pub const UCOL_DEFAULT_STRENGTH: UColAttributeValue = UColAttributeValue::UCOL_TERTIARY;
}
impl UColAttributeValue {
    pub const UCOL_QUATERNARY: UColAttributeValue = UColAttributeValue::UCOL_CE_STRENGTH_LIMIT;
}
impl UColAttributeValue {
    pub const UCOL_OFF: UColAttributeValue = UColAttributeValue::UCOL_STRENGTH_LIMIT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UColAttributeValue {
    UCOL_DEFAULT = - 1,
    UCOL_PRIMARY = 0,
    UCOL_SECONDARY = 1,
    UCOL_TERTIARY = 2,
    UCOL_CE_STRENGTH_LIMIT = 3,
    UCOL_IDENTICAL = 15,
    UCOL_STRENGTH_LIMIT = 16,
    UCOL_ON = 17,
    UCOL_SHIFTED = 20,
    UCOL_NON_IGNORABLE = 21,
    UCOL_LOWER_FIRST = 24,
    UCOL_UPPER_FIRST = 25,
    UCOL_ATTRIBUTE_VALUE_COUNT = 26,
}
impl UColReorderCode {
    pub const UCOL_REORDER_CODE_OTHERS: UColReorderCode = UColReorderCode::UCOL_REORDER_CODE_NONE;
}
impl UColReorderCode {
    pub const UCOL_REORDER_CODE_FIRST: UColReorderCode = UColReorderCode::UCOL_REORDER_CODE_SPACE;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UColReorderCode {
    UCOL_REORDER_CODE_DEFAULT = - 1,
    UCOL_REORDER_CODE_NONE = 103,
    UCOL_REORDER_CODE_SPACE = 4096,
    UCOL_REORDER_CODE_PUNCTUATION = 4097,
    UCOL_REORDER_CODE_SYMBOL = 4098,
    UCOL_REORDER_CODE_CURRENCY = 4099,
    UCOL_REORDER_CODE_DIGIT = 4100,
    UCOL_REORDER_CODE_LIMIT = 4101,
}
pub use self::UColAttributeValue as UCollationStrength;
impl UColAttribute {
    pub const UCOL_DECOMPOSITION_MODE: UColAttribute = UColAttribute::UCOL_NORMALIZATION_MODE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UColAttribute {
    UCOL_FRENCH_COLLATION = 0,
    UCOL_ALTERNATE_HANDLING = 1,
    UCOL_CASE_FIRST = 2,
    UCOL_CASE_LEVEL = 3,
    UCOL_NORMALIZATION_MODE = 4,
    UCOL_STRENGTH = 5,
    UCOL_HIRAGANA_QUATERNARY_MODE = 6,
    UCOL_NUMERIC_COLLATION = 7,
    UCOL_ATTRIBUTE_COUNT = 8,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UColRuleOption {
    UCOL_TAILORING_ONLY = 0,
    UCOL_FULL_RULES = 1,
}
extern "C" {
    pub fn ucol_open_73(
        loc: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> *mut UCollator;
}
extern "C" {
    pub fn ucol_openRules_73(
        rules: *const UChar,
        rulesLength: i32,
        normalizationMode: UColAttributeValue,
        strength: UCollationStrength,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
    ) -> *mut UCollator;
}
extern "C" {
    pub fn ucol_openFromShortString_73(
        definition: *const ::std::os::raw::c_char,
        forceDefaults: UBool,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
    ) -> *mut UCollator;
}
extern "C" {
    pub fn ucol_getContractions_73(
        coll: *const UCollator,
        conts: *mut USet,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_getContractionsAndExpansions_73(
        coll: *const UCollator,
        contractions: *mut USet,
        expansions: *mut USet,
        addPrefixes: UBool,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucol_close_73(coll: *mut UCollator);
}
extern "C" {
    pub fn ucol_strcoll_73(
        coll: *const UCollator,
        source: *const UChar,
        sourceLength: i32,
        target: *const UChar,
        targetLength: i32,
    ) -> UCollationResult;
}
extern "C" {
    pub fn ucol_strcollUTF8_73(
        coll: *const UCollator,
        source: *const ::std::os::raw::c_char,
        sourceLength: i32,
        target: *const ::std::os::raw::c_char,
        targetLength: i32,
        status: *mut UErrorCode,
    ) -> UCollationResult;
}
extern "C" {
    pub fn ucol_greater_73(
        coll: *const UCollator,
        source: *const UChar,
        sourceLength: i32,
        target: *const UChar,
        targetLength: i32,
    ) -> UBool;
}
extern "C" {
    pub fn ucol_greaterOrEqual_73(
        coll: *const UCollator,
        source: *const UChar,
        sourceLength: i32,
        target: *const UChar,
        targetLength: i32,
    ) -> UBool;
}
extern "C" {
    pub fn ucol_equal_73(
        coll: *const UCollator,
        source: *const UChar,
        sourceLength: i32,
        target: *const UChar,
        targetLength: i32,
    ) -> UBool;
}
extern "C" {
    pub fn ucol_strcollIter_73(
        coll: *const UCollator,
        sIter: *mut UCharIterator,
        tIter: *mut UCharIterator,
        status: *mut UErrorCode,
    ) -> UCollationResult;
}
extern "C" {
    pub fn ucol_getStrength_73(coll: *const UCollator) -> UCollationStrength;
}
extern "C" {
    pub fn ucol_setStrength_73(coll: *mut UCollator, strength: UCollationStrength);
}
extern "C" {
    pub fn ucol_getReorderCodes_73(
        coll: *const UCollator,
        dest: *mut i32,
        destCapacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_setReorderCodes_73(
        coll: *mut UCollator,
        reorderCodes: *const i32,
        reorderCodesLength: i32,
        pErrorCode: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucol_getEquivalentReorderCodes_73(
        reorderCode: i32,
        dest: *mut i32,
        destCapacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_getDisplayName_73(
        objLoc: *const ::std::os::raw::c_char,
        dispLoc: *const ::std::os::raw::c_char,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_getAvailable_73(localeIndex: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucol_countAvailable_73() -> i32;
}
extern "C" {
    pub fn ucol_openAvailableLocales_73(status: *mut UErrorCode) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucol_getKeywords_73(status: *mut UErrorCode) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucol_getKeywordValues_73(
        keyword: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucol_getKeywordValuesForLocale_73(
        key: *const ::std::os::raw::c_char,
        locale: *const ::std::os::raw::c_char,
        commonlyUsed: UBool,
        status: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucol_getFunctionalEquivalent_73(
        result: *mut ::std::os::raw::c_char,
        resultCapacity: i32,
        keyword: *const ::std::os::raw::c_char,
        locale: *const ::std::os::raw::c_char,
        isAvailable: *mut UBool,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_getRules_73(coll: *const UCollator, length: *mut i32) -> *const UChar;
}
extern "C" {
    pub fn ucol_getShortDefinitionString_73(
        coll: *const UCollator,
        locale: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        capacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_normalizeShortDefinitionString_73(
        source: *const ::std::os::raw::c_char,
        destination: *mut ::std::os::raw::c_char,
        capacity: i32,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_getSortKey_73(
        coll: *const UCollator,
        source: *const UChar,
        sourceLength: i32,
        result: *mut u8,
        resultLength: i32,
    ) -> i32;
}
extern "C" {
    pub fn ucol_nextSortKeyPart_73(
        coll: *const UCollator,
        iter: *mut UCharIterator,
        state: *mut u32,
        dest: *mut u8,
        count: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UColBoundMode {
    UCOL_BOUND_LOWER = 0,
    UCOL_BOUND_UPPER = 1,
    UCOL_BOUND_UPPER_LONG = 2,
    UCOL_BOUND_VALUE_COUNT = 3,
}
extern "C" {
    pub fn ucol_getBound_73(
        source: *const u8,
        sourceLength: i32,
        boundType: UColBoundMode,
        noOfLevels: u32,
        result: *mut u8,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_getVersion_73(coll: *const UCollator, info: *mut u8);
}
extern "C" {
    pub fn ucol_getUCAVersion_73(coll: *const UCollator, info: *mut u8);
}
extern "C" {
    pub fn ucol_mergeSortkeys_73(
        src1: *const u8,
        src1Length: i32,
        src2: *const u8,
        src2Length: i32,
        dest: *mut u8,
        destCapacity: i32,
    ) -> i32;
}
extern "C" {
    pub fn ucol_setAttribute_73(
        coll: *mut UCollator,
        attr: UColAttribute,
        value: UColAttributeValue,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucol_getAttribute_73(
        coll: *const UCollator,
        attr: UColAttribute,
        status: *mut UErrorCode,
    ) -> UColAttributeValue;
}
extern "C" {
    pub fn ucol_setMaxVariable_73(
        coll: *mut UCollator,
        group: UColReorderCode,
        pErrorCode: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucol_getMaxVariable_73(coll: *const UCollator) -> UColReorderCode;
}
extern "C" {
    pub fn ucol_setVariableTop_73(
        coll: *mut UCollator,
        varTop: *const UChar,
        len: i32,
        status: *mut UErrorCode,
    ) -> u32;
}
extern "C" {
    pub fn ucol_getVariableTop_73(coll: *const UCollator, status: *mut UErrorCode) -> u32;
}
extern "C" {
    pub fn ucol_restoreVariableTop_73(coll: *mut UCollator, varTop: u32, status: *mut UErrorCode);
}
extern "C" {
    pub fn ucol_clone_73(coll: *const UCollator, status: *mut UErrorCode) -> *mut UCollator;
}
extern "C" {
    pub fn ucol_safeClone_73(
        coll: *const UCollator,
        stackBuffer: *mut ::std::os::raw::c_void,
        pBufferSize: *mut i32,
        status: *mut UErrorCode,
    ) -> *mut UCollator;
}
extern "C" {
    pub fn ucol_getRulesEx_73(
        coll: *const UCollator,
        delta: UColRuleOption,
        buffer: *mut UChar,
        bufferLen: i32,
    ) -> i32;
}
extern "C" {
    pub fn ucol_getLocale_73(
        coll: *const UCollator,
        type_: ULocDataLocaleType,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucol_getLocaleByType_73(
        coll: *const UCollator,
        type_: ULocDataLocaleType,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucol_getTailoredSet_73(coll: *const UCollator, status: *mut UErrorCode) -> *mut USet;
}
extern "C" {
    pub fn ucol_getUnsafeSet_73(
        coll: *const UCollator,
        unsafe_: *mut USet,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_prepareShortStringOpen_73(
        definition: *const ::std::os::raw::c_char,
        forceDefaults: UBool,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucol_cloneBinary_73(
        coll: *const UCollator,
        buffer: *mut u8,
        capacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucol_openBinary_73(
        bin: *const u8,
        length: i32,
        base: *const UCollator,
        status: *mut UErrorCode,
    ) -> *mut UCollator;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UFieldPosition {
    pub field: i32,
    pub beginIndex: i32,
    pub endIndex: i32,
}
#[test]
fn bindgen_test_layout_UFieldPosition() {
    assert_eq!(
        ::std::mem::size_of::<UFieldPosition>(),
        12usize,
        concat!("Size of: ", stringify!(UFieldPosition))
    );
    assert_eq!(
        ::std::mem::align_of::<UFieldPosition>(),
        4usize,
        concat!("Alignment of ", stringify!(UFieldPosition))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UFieldPosition>())).field as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UFieldPosition),
            "::",
            stringify!(field)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UFieldPosition>())).beginIndex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UFieldPosition),
            "::",
            stringify!(beginIndex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UFieldPosition>())).endIndex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UFieldPosition),
            "::",
            stringify!(endIndex)
        )
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UFormattableType {
    UFMT_DATE = 0,
    UFMT_DOUBLE = 1,
    UFMT_LONG = 2,
    UFMT_STRING = 3,
    UFMT_ARRAY = 4,
    UFMT_INT64 = 5,
    UFMT_OBJECT = 6,
    UFMT_COUNT = 7,
}
pub type UFormattable = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn ufmt_open_73(status: *mut UErrorCode) -> *mut UFormattable;
}
extern "C" {
    pub fn ufmt_close_73(fmt: *mut UFormattable);
}
extern "C" {
    pub fn ufmt_getType_73(fmt: *const UFormattable, status: *mut UErrorCode) -> UFormattableType;
}
extern "C" {
    pub fn ufmt_isNumeric_73(fmt: *const UFormattable) -> UBool;
}
extern "C" {
    pub fn ufmt_getDate_73(fmt: *const UFormattable, status: *mut UErrorCode) -> UDate;
}
extern "C" {
    pub fn ufmt_getDouble_73(fmt: *mut UFormattable, status: *mut UErrorCode) -> f64;
}
extern "C" {
    pub fn ufmt_getLong_73(fmt: *mut UFormattable, status: *mut UErrorCode) -> i32;
}
extern "C" {
    pub fn ufmt_getInt64_73(fmt: *mut UFormattable, status: *mut UErrorCode) -> i64;
}
extern "C" {
    pub fn ufmt_getObject_73(
        fmt: *const UFormattable,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn ufmt_getUChars_73(
        fmt: *mut UFormattable,
        len: *mut i32,
        status: *mut UErrorCode,
    ) -> *const UChar;
}
extern "C" {
    pub fn ufmt_getArrayLength_73(fmt: *const UFormattable, status: *mut UErrorCode) -> i32;
}
extern "C" {
    pub fn ufmt_getArrayItemByIndex_73(
        fmt: *mut UFormattable,
        n: i32,
        status: *mut UErrorCode,
    ) -> *mut UFormattable;
}
extern "C" {
    pub fn ufmt_getDecNumChars_73(
        fmt: *mut UFormattable,
        len: *mut i32,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UDisplayContextType {
    UDISPCTX_TYPE_DIALECT_HANDLING = 0,
    UDISPCTX_TYPE_CAPITALIZATION = 1,
    UDISPCTX_TYPE_DISPLAY_LENGTH = 2,
    UDISPCTX_TYPE_SUBSTITUTE_HANDLING = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UDisplayContext {
    UDISPCTX_STANDARD_NAMES = 0,
    UDISPCTX_DIALECT_NAMES = 1,
    UDISPCTX_CAPITALIZATION_NONE = 256,
    UDISPCTX_CAPITALIZATION_FOR_MIDDLE_OF_SENTENCE = 257,
    UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE = 258,
    UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU = 259,
    UDISPCTX_CAPITALIZATION_FOR_STANDALONE = 260,
    UDISPCTX_LENGTH_FULL = 512,
    UDISPCTX_LENGTH_SHORT = 513,
    UDISPCTX_SUBSTITUTE = 768,
    UDISPCTX_NO_SUBSTITUTE = 769,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UFieldPositionIterator {
    _unused: [u8; 0],
}
extern "C" {
    pub fn ufieldpositer_open_73(status: *mut UErrorCode) -> *mut UFieldPositionIterator;
}
extern "C" {
    pub fn ufieldpositer_close_73(fpositer: *mut UFieldPositionIterator);
}
extern "C" {
    pub fn ufieldpositer_next_73(
        fpositer: *mut UFieldPositionIterator,
        beginIndex: *mut i32,
        endIndex: *mut i32,
    ) -> i32;
}
pub type UNumberFormat = *mut ::std::os::raw::c_void;
impl UNumberFormatStyle {
    pub const UNUM_DEFAULT: UNumberFormatStyle = UNumberFormatStyle::UNUM_DECIMAL;
}
impl UNumberFormatStyle {
    pub const UNUM_IGNORE: UNumberFormatStyle = UNumberFormatStyle::UNUM_PATTERN_DECIMAL;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UNumberFormatStyle {
    UNUM_PATTERN_DECIMAL = 0,
    UNUM_DECIMAL = 1,
    UNUM_CURRENCY = 2,
    UNUM_PERCENT = 3,
    UNUM_SCIENTIFIC = 4,
    UNUM_SPELLOUT = 5,
    UNUM_ORDINAL = 6,
    UNUM_DURATION = 7,
    UNUM_NUMBERING_SYSTEM = 8,
    UNUM_PATTERN_RULEBASED = 9,
    UNUM_CURRENCY_ISO = 10,
    UNUM_CURRENCY_PLURAL = 11,
    UNUM_CURRENCY_ACCOUNTING = 12,
    UNUM_CASH_CURRENCY = 13,
    UNUM_DECIMAL_COMPACT_SHORT = 14,
    UNUM_DECIMAL_COMPACT_LONG = 15,
    UNUM_CURRENCY_STANDARD = 16,
    UNUM_FORMAT_STYLE_COUNT = 17,
}
extern "C" {
    pub fn unum_open_73(
        style: UNumberFormatStyle,
        pattern: *const UChar,
        patternLength: i32,
        locale: *const ::std::os::raw::c_char,
        parseErr: *mut UParseError,
        status: *mut UErrorCode,
    ) -> *mut UNumberFormat;
}
extern "C" {
    pub fn unum_close_73(fmt: *mut UNumberFormat);
}
extern "C" {
    pub fn unum_clone_73(fmt: *const UNumberFormat, status: *mut UErrorCode) -> *mut UNumberFormat;
}
extern "C" {
    pub fn unum_format_73(
        fmt: *const UNumberFormat,
        number: i32,
        result: *mut UChar,
        resultLength: i32,
        pos: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_formatInt64_73(
        fmt: *const UNumberFormat,
        number: i64,
        result: *mut UChar,
        resultLength: i32,
        pos: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_formatDouble_73(
        fmt: *const UNumberFormat,
        number: f64,
        result: *mut UChar,
        resultLength: i32,
        pos: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_formatDoubleForFields_73(
        format: *const UNumberFormat,
        number: f64,
        result: *mut UChar,
        resultLength: i32,
        fpositer: *mut UFieldPositionIterator,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_formatDecimal_73(
        fmt: *const UNumberFormat,
        number: *const ::std::os::raw::c_char,
        length: i32,
        result: *mut UChar,
        resultLength: i32,
        pos: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_formatDoubleCurrency_73(
        fmt: *const UNumberFormat,
        number: f64,
        currency: *mut UChar,
        result: *mut UChar,
        resultLength: i32,
        pos: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_formatUFormattable_73(
        fmt: *const UNumberFormat,
        number: *const UFormattable,
        result: *mut UChar,
        resultLength: i32,
        pos: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_parse_73(
        fmt: *const UNumberFormat,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_parseInt64_73(
        fmt: *const UNumberFormat,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        status: *mut UErrorCode,
    ) -> i64;
}
extern "C" {
    pub fn unum_parseDouble_73(
        fmt: *const UNumberFormat,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        status: *mut UErrorCode,
    ) -> f64;
}
extern "C" {
    pub fn unum_parseDecimal_73(
        fmt: *const UNumberFormat,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        outBuf: *mut ::std::os::raw::c_char,
        outBufLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_parseDoubleCurrency_73(
        fmt: *const UNumberFormat,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        currency: *mut UChar,
        status: *mut UErrorCode,
    ) -> f64;
}
extern "C" {
    pub fn unum_parseToUFormattable_73(
        fmt: *const UNumberFormat,
        result: *mut UFormattable,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        status: *mut UErrorCode,
    ) -> *mut UFormattable;
}
extern "C" {
    pub fn unum_applyPattern_73(
        format: *mut UNumberFormat,
        localized: UBool,
        pattern: *const UChar,
        patternLength: i32,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn unum_getAvailable_73(localeIndex: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn unum_countAvailable_73() -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UNumberFormatAttribute {
    UNUM_PARSE_INT_ONLY = 0,
    UNUM_GROUPING_USED = 1,
    UNUM_DECIMAL_ALWAYS_SHOWN = 2,
    UNUM_MAX_INTEGER_DIGITS = 3,
    UNUM_MIN_INTEGER_DIGITS = 4,
    UNUM_INTEGER_DIGITS = 5,
    UNUM_MAX_FRACTION_DIGITS = 6,
    UNUM_MIN_FRACTION_DIGITS = 7,
    UNUM_FRACTION_DIGITS = 8,
    UNUM_MULTIPLIER = 9,
    UNUM_GROUPING_SIZE = 10,
    UNUM_ROUNDING_MODE = 11,
    UNUM_ROUNDING_INCREMENT = 12,
    UNUM_FORMAT_WIDTH = 13,
    UNUM_PADDING_POSITION = 14,
    UNUM_SECONDARY_GROUPING_SIZE = 15,
    UNUM_SIGNIFICANT_DIGITS_USED = 16,
    UNUM_MIN_SIGNIFICANT_DIGITS = 17,
    UNUM_MAX_SIGNIFICANT_DIGITS = 18,
    UNUM_LENIENT_PARSE = 19,
    UNUM_PARSE_ALL_INPUT = 20,
    UNUM_SCALE = 21,
    UNUM_MINIMUM_GROUPING_DIGITS = 22,
    UNUM_CURRENCY_USAGE = 23,
    UNUM_MAX_NONBOOLEAN_ATTRIBUTE = 4095,
    UNUM_FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS = 4096,
    UNUM_PARSE_NO_EXPONENT = 4097,
    UNUM_PARSE_DECIMAL_MARK_REQUIRED = 4098,
    UNUM_PARSE_CASE_SENSITIVE = 4099,
    UNUM_SIGN_ALWAYS_SHOWN = 4100,
    UNUM_LIMIT_BOOLEAN_ATTRIBUTE = 4101,
}
extern "C" {
    pub fn unum_hasAttribute_73(fmt: *const UNumberFormat, attr: UNumberFormatAttribute) -> bool;
}
extern "C" {
    pub fn unum_getAttribute_73(fmt: *const UNumberFormat, attr: UNumberFormatAttribute) -> i32;
}
extern "C" {
    pub fn unum_setAttribute_73(
        fmt: *mut UNumberFormat,
        attr: UNumberFormatAttribute,
        newValue: i32,
    );
}
extern "C" {
    pub fn unum_getDoubleAttribute_73(
        fmt: *const UNumberFormat,
        attr: UNumberFormatAttribute,
    ) -> f64;
}
extern "C" {
    pub fn unum_setDoubleAttribute_73(
        fmt: *mut UNumberFormat,
        attr: UNumberFormatAttribute,
        newValue: f64,
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UNumberFormatTextAttribute {
    UNUM_POSITIVE_PREFIX = 0,
    UNUM_POSITIVE_SUFFIX = 1,
    UNUM_NEGATIVE_PREFIX = 2,
    UNUM_NEGATIVE_SUFFIX = 3,
    UNUM_PADDING_CHARACTER = 4,
    UNUM_CURRENCY_CODE = 5,
    UNUM_DEFAULT_RULESET = 6,
    UNUM_PUBLIC_RULESETS = 7,
}
extern "C" {
    pub fn unum_getTextAttribute_73(
        fmt: *const UNumberFormat,
        tag: UNumberFormatTextAttribute,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_setTextAttribute_73(
        fmt: *mut UNumberFormat,
        tag: UNumberFormatTextAttribute,
        newValue: *const UChar,
        newValueLength: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn unum_toPattern_73(
        fmt: *const UNumberFormat,
        isPatternLocalized: UBool,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UNumberFormatSymbol {
    UNUM_DECIMAL_SEPARATOR_SYMBOL = 0,
    UNUM_GROUPING_SEPARATOR_SYMBOL = 1,
    UNUM_PATTERN_SEPARATOR_SYMBOL = 2,
    UNUM_PERCENT_SYMBOL = 3,
    UNUM_ZERO_DIGIT_SYMBOL = 4,
    UNUM_DIGIT_SYMBOL = 5,
    UNUM_MINUS_SIGN_SYMBOL = 6,
    UNUM_PLUS_SIGN_SYMBOL = 7,
    UNUM_CURRENCY_SYMBOL = 8,
    UNUM_INTL_CURRENCY_SYMBOL = 9,
    UNUM_MONETARY_SEPARATOR_SYMBOL = 10,
    UNUM_EXPONENTIAL_SYMBOL = 11,
    UNUM_PERMILL_SYMBOL = 12,
    UNUM_PAD_ESCAPE_SYMBOL = 13,
    UNUM_INFINITY_SYMBOL = 14,
    UNUM_NAN_SYMBOL = 15,
    UNUM_SIGNIFICANT_DIGIT_SYMBOL = 16,
    UNUM_MONETARY_GROUPING_SEPARATOR_SYMBOL = 17,
    UNUM_ONE_DIGIT_SYMBOL = 18,
    UNUM_TWO_DIGIT_SYMBOL = 19,
    UNUM_THREE_DIGIT_SYMBOL = 20,
    UNUM_FOUR_DIGIT_SYMBOL = 21,
    UNUM_FIVE_DIGIT_SYMBOL = 22,
    UNUM_SIX_DIGIT_SYMBOL = 23,
    UNUM_SEVEN_DIGIT_SYMBOL = 24,
    UNUM_EIGHT_DIGIT_SYMBOL = 25,
    UNUM_NINE_DIGIT_SYMBOL = 26,
    UNUM_EXPONENT_MULTIPLICATION_SYMBOL = 27,
    UNUM_APPROXIMATELY_SIGN_SYMBOL = 28,
    UNUM_FORMAT_SYMBOL_COUNT = 29,
}
extern "C" {
    pub fn unum_getSymbol_73(
        fmt: *const UNumberFormat,
        symbol: UNumberFormatSymbol,
        buffer: *mut UChar,
        size: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unum_setSymbol_73(
        fmt: *mut UNumberFormat,
        symbol: UNumberFormatSymbol,
        value: *const UChar,
        length: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn unum_getLocaleByType_73(
        fmt: *const UNumberFormat,
        type_: ULocDataLocaleType,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn unum_setContext_73(
        fmt: *mut UNumberFormat,
        value: UDisplayContext,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn unum_getContext_73(
        fmt: *const UNumberFormat,
        type_: UDisplayContextType,
        status: *mut UErrorCode,
    ) -> UDisplayContext;
}
pub type UDateFormat = *mut ::std::os::raw::c_void;
impl UDateFormatStyle {
    pub const UDAT_DEFAULT: UDateFormatStyle = UDateFormatStyle::UDAT_MEDIUM;
}
impl UDateFormatStyle {
    pub const UDAT_FULL_RELATIVE: UDateFormatStyle = UDateFormatStyle::UDAT_RELATIVE;
}
impl UDateFormatStyle {
    pub const UDAT_IGNORE: UDateFormatStyle = UDateFormatStyle::UDAT_PATTERN;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UDateFormatStyle {
    UDAT_FULL = 0,
    UDAT_LONG = 1,
    UDAT_MEDIUM = 2,
    UDAT_SHORT = 3,
    UDAT_RELATIVE = 128,
    UDAT_LONG_RELATIVE = 129,
    UDAT_MEDIUM_RELATIVE = 130,
    UDAT_SHORT_RELATIVE = 131,
    UDAT_NONE = - 1,
    UDAT_PATTERN = - 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UDateFormatField {
    UDAT_ERA_FIELD = 0,
    UDAT_YEAR_FIELD = 1,
    UDAT_MONTH_FIELD = 2,
    UDAT_DATE_FIELD = 3,
    UDAT_HOUR_OF_DAY1_FIELD = 4,
    UDAT_HOUR_OF_DAY0_FIELD = 5,
    UDAT_MINUTE_FIELD = 6,
    UDAT_SECOND_FIELD = 7,
    UDAT_FRACTIONAL_SECOND_FIELD = 8,
    UDAT_DAY_OF_WEEK_FIELD = 9,
    UDAT_DAY_OF_YEAR_FIELD = 10,
    UDAT_DAY_OF_WEEK_IN_MONTH_FIELD = 11,
    UDAT_WEEK_OF_YEAR_FIELD = 12,
    UDAT_WEEK_OF_MONTH_FIELD = 13,
    UDAT_AM_PM_FIELD = 14,
    UDAT_HOUR1_FIELD = 15,
    UDAT_HOUR0_FIELD = 16,
    UDAT_TIMEZONE_FIELD = 17,
    UDAT_YEAR_WOY_FIELD = 18,
    UDAT_DOW_LOCAL_FIELD = 19,
    UDAT_EXTENDED_YEAR_FIELD = 20,
    UDAT_JULIAN_DAY_FIELD = 21,
    UDAT_MILLISECONDS_IN_DAY_FIELD = 22,
    UDAT_TIMEZONE_RFC_FIELD = 23,
    UDAT_TIMEZONE_GENERIC_FIELD = 24,
    UDAT_STANDALONE_DAY_FIELD = 25,
    UDAT_STANDALONE_MONTH_FIELD = 26,
    UDAT_QUARTER_FIELD = 27,
    UDAT_STANDALONE_QUARTER_FIELD = 28,
    UDAT_TIMEZONE_SPECIAL_FIELD = 29,
    UDAT_YEAR_NAME_FIELD = 30,
    UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD = 31,
    UDAT_TIMEZONE_ISO_FIELD = 32,
    UDAT_TIMEZONE_ISO_LOCAL_FIELD = 33,
    UDAT_RELATED_YEAR_FIELD = 34,
    UDAT_AM_PM_MIDNIGHT_NOON_FIELD = 35,
    UDAT_FLEXIBLE_DAY_PERIOD_FIELD = 36,
    UDAT_TIME_SEPARATOR_FIELD = 37,
    UDAT_FIELD_COUNT = 38,
}
extern "C" {
    pub fn udat_toCalendarDateField_73(field: UDateFormatField) -> UCalendarDateFields;
}
extern "C" {
    pub fn udat_open_73(
        timeStyle: UDateFormatStyle,
        dateStyle: UDateFormatStyle,
        locale: *const ::std::os::raw::c_char,
        tzID: *const UChar,
        tzIDLength: i32,
        pattern: *const UChar,
        patternLength: i32,
        status: *mut UErrorCode,
    ) -> *mut UDateFormat;
}
extern "C" {
    pub fn udat_close_73(format: *mut UDateFormat);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UDateFormatBooleanAttribute {
    UDAT_PARSE_ALLOW_WHITESPACE = 0,
    UDAT_PARSE_ALLOW_NUMERIC = 1,
    UDAT_PARSE_PARTIAL_LITERAL_MATCH = 2,
    UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH = 3,
    UDAT_BOOLEAN_ATTRIBUTE_COUNT = 4,
}
extern "C" {
    pub fn udat_getBooleanAttribute_73(
        fmt: *const UDateFormat,
        attr: UDateFormatBooleanAttribute,
        status: *mut UErrorCode,
    ) -> UBool;
}
extern "C" {
    pub fn udat_setBooleanAttribute_73(
        fmt: *mut UDateFormat,
        attr: UDateFormatBooleanAttribute,
        newValue: UBool,
        status: *mut UErrorCode,
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UDateFormatHourCycle {
    UDAT_HOUR_CYCLE_11 = 0,
    UDAT_HOUR_CYCLE_12 = 1,
    UDAT_HOUR_CYCLE_23 = 2,
    UDAT_HOUR_CYCLE_24 = 3,
}
extern "C" {
    pub fn udat_clone_73(fmt: *const UDateFormat, status: *mut UErrorCode) -> *mut UDateFormat;
}
extern "C" {
    pub fn udat_format_73(
        format: *const UDateFormat,
        dateToFormat: UDate,
        result: *mut UChar,
        resultLength: i32,
        position: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_formatCalendar_73(
        format: *const UDateFormat,
        calendar: *mut UCalendar,
        result: *mut UChar,
        capacity: i32,
        position: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_formatForFields_73(
        format: *const UDateFormat,
        dateToFormat: UDate,
        result: *mut UChar,
        resultLength: i32,
        fpositer: *mut UFieldPositionIterator,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_formatCalendarForFields_73(
        format: *const UDateFormat,
        calendar: *mut UCalendar,
        result: *mut UChar,
        capacity: i32,
        fpositer: *mut UFieldPositionIterator,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_parse_73(
        format: *const UDateFormat,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        status: *mut UErrorCode,
    ) -> UDate;
}
extern "C" {
    pub fn udat_parseCalendar_73(
        format: *const UDateFormat,
        calendar: *mut UCalendar,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_isLenient_73(fmt: *const UDateFormat) -> UBool;
}
extern "C" {
    pub fn udat_setLenient_73(fmt: *mut UDateFormat, isLenient: UBool);
}
extern "C" {
    pub fn udat_getCalendar_73(fmt: *const UDateFormat) -> *const UCalendar;
}
extern "C" {
    pub fn udat_setCalendar_73(fmt: *mut UDateFormat, calendarToSet: *const UCalendar);
}
extern "C" {
    pub fn udat_getNumberFormat_73(fmt: *const UDateFormat) -> *const UNumberFormat;
}
extern "C" {
    pub fn udat_getNumberFormatForField_73(
        fmt: *const UDateFormat,
        field: UChar,
    ) -> *const UNumberFormat;
}
extern "C" {
    pub fn udat_adoptNumberFormatForFields_73(
        fmt: *mut UDateFormat,
        fields: *const UChar,
        numberFormatToSet: *mut UNumberFormat,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_setNumberFormat_73(fmt: *mut UDateFormat, numberFormatToSet: *const UNumberFormat);
}
extern "C" {
    pub fn udat_adoptNumberFormat_73(
        fmt: *mut UDateFormat,
        numberFormatToAdopt: *mut UNumberFormat,
    );
}
extern "C" {
    pub fn udat_getAvailable_73(localeIndex: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udat_countAvailable_73() -> i32;
}
extern "C" {
    pub fn udat_get2DigitYearStart_73(fmt: *const UDateFormat, status: *mut UErrorCode) -> UDate;
}
extern "C" {
    pub fn udat_set2DigitYearStart_73(fmt: *mut UDateFormat, d: UDate, status: *mut UErrorCode);
}
extern "C" {
    pub fn udat_toPattern_73(
        fmt: *const UDateFormat,
        localized: UBool,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_applyPattern_73(
        format: *mut UDateFormat,
        localized: UBool,
        pattern: *const UChar,
        patternLength: i32,
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UDateFormatSymbolType {
    UDAT_ERAS = 0,
    UDAT_MONTHS = 1,
    UDAT_SHORT_MONTHS = 2,
    UDAT_WEEKDAYS = 3,
    UDAT_SHORT_WEEKDAYS = 4,
    UDAT_AM_PMS = 5,
    UDAT_LOCALIZED_CHARS = 6,
    UDAT_ERA_NAMES = 7,
    UDAT_NARROW_MONTHS = 8,
    UDAT_NARROW_WEEKDAYS = 9,
    UDAT_STANDALONE_MONTHS = 10,
    UDAT_STANDALONE_SHORT_MONTHS = 11,
    UDAT_STANDALONE_NARROW_MONTHS = 12,
    UDAT_STANDALONE_WEEKDAYS = 13,
    UDAT_STANDALONE_SHORT_WEEKDAYS = 14,
    UDAT_STANDALONE_NARROW_WEEKDAYS = 15,
    UDAT_QUARTERS = 16,
    UDAT_SHORT_QUARTERS = 17,
    UDAT_STANDALONE_QUARTERS = 18,
    UDAT_STANDALONE_SHORT_QUARTERS = 19,
    UDAT_SHORTER_WEEKDAYS = 20,
    UDAT_STANDALONE_SHORTER_WEEKDAYS = 21,
    UDAT_CYCLIC_YEARS_WIDE = 22,
    UDAT_CYCLIC_YEARS_ABBREVIATED = 23,
    UDAT_CYCLIC_YEARS_NARROW = 24,
    UDAT_ZODIAC_NAMES_WIDE = 25,
    UDAT_ZODIAC_NAMES_ABBREVIATED = 26,
    UDAT_ZODIAC_NAMES_NARROW = 27,
    UDAT_NARROW_QUARTERS = 28,
    UDAT_STANDALONE_NARROW_QUARTERS = 29,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UDateFormatSymbols {
    _unused: [u8; 0],
}
extern "C" {
    pub fn udat_getSymbols_73(
        fmt: *const UDateFormat,
        type_: UDateFormatSymbolType,
        symbolIndex: i32,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_countSymbols_73(fmt: *const UDateFormat, type_: UDateFormatSymbolType) -> i32;
}
extern "C" {
    pub fn udat_setSymbols_73(
        format: *mut UDateFormat,
        type_: UDateFormatSymbolType,
        symbolIndex: i32,
        value: *mut UChar,
        valueLength: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_getLocaleByType_73(
        fmt: *const UDateFormat,
        type_: ULocDataLocaleType,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udat_setContext_73(
        fmt: *mut UDateFormat,
        value: UDisplayContext,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_getContext_73(
        fmt: *const UDateFormat,
        type_: UDisplayContextType,
        status: *mut UErrorCode,
    ) -> UDisplayContext;
}
extern "C" {
    pub fn udat_toPatternRelativeDate_73(
        fmt: *const UDateFormat,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_toPatternRelativeTime_73(
        fmt: *const UDateFormat,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_applyPatternRelative_73(
        format: *mut UDateFormat,
        datePattern: *const UChar,
        datePatternLength: i32,
        timePattern: *const UChar,
        timePatternLength: i32,
        status: *mut UErrorCode,
    );
}
pub type UDateFormatOpener =
    ::std::option::Option<
        unsafe extern "C" fn(timeStyle: UDateFormatStyle,
                             dateStyle: UDateFormatStyle,
                             locale: *const ::std::os::raw::c_char,
                             tzID: *const UChar,
                             tzIDLength: i32,
                             pattern: *const UChar,
                             patternLength: i32,
                             status: *mut UErrorCode)
                             -> *mut UDateFormat,
    >;
extern "C" {
    pub fn udat_registerOpener_73(opener: UDateFormatOpener, status: *mut UErrorCode);
}
extern "C" {
    pub fn udat_unregisterOpener_73(
        opener: UDateFormatOpener,
        status: *mut UErrorCode,
    ) -> UDateFormatOpener;
}
pub type UDateTimePatternGenerator = *mut ::std::os::raw::c_void;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UDateTimePatternField {
    UDATPG_ERA_FIELD = 0,
    UDATPG_YEAR_FIELD = 1,
    UDATPG_QUARTER_FIELD = 2,
    UDATPG_MONTH_FIELD = 3,
    UDATPG_WEEK_OF_YEAR_FIELD = 4,
    UDATPG_WEEK_OF_MONTH_FIELD = 5,
    UDATPG_WEEKDAY_FIELD = 6,
    UDATPG_DAY_OF_YEAR_FIELD = 7,
    UDATPG_DAY_OF_WEEK_IN_MONTH_FIELD = 8,
    UDATPG_DAY_FIELD = 9,
    UDATPG_DAYPERIOD_FIELD = 10,
    UDATPG_HOUR_FIELD = 11,
    UDATPG_MINUTE_FIELD = 12,
    UDATPG_SECOND_FIELD = 13,
    UDATPG_FRACTIONAL_SECOND_FIELD = 14,
    UDATPG_ZONE_FIELD = 15,
    UDATPG_FIELD_COUNT = 16,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UDateTimePGDisplayWidth {
    UDATPG_WIDE = 0,
    UDATPG_ABBREVIATED = 1,
    UDATPG_NARROW = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UDateTimePatternMatchOptions {
    UDATPG_MATCH_NO_OPTIONS = 0,
    UDATPG_MATCH_HOUR_FIELD_LENGTH = 2048,
    UDATPG_MATCH_MINUTE_FIELD_LENGTH = 4096,
    UDATPG_MATCH_SECOND_FIELD_LENGTH = 8192,
    UDATPG_MATCH_ALL_FIELDS_LENGTH = 65535,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UDateTimePatternConflict {
    UDATPG_NO_CONFLICT = 0,
    UDATPG_BASE_CONFLICT = 1,
    UDATPG_CONFLICT = 2,
    UDATPG_CONFLICT_COUNT = 3,
}
extern "C" {
    pub fn udatpg_open_73(
        locale: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UDateTimePatternGenerator;
}
extern "C" {
    pub fn udatpg_openEmpty_73(pErrorCode: *mut UErrorCode) -> *mut UDateTimePatternGenerator;
}
extern "C" {
    pub fn udatpg_close_73(dtpg: *mut UDateTimePatternGenerator);
}
extern "C" {
    pub fn udatpg_clone_73(
        dtpg: *const UDateTimePatternGenerator,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UDateTimePatternGenerator;
}
extern "C" {
    pub fn udatpg_getBestPattern_73(
        dtpg: *mut UDateTimePatternGenerator,
        skeleton: *const UChar,
        length: i32,
        bestPattern: *mut UChar,
        capacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udatpg_getBestPatternWithOptions_73(
        dtpg: *mut UDateTimePatternGenerator,
        skeleton: *const UChar,
        length: i32,
        options: UDateTimePatternMatchOptions,
        bestPattern: *mut UChar,
        capacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udatpg_getSkeleton_73(
        unusedDtpg: *mut UDateTimePatternGenerator,
        pattern: *const UChar,
        length: i32,
        skeleton: *mut UChar,
        capacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udatpg_getBaseSkeleton_73(
        unusedDtpg: *mut UDateTimePatternGenerator,
        pattern: *const UChar,
        length: i32,
        baseSkeleton: *mut UChar,
        capacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udatpg_addPattern_73(
        dtpg: *mut UDateTimePatternGenerator,
        pattern: *const UChar,
        patternLength: i32,
        override_: UBool,
        conflictingPattern: *mut UChar,
        capacity: i32,
        pLength: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> UDateTimePatternConflict;
}
extern "C" {
    pub fn udatpg_setAppendItemFormat_73(
        dtpg: *mut UDateTimePatternGenerator,
        field: UDateTimePatternField,
        value: *const UChar,
        length: i32,
    );
}
extern "C" {
    pub fn udatpg_getAppendItemFormat_73(
        dtpg: *const UDateTimePatternGenerator,
        field: UDateTimePatternField,
        pLength: *mut i32,
    ) -> *const UChar;
}
extern "C" {
    pub fn udatpg_setAppendItemName_73(
        dtpg: *mut UDateTimePatternGenerator,
        field: UDateTimePatternField,
        value: *const UChar,
        length: i32,
    );
}
extern "C" {
    pub fn udatpg_getAppendItemName_73(
        dtpg: *const UDateTimePatternGenerator,
        field: UDateTimePatternField,
        pLength: *mut i32,
    ) -> *const UChar;
}
extern "C" {
    pub fn udatpg_getFieldDisplayName_73(
        dtpg: *const UDateTimePatternGenerator,
        field: UDateTimePatternField,
        width: UDateTimePGDisplayWidth,
        fieldName: *mut UChar,
        capacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udatpg_setDateTimeFormat_73(
        dtpg: *const UDateTimePatternGenerator,
        dtFormat: *const UChar,
        length: i32,
    );
}
extern "C" {
    pub fn udatpg_getDateTimeFormat_73(
        dtpg: *const UDateTimePatternGenerator,
        pLength: *mut i32,
    ) -> *const UChar;
}
extern "C" {
    pub fn udatpg_setDateTimeFormatForStyle_73(
        udtpg: *mut UDateTimePatternGenerator,
        style: UDateFormatStyle,
        dateTimeFormat: *const UChar,
        length: i32,
        pErrorCode: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udatpg_getDateTimeFormatForStyle_73(
        udtpg: *const UDateTimePatternGenerator,
        style: UDateFormatStyle,
        pLength: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *const UChar;
}
extern "C" {
    pub fn udatpg_setDecimal_73(
        dtpg: *mut UDateTimePatternGenerator,
        decimal: *const UChar,
        length: i32,
    );
}
extern "C" {
    pub fn udatpg_getDecimal_73(
        dtpg: *const UDateTimePatternGenerator,
        pLength: *mut i32,
    ) -> *const UChar;
}
extern "C" {
    pub fn udatpg_replaceFieldTypes_73(
        dtpg: *mut UDateTimePatternGenerator,
        pattern: *const UChar,
        patternLength: i32,
        skeleton: *const UChar,
        skeletonLength: i32,
        dest: *mut UChar,
        destCapacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udatpg_replaceFieldTypesWithOptions_73(
        dtpg: *mut UDateTimePatternGenerator,
        pattern: *const UChar,
        patternLength: i32,
        skeleton: *const UChar,
        skeletonLength: i32,
        options: UDateTimePatternMatchOptions,
        dest: *mut UChar,
        destCapacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udatpg_openSkeletons_73(
        dtpg: *const UDateTimePatternGenerator,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn udatpg_openBaseSkeletons_73(
        dtpg: *const UDateTimePatternGenerator,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn udatpg_getPatternForSkeleton_73(
        dtpg: *const UDateTimePatternGenerator,
        skeleton: *const UChar,
        skeletonLength: i32,
        pLength: *mut i32,
    ) -> *const UChar;
}
extern "C" {
    pub fn udatpg_getDefaultHourCycle_73(
        dtpg: *const UDateTimePatternGenerator,
        pErrorCode: *mut UErrorCode,
    ) -> UDateFormatHourCycle;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UDataInfo {
    pub size: u16,
    pub reservedWord: u16,
    pub isBigEndian: u8,
    pub charsetFamily: u8,
    pub sizeofUChar: u8,
    pub reservedByte: u8,
    pub dataFormat: [u8; 4usize],
    pub formatVersion: [u8; 4usize],
    pub dataVersion: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_UDataInfo() {
    assert_eq!(
        ::std::mem::size_of::<UDataInfo>(),
        20usize,
        concat!("Size of: ", stringify!(UDataInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<UDataInfo>(),
        2usize,
        concat!("Alignment of ", stringify!(UDataInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).reservedWord as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(reservedWord)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).isBigEndian as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(isBigEndian)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).charsetFamily as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(charsetFamily)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).sizeofUChar as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(sizeofUChar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).reservedByte as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(reservedByte)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).dataFormat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(dataFormat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).formatVersion as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(formatVersion)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).dataVersion as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UDataInfo),
            "::",
            stringify!(dataVersion)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UDataMemory {
    _unused: [u8; 0],
}
pub type UDataMemoryIsAcceptable =
    ::std::option::Option<
        unsafe extern "C" fn(context: *mut ::std::os::raw::c_void,
                             type_: *const ::std::os::raw::c_char,
                             name: *const ::std::os::raw::c_char,
                             pInfo: *const UDataInfo)
                             -> UBool,
    >;
extern "C" {
    pub fn udata_open_73(
        path: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UDataMemory;
}
extern "C" {
    pub fn udata_openChoice_73(
        path: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        isAcceptable: UDataMemoryIsAcceptable,
        context: *mut ::std::os::raw::c_void,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UDataMemory;
}
extern "C" {
    pub fn udata_close_73(pData: *mut UDataMemory);
}
extern "C" {
    pub fn udata_getMemory_73(pData: *mut UDataMemory) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn udata_getInfo_73(pData: *mut UDataMemory, pInfo: *mut UDataInfo);
}
extern "C" {
    pub fn udata_setCommonData_73(data: *const ::std::os::raw::c_void, err: *mut UErrorCode);
}
extern "C" {
    pub fn udata_setAppData_73(
        packageName: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        err: *mut UErrorCode,
    );
}
impl UDataFileAccess {
    pub const UDATA_DEFAULT_ACCESS: UDataFileAccess = UDataFileAccess::UDATA_FILES_FIRST;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UDataFileAccess {
    UDATA_FILES_FIRST = 0,
    UDATA_ONLY_PACKAGES = 1,
    UDATA_PACKAGES_FIRST = 2,
    UDATA_NO_FILES = 3,
    UDATA_FILE_ACCESS_COUNT = 4,
}
extern "C" {
    pub fn udata_setFileAccess_73(access: UDataFileAccess, status: *mut UErrorCode);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UFieldCategory {
    UFIELD_CATEGORY_UNDEFINED = 0,
    UFIELD_CATEGORY_DATE = 1,
    UFIELD_CATEGORY_NUMBER = 2,
    UFIELD_CATEGORY_LIST = 3,
    UFIELD_CATEGORY_RELATIVE_DATETIME = 4,
    UFIELD_CATEGORY_DATE_INTERVAL = 5,
    UFIELD_CATEGORY_COUNT = 6,
    UFIELD_CATEGORY_LIST_SPAN = 4099,
    UFIELD_CATEGORY_DATE_INTERVAL_SPAN = 4101,
    UFIELD_CATEGORY_NUMBER_RANGE_SPAN = 4098,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UFormattedValue {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UListFormatter {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UFormattedList {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UListFormatterField {
    ULISTFMT_LITERAL_FIELD = 0,
    ULISTFMT_ELEMENT_FIELD = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UListFormatterType {
    ULISTFMT_TYPE_AND = 0,
    ULISTFMT_TYPE_OR = 1,
    ULISTFMT_TYPE_UNITS = 2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UListFormatterWidth {
    ULISTFMT_WIDTH_WIDE = 0,
    ULISTFMT_WIDTH_SHORT = 1,
    ULISTFMT_WIDTH_NARROW = 2,
}
extern "C" {
    pub fn ulistfmt_open_73(
        locale: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> *mut UListFormatter;
}
extern "C" {
    pub fn ulistfmt_openForType_73(
        locale: *const ::std::os::raw::c_char,
        type_: UListFormatterType,
        width: UListFormatterWidth,
        status: *mut UErrorCode,
    ) -> *mut UListFormatter;
}
extern "C" {
    pub fn ulistfmt_close_73(listfmt: *mut UListFormatter);
}
extern "C" {
    pub fn ulistfmt_openResult_73(ec: *mut UErrorCode) -> *mut UFormattedList;
}
extern "C" {
    pub fn ulistfmt_resultAsValue_73(
        uresult: *const UFormattedList,
        ec: *mut UErrorCode,
    ) -> *const UFormattedValue;
}
extern "C" {
    pub fn ulistfmt_closeResult_73(uresult: *mut UFormattedList);
}
extern "C" {
    pub fn ulistfmt_format_73(
        listfmt: *const UListFormatter,
        strings: *const *const UChar,
        stringLengths: *const i32,
        stringCount: i32,
        result: *mut UChar,
        resultCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ulistfmt_formatStringsToResult_73(
        listfmt: *const UListFormatter,
        strings: *const *const UChar,
        stringLengths: *const i32,
        stringCount: i32,
        uresult: *mut UFormattedList,
        status: *mut UErrorCode,
    );
}
pub type va_list = __builtin_va_list;
extern "C" {
    pub fn u_formatMessage_73(
        locale: *const ::std::os::raw::c_char,
        pattern: *const UChar,
        patternLength: i32,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
        ...
    ) -> i32;
}
extern "C" {
    pub fn u_vformatMessage_73(
        locale: *const ::std::os::raw::c_char,
        pattern: *const UChar,
        patternLength: i32,
        result: *mut UChar,
        resultLength: i32,
        ap: *mut __va_list_tag,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_parseMessage_73(
        locale: *const ::std::os::raw::c_char,
        pattern: *const UChar,
        patternLength: i32,
        source: *const UChar,
        sourceLength: i32,
        status: *mut UErrorCode,
        ...
    );
}
extern "C" {
    pub fn u_vparseMessage_73(
        locale: *const ::std::os::raw::c_char,
        pattern: *const UChar,
        patternLength: i32,
        source: *const UChar,
        sourceLength: i32,
        ap: *mut __va_list_tag,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn u_formatMessageWithError_73(
        locale: *const ::std::os::raw::c_char,
        pattern: *const UChar,
        patternLength: i32,
        result: *mut UChar,
        resultLength: i32,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
        ...
    ) -> i32;
}
extern "C" {
    pub fn u_vformatMessageWithError_73(
        locale: *const ::std::os::raw::c_char,
        pattern: *const UChar,
        patternLength: i32,
        result: *mut UChar,
        resultLength: i32,
        parseError: *mut UParseError,
        ap: *mut __va_list_tag,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_parseMessageWithError_73(
        locale: *const ::std::os::raw::c_char,
        pattern: *const UChar,
        patternLength: i32,
        source: *const UChar,
        sourceLength: i32,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
        ...
    );
}
extern "C" {
    pub fn u_vparseMessageWithError_73(
        locale: *const ::std::os::raw::c_char,
        pattern: *const UChar,
        patternLength: i32,
        source: *const UChar,
        sourceLength: i32,
        ap: *mut __va_list_tag,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
    );
}
pub type UMessageFormat = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn umsg_open_73(
        pattern: *const UChar,
        patternLength: i32,
        locale: *const ::std::os::raw::c_char,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
    ) -> *mut UMessageFormat;
}
extern "C" {
    pub fn umsg_close_73(format: *mut UMessageFormat);
}
extern "C" {
    pub fn umsg_clone_73(fmt: *const UMessageFormat, status: *mut UErrorCode) -> UMessageFormat;
}
extern "C" {
    pub fn umsg_setLocale_73(fmt: *mut UMessageFormat, locale: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn umsg_getLocale_73(fmt: *const UMessageFormat) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn umsg_applyPattern_73(
        fmt: *mut UMessageFormat,
        pattern: *const UChar,
        patternLength: i32,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn umsg_toPattern_73(
        fmt: *const UMessageFormat,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn umsg_format_73(
        fmt: *const UMessageFormat,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
        ...
    ) -> i32;
}
extern "C" {
    pub fn umsg_vformat_73(
        fmt: *const UMessageFormat,
        result: *mut UChar,
        resultLength: i32,
        ap: *mut __va_list_tag,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn umsg_parse_73(
        fmt: *const UMessageFormat,
        source: *const UChar,
        sourceLength: i32,
        count: *mut i32,
        status: *mut UErrorCode,
        ...
    );
}
extern "C" {
    pub fn umsg_vparse_73(
        fmt: *const UMessageFormat,
        source: *const UChar,
        sourceLength: i32,
        count: *mut i32,
        ap: *mut __va_list_tag,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn umsg_autoQuoteApostrophe_73(
        pattern: *const UChar,
        patternLength: i32,
        dest: *mut UChar,
        destCapacity: i32,
        ec: *mut UErrorCode,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UFormattedNumber {
    _unused: [u8; 0],
}
extern "C" {
    pub fn unumf_openResult_73(ec: *mut UErrorCode) -> *mut UFormattedNumber;
}
extern "C" {
    pub fn unumf_resultAsValue_73(
        uresult: *const UFormattedNumber,
        ec: *mut UErrorCode,
    ) -> *const UFormattedValue;
}
extern "C" {
    pub fn unumf_resultToString_73(
        uresult: *const UFormattedNumber,
        buffer: *mut UChar,
        bufferCapacity: i32,
        ec: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unumf_resultNextFieldPosition_73(
        uresult: *const UFormattedNumber,
        ufpos: *mut UFieldPosition,
        ec: *mut UErrorCode,
    ) -> UBool;
}
extern "C" {
    pub fn unumf_resultGetAllFieldPositions_73(
        uresult: *const UFormattedNumber,
        ufpositer: *mut UFieldPositionIterator,
        ec: *mut UErrorCode,
    );
}
extern "C" {
    pub fn unumf_resultToDecimalNumber_73(
        uresult: *const UFormattedNumber,
        dest: *mut ::std::os::raw::c_char,
        destCapacity: i32,
        ec: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn unumf_closeResult_73(uresult: *mut UFormattedNumber);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UNumberFormatter {
    _unused: [u8; 0],
}
extern "C" {
    pub fn unumf_openForSkeletonAndLocale_73(
        skeleton: *const UChar,
        skeletonLen: i32,
        locale: *const ::std::os::raw::c_char,
        ec: *mut UErrorCode,
    ) -> *mut UNumberFormatter;
}
extern "C" {
    pub fn unumf_openForSkeletonAndLocaleWithError_73(
        skeleton: *const UChar,
        skeletonLen: i32,
        locale: *const ::std::os::raw::c_char,
        perror: *mut UParseError,
        ec: *mut UErrorCode,
    ) -> *mut UNumberFormatter;
}
extern "C" {
    pub fn unumf_formatInt_73(
        uformatter: *const UNumberFormatter,
        value: i64,
        uresult: *mut UFormattedNumber,
        ec: *mut UErrorCode,
    );
}
extern "C" {
    pub fn unumf_formatDouble_73(
        uformatter: *const UNumberFormatter,
        value: f64,
        uresult: *mut UFormattedNumber,
        ec: *mut UErrorCode,
    );
}
extern "C" {
    pub fn unumf_formatDecimal_73(
        uformatter: *const UNumberFormatter,
        value: *const ::std::os::raw::c_char,
        valueLen: i32,
        uresult: *mut UFormattedNumber,
        ec: *mut UErrorCode,
    );
}
extern "C" {
    pub fn unumf_close_73(uformatter: *mut UNumberFormatter);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UFormattedNumberRange {
    _unused: [u8; 0],
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UPluralType {
    UPLURAL_TYPE_CARDINAL = 0,
    UPLURAL_TYPE_ORDINAL = 1,
    UPLURAL_TYPE_COUNT = 2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UPluralRules {
    _unused: [u8; 0],
}
extern "C" {
    pub fn uplrules_open_73(
        locale: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> *mut UPluralRules;
}
extern "C" {
    pub fn uplrules_openForType_73(
        locale: *const ::std::os::raw::c_char,
        type_: UPluralType,
        status: *mut UErrorCode,
    ) -> *mut UPluralRules;
}
extern "C" {
    pub fn uplrules_close_73(uplrules: *mut UPluralRules);
}
extern "C" {
    pub fn uplrules_select_73(
        uplrules: *const UPluralRules,
        number: f64,
        keyword: *mut UChar,
        capacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uplrules_selectFormatted_73(
        uplrules: *const UPluralRules,
        number: *const UFormattedNumber,
        keyword: *mut UChar,
        capacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uplrules_selectForRange_73(
        uplrules: *const UPluralRules,
        urange: *const UFormattedNumberRange,
        keyword: *mut UChar,
        capacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uplrules_selectWithFormat_73(
        uplrules: *const UPluralRules,
        number: f64,
        fmt: *const UNumberFormat,
        keyword: *mut UChar,
        capacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uplrules_getKeywords_73(
        uplrules: *const UPluralRules,
        status: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn u_getDataDirectory_73() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_setDataDirectory_73(directory: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn u_getTimeZoneFilesDirectory_73(status: *mut UErrorCode)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_setTimeZoneFilesDirectory_73(
        path: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn u_charsToUChars_73(cs: *const ::std::os::raw::c_char, us: *mut UChar, length: i32);
}
extern "C" {
    pub fn u_UCharsToChars_73(us: *const UChar, cs: *mut ::std::os::raw::c_char, length: i32);
}
extern "C" {
    pub fn u_strlen_73(s: *const UChar) -> i32;
}
extern "C" {
    pub fn u_countChar32_73(s: *const UChar, length: i32) -> i32;
}
extern "C" {
    pub fn u_strHasMoreChar32Than_73(s: *const UChar, length: i32, number: i32) -> UBool;
}
extern "C" {
    pub fn u_strcat_73(dst: *mut UChar, src: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strncat_73(dst: *mut UChar, src: *const UChar, n: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_strstr_73(s: *const UChar, substring: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strFindFirst_73(
        s: *const UChar,
        length: i32,
        substring: *const UChar,
        subLength: i32,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strchr_73(s: *const UChar, c: UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strchr32_73(s: *const UChar, c: UChar32) -> *mut UChar;
}
extern "C" {
    pub fn u_strrstr_73(s: *const UChar, substring: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strFindLast_73(
        s: *const UChar,
        length: i32,
        substring: *const UChar,
        subLength: i32,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strrchr_73(s: *const UChar, c: UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strrchr32_73(s: *const UChar, c: UChar32) -> *mut UChar;
}
extern "C" {
    pub fn u_strpbrk_73(string: *const UChar, matchSet: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strcspn_73(string: *const UChar, matchSet: *const UChar) -> i32;
}
extern "C" {
    pub fn u_strspn_73(string: *const UChar, matchSet: *const UChar) -> i32;
}
extern "C" {
    pub fn u_strtok_r_73(
        src: *mut UChar,
        delim: *const UChar,
        saveState: *mut *mut UChar,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strcmp_73(s1: *const UChar, s2: *const UChar) -> i32;
}
extern "C" {
    pub fn u_strcmpCodePointOrder_73(s1: *const UChar, s2: *const UChar) -> i32;
}
extern "C" {
    pub fn u_strCompare_73(
        s1: *const UChar,
        length1: i32,
        s2: *const UChar,
        length2: i32,
        codePointOrder: UBool,
    ) -> i32;
}
extern "C" {
    pub fn u_strCompareIter_73(
        iter1: *mut UCharIterator,
        iter2: *mut UCharIterator,
        codePointOrder: UBool,
    ) -> i32;
}
extern "C" {
    pub fn u_strCaseCompare_73(
        s1: *const UChar,
        length1: i32,
        s2: *const UChar,
        length2: i32,
        options: u32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strncmp_73(ucs1: *const UChar, ucs2: *const UChar, n: i32) -> i32;
}
extern "C" {
    pub fn u_strncmpCodePointOrder_73(s1: *const UChar, s2: *const UChar, n: i32) -> i32;
}
extern "C" {
    pub fn u_strcasecmp_73(s1: *const UChar, s2: *const UChar, options: u32) -> i32;
}
extern "C" {
    pub fn u_strncasecmp_73(s1: *const UChar, s2: *const UChar, n: i32, options: u32) -> i32;
}
extern "C" {
    pub fn u_memcasecmp_73(s1: *const UChar, s2: *const UChar, length: i32, options: u32) -> i32;
}
extern "C" {
    pub fn u_strcpy_73(dst: *mut UChar, src: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strncpy_73(dst: *mut UChar, src: *const UChar, n: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_uastrcpy_73(dst: *mut UChar, src: *const ::std::os::raw::c_char) -> *mut UChar;
}
extern "C" {
    pub fn u_uastrncpy_73(
        dst: *mut UChar,
        src: *const ::std::os::raw::c_char,
        n: i32,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_austrcpy_73(
        dst: *mut ::std::os::raw::c_char,
        src: *const UChar,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_austrncpy_73(
        dst: *mut ::std::os::raw::c_char,
        src: *const UChar,
        n: i32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_memcpy_73(dest: *mut UChar, src: *const UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memmove_73(dest: *mut UChar, src: *const UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memset_73(dest: *mut UChar, c: UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memcmp_73(buf1: *const UChar, buf2: *const UChar, count: i32) -> i32;
}
extern "C" {
    pub fn u_memcmpCodePointOrder_73(s1: *const UChar, s2: *const UChar, count: i32) -> i32;
}
extern "C" {
    pub fn u_memchr_73(s: *const UChar, c: UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memchr32_73(s: *const UChar, c: UChar32, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memrchr_73(s: *const UChar, c: UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memrchr32_73(s: *const UChar, c: UChar32, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_unescape_73(
        src: *const ::std::os::raw::c_char,
        dest: *mut UChar,
        destCapacity: i32,
    ) -> i32;
}
pub type UNESCAPE_CHAR_AT =
    ::std::option::Option<
        unsafe extern "C" fn(offset: i32, context: *mut ::std::os::raw::c_void)
                             -> UChar,
    >;
extern "C" {
    pub fn u_unescapeAt_73(
        charAt: UNESCAPE_CHAR_AT,
        offset: *mut i32,
        length: i32,
        context: *mut ::std::os::raw::c_void,
    ) -> UChar32;
}
extern "C" {
    pub fn u_strToUpper_73(
        dest: *mut UChar,
        destCapacity: i32,
        src: *const UChar,
        srcLength: i32,
        locale: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strToLower_73(
        dest: *mut UChar,
        destCapacity: i32,
        src: *const UChar,
        srcLength: i32,
        locale: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strToTitle_73(
        dest: *mut UChar,
        destCapacity: i32,
        src: *const UChar,
        srcLength: i32,
        titleIter: *mut UBreakIterator,
        locale: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strFoldCase_73(
        dest: *mut UChar,
        destCapacity: i32,
        src: *const UChar,
        srcLength: i32,
        options: u32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strToWCS_73(
        dest: *mut wchar_t,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn u_strFromWCS_73(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const wchar_t,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToUTF8_73(
        dest: *mut ::std::os::raw::c_char,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_strFromUTF8_73(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const ::std::os::raw::c_char,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToUTF8WithSub_73(
        dest: *mut ::std::os::raw::c_char,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_strFromUTF8WithSub_73(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const ::std::os::raw::c_char,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strFromUTF8Lenient_73(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const ::std::os::raw::c_char,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToUTF32_73(
        dest: *mut UChar32,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar32;
}
extern "C" {
    pub fn u_strFromUTF32_73(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar32,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToUTF32WithSub_73(
        dest: *mut UChar32,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar32;
}
extern "C" {
    pub fn u_strFromUTF32WithSub_73(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar32,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToJavaModifiedUTF8_73(
        dest: *mut ::std::os::raw::c_char,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_strFromJavaModifiedUTF8WithSub_73(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const ::std::os::raw::c_char,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
pub type UReplaceable = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UReplaceableCallbacks {
    pub length: ::std::option::Option<unsafe extern "C" fn(rep: *const UReplaceable) -> i32>,
    pub charAt:
        ::std::option::Option<unsafe extern "C" fn(rep: *const UReplaceable, offset: i32) -> UChar>,
    pub char32At: ::std::option::Option<
        unsafe extern "C" fn(rep: *const UReplaceable,
                             offset: i32)
                             -> UChar32,
    >,
    pub replace: ::std::option::Option<
        unsafe extern "C" fn(rep: *mut UReplaceable,
                             start: i32,
                             limit: i32,
                             text: *const UChar,
                             textLength: i32),
    >,
    pub extract: ::std::option::Option<
        unsafe extern "C" fn(rep: *mut UReplaceable,
                             start: i32,
                             limit: i32,
                             dst: *mut UChar),
    >,
    pub copy: ::std::option::Option<
        unsafe extern "C" fn(rep: *mut UReplaceable,
                             start: i32,
                             limit: i32,
                             dest: i32),
    >,
}
#[test]
fn bindgen_test_layout_UReplaceableCallbacks() {
    assert_eq!(
        ::std::mem::size_of::<UReplaceableCallbacks>(),
        48usize,
        concat!("Size of: ", stringify!(UReplaceableCallbacks))
    );
    assert_eq!(
        ::std::mem::align_of::<UReplaceableCallbacks>(),
        8usize,
        concat!("Alignment of ", stringify!(UReplaceableCallbacks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UReplaceableCallbacks>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UReplaceableCallbacks),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UReplaceableCallbacks>())).charAt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UReplaceableCallbacks),
            "::",
            stringify!(charAt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UReplaceableCallbacks>())).char32At as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UReplaceableCallbacks),
            "::",
            stringify!(char32At)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UReplaceableCallbacks>())).replace as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UReplaceableCallbacks),
            "::",
            stringify!(replace)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UReplaceableCallbacks>())).extract as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UReplaceableCallbacks),
            "::",
            stringify!(extract)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UReplaceableCallbacks>())).copy as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UReplaceableCallbacks),
            "::",
            stringify!(copy)
        )
    );
}
pub type UTransliterator = *mut ::std::os::raw::c_void;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UTransDirection {
    UTRANS_FORWARD = 0,
    UTRANS_REVERSE = 1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UTransPosition {
    pub contextStart: i32,
    pub contextLimit: i32,
    pub start: i32,
    pub limit: i32,
}
#[test]
fn bindgen_test_layout_UTransPosition() {
    assert_eq!(
        ::std::mem::size_of::<UTransPosition>(),
        16usize,
        concat!("Size of: ", stringify!(UTransPosition))
    );
    assert_eq!(
        ::std::mem::align_of::<UTransPosition>(),
        4usize,
        concat!("Alignment of ", stringify!(UTransPosition))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTransPosition>())).contextStart as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UTransPosition),
            "::",
            stringify!(contextStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTransPosition>())).contextLimit as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(UTransPosition),
            "::",
            stringify!(contextLimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTransPosition>())).start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UTransPosition),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTransPosition>())).limit as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(UTransPosition),
            "::",
            stringify!(limit)
        )
    );
}
extern "C" {
    pub fn utrans_openU_73(
        id: *const UChar,
        idLength: i32,
        dir: UTransDirection,
        rules: *const UChar,
        rulesLength: i32,
        parseError: *mut UParseError,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UTransliterator;
}
extern "C" {
    pub fn utrans_openInverse_73(
        trans: *const UTransliterator,
        status: *mut UErrorCode,
    ) -> *mut UTransliterator;
}
extern "C" {
    pub fn utrans_clone_73(
        trans: *const UTransliterator,
        status: *mut UErrorCode,
    ) -> *mut UTransliterator;
}
extern "C" {
    pub fn utrans_close_73(trans: *mut UTransliterator);
}
extern "C" {
    pub fn utrans_getUnicodeID_73(
        trans: *const UTransliterator,
        resultLength: *mut i32,
    ) -> *const UChar;
}
extern "C" {
    pub fn utrans_register_73(adoptedTrans: *mut UTransliterator, status: *mut UErrorCode);
}
extern "C" {
    pub fn utrans_unregisterID_73(id: *const UChar, idLength: i32);
}
extern "C" {
    pub fn utrans_setFilter_73(
        trans: *mut UTransliterator,
        filterPattern: *const UChar,
        filterPatternLen: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn utrans_countAvailableIDs_73() -> i32;
}
extern "C" {
    pub fn utrans_openIDs_73(pErrorCode: *mut UErrorCode) -> *mut UEnumeration;
}
extern "C" {
    pub fn utrans_trans_73(
        trans: *const UTransliterator,
        rep: *mut UReplaceable,
        repFunc: *const UReplaceableCallbacks,
        start: i32,
        limit: *mut i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn utrans_transIncremental_73(
        trans: *const UTransliterator,
        rep: *mut UReplaceable,
        repFunc: *const UReplaceableCallbacks,
        pos: *mut UTransPosition,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn utrans_transUChars_73(
        trans: *const UTransliterator,
        text: *mut UChar,
        textLength: *mut i32,
        textCapacity: i32,
        start: i32,
        limit: *mut i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn utrans_transIncrementalUChars_73(
        trans: *const UTransliterator,
        text: *mut UChar,
        textLength: *mut i32,
        textCapacity: i32,
        pos: *mut UTransPosition,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn utrans_toRules_73(
        trans: *const UTransliterator,
        escapeUnprintable: UBool,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn utrans_getSourceSet_73(
        trans: *const UTransliterator,
        ignoreFilter: UBool,
        fillIn: *mut USet,
        status: *mut UErrorCode,
    ) -> *mut USet;
}
extern "C" {
    pub fn utrans_open_73(
        id: *const ::std::os::raw::c_char,
        dir: UTransDirection,
        rules: *const UChar,
        rulesLength: i32,
        parseError: *mut UParseError,
        status: *mut UErrorCode,
    ) -> *mut UTransliterator;
}
extern "C" {
    pub fn utrans_getID_73(
        trans: *const UTransliterator,
        buf: *mut ::std::os::raw::c_char,
        bufCapacity: i32,
    ) -> i32;
}
extern "C" {
    pub fn utrans_unregister_73(id: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn utrans_getAvailableID_73(
        index: i32,
        buf: *mut ::std::os::raw::c_char,
        bufCapacity: i32,
    ) -> i32;
}
#[repr(C)]
#[derive(Copy, Clone)]pub union UCPTrieData { pub ptr0 : * const :: std :: os :: raw :: c_void , pub ptr16 : * const u16 , pub ptr32 : * const u32 , pub ptr8 : * const u8 , }#[test]
fn bindgen_test_layout_UCPTrieData() {
    assert_eq!(
        ::std::mem::size_of::<UCPTrieData>(),
        8usize,
        concat!("Size of: ", stringify!(UCPTrieData))
    );
    assert_eq!(
        ::std::mem::align_of::<UCPTrieData>(),
        8usize,
        concat!("Alignment of ", stringify!(UCPTrieData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCPTrieData>())).ptr0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UCPTrieData),
            "::",
            stringify!(ptr0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCPTrieData>())).ptr16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UCPTrieData),
            "::",
            stringify!(ptr16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCPTrieData>())).ptr32 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UCPTrieData),
            "::",
            stringify!(ptr32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCPTrieData>())).ptr8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UCPTrieData),
            "::",
            stringify!(ptr8)
        )
    );
}
impl Default for UCPTrieData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct UCPTrie {
    pub index: *const u16,
    pub data: UCPTrieData,
    pub indexLength: i32,
    pub dataLength: i32,
    pub highStart: UChar32,
    pub shifted12HighStart: u16,
    pub type_: i8,
    pub valueWidth: i8,
    pub reserved32: u32,
    pub reserved16: u16,
    pub index3NullOffset: u16,
    pub dataNullOffset: i32,
    pub nullValue: u32,
}
#[test]
fn bindgen_test_layout_UCPTrie() {
    assert_eq!(
        ::std::mem::size_of::<UCPTrie>(),
        48usize,
        concat!("Size of: ", stringify!(UCPTrie))
    );
    assert_eq!(
        ::std::mem::align_of::<UCPTrie>(),
        8usize,
        concat!("Alignment of ", stringify!(UCPTrie))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCPTrie>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(UCPTrie),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCPTrie>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(UCPTrie),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCPTrie>())).indexLength as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(UCPTrie),
            "::",
            stringify!(indexLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCPTrie>())).dataLength as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(UCPTrie),
            "::",
            stringify!(dataLength)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCPTrie>())).highStart as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(UCPTrie),
            "::",
            stringify!(highStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCPTrie>())).shifted12HighStart as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(UCPTrie),
            "::",
            stringify!(shifted12HighStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCPTrie>())).type_ as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(UCPTrie),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCPTrie>())).valueWidth as *const _ as usize },
        31usize,
        concat!(
            "Offset of field: ",
            stringify!(UCPTrie),
            "::",
            stringify!(valueWidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCPTrie>())).reserved32 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(UCPTrie),
            "::",
            stringify!(reserved32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCPTrie>())).reserved16 as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(UCPTrie),
            "::",
            stringify!(reserved16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCPTrie>())).index3NullOffset as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(UCPTrie),
            "::",
            stringify!(index3NullOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCPTrie>())).dataNullOffset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(UCPTrie),
            "::",
            stringify!(dataNullOffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCPTrie>())).nullValue as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(UCPTrie),
            "::",
            stringify!(nullValue)
        )
    );
}
impl Default for UCPTrie {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UCPTrieType {
    UCPTRIE_TYPE_ANY = - 1,
    UCPTRIE_TYPE_FAST = 0,
    UCPTRIE_TYPE_SMALL = 1,
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq, Eq)]
pub enum UCPTrieValueWidth {
    UCPTRIE_VALUE_BITS_ANY = - 1,
    UCPTRIE_VALUE_BITS_16 = 0,
    UCPTRIE_VALUE_BITS_32 = 1,
    UCPTRIE_VALUE_BITS_8 = 2,
}
extern "C" {
    pub fn ucptrie_openFromBinary_73(
        type_: UCPTrieType,
        valueWidth: UCPTrieValueWidth,
        data: *const ::std::os::raw::c_void,
        length: i32,
        pActualLength: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UCPTrie;
}
extern "C" {
    pub fn ucptrie_close_73(trie: *mut UCPTrie);
}
extern "C" {
    pub fn ucptrie_getType_73(trie: *const UCPTrie) -> UCPTrieType;
}
extern "C" {
    pub fn ucptrie_getValueWidth_73(trie: *const UCPTrie) -> UCPTrieValueWidth;
}
extern "C" {
    pub fn ucptrie_get_73(trie: *const UCPTrie, c: UChar32) -> u32;
}
extern "C" {
    pub fn ucptrie_getRange_73(
        trie: *const UCPTrie,
        start: UChar32,
        option: UCPMapRangeOption,
        surrogateValue: u32,
        filter: UCPMapValueFilter,
        context: *const ::std::os::raw::c_void,
        pValue: *mut u32,
    ) -> UChar32;
}
extern "C" {
    pub fn ucptrie_toBinary_73(
        trie: *const UCPTrie,
        data: *mut ::std::os::raw::c_void,
        capacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucptrie_internalSmallIndex_73(trie: *const UCPTrie, c: UChar32) -> i32;
}
extern "C" {
    pub fn ucptrie_internalSmallU8Index_73(trie: *const UCPTrie, lt1: i32, t2: u8, t3: u8) -> i32;
}
extern "C" {
    pub fn ucptrie_internalU8PrevIndex_73(
        trie: *const UCPTrie,
        c: UChar32,
        start: *const u8,
        src: *const u8,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UMutableCPTrie {
    _unused: [u8; 0],
}
extern "C" {
    pub fn umutablecptrie_open_73(
        initialValue: u32,
        errorValue: u32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UMutableCPTrie;
}
extern "C" {
    pub fn umutablecptrie_clone_73(
        other: *const UMutableCPTrie,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UMutableCPTrie;
}
extern "C" {
    pub fn umutablecptrie_close_73(trie: *mut UMutableCPTrie);
}
extern "C" {
    pub fn umutablecptrie_fromUCPMap_73(
        map: *const UCPMap,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UMutableCPTrie;
}
extern "C" {
    pub fn umutablecptrie_fromUCPTrie_73(
        trie: *const UCPTrie,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UMutableCPTrie;
}
extern "C" {
    pub fn umutablecptrie_get_73(trie: *const UMutableCPTrie, c: UChar32) -> u32;
}
extern "C" {
    pub fn umutablecptrie_getRange_73(
        trie: *const UMutableCPTrie,
        start: UChar32,
        option: UCPMapRangeOption,
        surrogateValue: u32,
        filter: UCPMapValueFilter,
        context: *const ::std::os::raw::c_void,
        pValue: *mut u32,
    ) -> UChar32;
}
extern "C" {
    pub fn umutablecptrie_set_73(
        trie: *mut UMutableCPTrie,
        c: UChar32,
        value: u32,
        pErrorCode: *mut UErrorCode,
    );
}
extern "C" {
    pub fn umutablecptrie_setRange_73(
        trie: *mut UMutableCPTrie,
        start: UChar32,
        end: UChar32,
        value: u32,
        pErrorCode: *mut UErrorCode,
    );
}
extern "C" {
    pub fn umutablecptrie_buildImmutable_73(
        trie: *mut UMutableCPTrie,
        type_: UCPTrieType,
        valueWidth: UCPTrieValueWidth,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UCPTrie;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
