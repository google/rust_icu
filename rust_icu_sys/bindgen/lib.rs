/* automatically generated by rust-bindgen */

pub type wchar_t = ::std::os::raw::c_int;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type UBool = i8;
pub type UChar = u16;
pub type OldUChar = ::std::os::raw::c_ushort;
pub type UChar32 = i32;
pub type UVersionInfo = [u8; 4usize];
extern "C" {
    pub fn u_versionFromString_64(
        versionArray: *mut u8,
        versionString: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn u_versionFromUString_64(versionArray: *mut u8, versionString: *const UChar);
}
extern "C" {
    pub fn u_versionToString_64(versionArray: *mut u8, versionString: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn u_getVersion_64(versionArray: *mut u8);
}
pub type UDate = f64;
impl UErrorCode {
    pub const U_ERROR_WARNING_START: UErrorCode = UErrorCode::U_USING_FALLBACK_WARNING;
}
impl UErrorCode {
    pub const U_PARSE_ERROR_START: UErrorCode = UErrorCode::U_BAD_VARIABLE_DEFINITION;
}
impl UErrorCode {
    pub const U_FMT_PARSE_ERROR_START: UErrorCode = UErrorCode::U_UNEXPECTED_TOKEN;
}
impl UErrorCode {
    pub const U_MULTIPLE_DECIMAL_SEPERATORS: UErrorCode = UErrorCode::U_MULTIPLE_DECIMAL_SEPARATORS;
}
impl UErrorCode {
    pub const U_BRK_ERROR_START: UErrorCode = UErrorCode::U_BRK_INTERNAL_ERROR;
}
impl UErrorCode {
    pub const U_REGEX_ERROR_START: UErrorCode = UErrorCode::U_REGEX_INTERNAL_ERROR;
}
impl UErrorCode {
    pub const U_IDNA_ERROR_START: UErrorCode = UErrorCode::U_IDNA_PROHIBITED_ERROR;
}
impl UErrorCode {
    pub const U_STRINGPREP_PROHIBITED_ERROR: UErrorCode = UErrorCode::U_IDNA_PROHIBITED_ERROR;
}
impl UErrorCode {
    pub const U_STRINGPREP_UNASSIGNED_ERROR: UErrorCode = UErrorCode::U_IDNA_UNASSIGNED_ERROR;
}
impl UErrorCode {
    pub const U_STRINGPREP_CHECK_BIDI_ERROR: UErrorCode = UErrorCode::U_IDNA_CHECK_BIDI_ERROR;
}
impl UErrorCode {
    pub const U_PLUGIN_TOO_HIGH: UErrorCode = UErrorCode::U_PLUGIN_ERROR_START;
}
impl UErrorCode {
    pub const U_ERROR_LIMIT: UErrorCode = UErrorCode::U_PLUGIN_ERROR_LIMIT;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UErrorCode {
    U_USING_FALLBACK_WARNING = -128,
    U_USING_DEFAULT_WARNING = -127,
    U_SAFECLONE_ALLOCATED_WARNING = -126,
    U_STATE_OLD_WARNING = -125,
    U_STRING_NOT_TERMINATED_WARNING = -124,
    U_SORT_KEY_TOO_SHORT_WARNING = -123,
    U_AMBIGUOUS_ALIAS_WARNING = -122,
    U_DIFFERENT_UCA_VERSION = -121,
    U_PLUGIN_CHANGED_LEVEL_WARNING = -120,
    U_ERROR_WARNING_LIMIT = -119,
    U_ZERO_ERROR = 0,
    U_ILLEGAL_ARGUMENT_ERROR = 1,
    U_MISSING_RESOURCE_ERROR = 2,
    U_INVALID_FORMAT_ERROR = 3,
    U_FILE_ACCESS_ERROR = 4,
    U_INTERNAL_PROGRAM_ERROR = 5,
    U_MESSAGE_PARSE_ERROR = 6,
    U_MEMORY_ALLOCATION_ERROR = 7,
    U_INDEX_OUTOFBOUNDS_ERROR = 8,
    U_PARSE_ERROR = 9,
    U_INVALID_CHAR_FOUND = 10,
    U_TRUNCATED_CHAR_FOUND = 11,
    U_ILLEGAL_CHAR_FOUND = 12,
    U_INVALID_TABLE_FORMAT = 13,
    U_INVALID_TABLE_FILE = 14,
    U_BUFFER_OVERFLOW_ERROR = 15,
    U_UNSUPPORTED_ERROR = 16,
    U_RESOURCE_TYPE_MISMATCH = 17,
    U_ILLEGAL_ESCAPE_SEQUENCE = 18,
    U_UNSUPPORTED_ESCAPE_SEQUENCE = 19,
    U_NO_SPACE_AVAILABLE = 20,
    U_CE_NOT_FOUND_ERROR = 21,
    U_PRIMARY_TOO_LONG_ERROR = 22,
    U_STATE_TOO_OLD_ERROR = 23,
    U_TOO_MANY_ALIASES_ERROR = 24,
    U_ENUM_OUT_OF_SYNC_ERROR = 25,
    U_INVARIANT_CONVERSION_ERROR = 26,
    U_INVALID_STATE_ERROR = 27,
    U_COLLATOR_VERSION_MISMATCH = 28,
    U_USELESS_COLLATOR_ERROR = 29,
    U_NO_WRITE_PERMISSION = 30,
    U_STANDARD_ERROR_LIMIT = 31,
    U_BAD_VARIABLE_DEFINITION = 65536,
    U_MALFORMED_RULE = 65537,
    U_MALFORMED_SET = 65538,
    U_MALFORMED_SYMBOL_REFERENCE = 65539,
    U_MALFORMED_UNICODE_ESCAPE = 65540,
    U_MALFORMED_VARIABLE_DEFINITION = 65541,
    U_MALFORMED_VARIABLE_REFERENCE = 65542,
    U_MISMATCHED_SEGMENT_DELIMITERS = 65543,
    U_MISPLACED_ANCHOR_START = 65544,
    U_MISPLACED_CURSOR_OFFSET = 65545,
    U_MISPLACED_QUANTIFIER = 65546,
    U_MISSING_OPERATOR = 65547,
    U_MISSING_SEGMENT_CLOSE = 65548,
    U_MULTIPLE_ANTE_CONTEXTS = 65549,
    U_MULTIPLE_CURSORS = 65550,
    U_MULTIPLE_POST_CONTEXTS = 65551,
    U_TRAILING_BACKSLASH = 65552,
    U_UNDEFINED_SEGMENT_REFERENCE = 65553,
    U_UNDEFINED_VARIABLE = 65554,
    U_UNQUOTED_SPECIAL = 65555,
    U_UNTERMINATED_QUOTE = 65556,
    U_RULE_MASK_ERROR = 65557,
    U_MISPLACED_COMPOUND_FILTER = 65558,
    U_MULTIPLE_COMPOUND_FILTERS = 65559,
    U_INVALID_RBT_SYNTAX = 65560,
    U_INVALID_PROPERTY_PATTERN = 65561,
    U_MALFORMED_PRAGMA = 65562,
    U_UNCLOSED_SEGMENT = 65563,
    U_ILLEGAL_CHAR_IN_SEGMENT = 65564,
    U_VARIABLE_RANGE_EXHAUSTED = 65565,
    U_VARIABLE_RANGE_OVERLAP = 65566,
    U_ILLEGAL_CHARACTER = 65567,
    U_INTERNAL_TRANSLITERATOR_ERROR = 65568,
    U_INVALID_ID = 65569,
    U_INVALID_FUNCTION = 65570,
    U_PARSE_ERROR_LIMIT = 65571,
    U_UNEXPECTED_TOKEN = 65792,
    U_MULTIPLE_DECIMAL_SEPARATORS = 65793,
    U_MULTIPLE_EXPONENTIAL_SYMBOLS = 65794,
    U_MALFORMED_EXPONENTIAL_PATTERN = 65795,
    U_MULTIPLE_PERCENT_SYMBOLS = 65796,
    U_MULTIPLE_PERMILL_SYMBOLS = 65797,
    U_MULTIPLE_PAD_SPECIFIERS = 65798,
    U_PATTERN_SYNTAX_ERROR = 65799,
    U_ILLEGAL_PAD_POSITION = 65800,
    U_UNMATCHED_BRACES = 65801,
    U_UNSUPPORTED_PROPERTY = 65802,
    U_UNSUPPORTED_ATTRIBUTE = 65803,
    U_ARGUMENT_TYPE_MISMATCH = 65804,
    U_DUPLICATE_KEYWORD = 65805,
    U_UNDEFINED_KEYWORD = 65806,
    U_DEFAULT_KEYWORD_MISSING = 65807,
    U_DECIMAL_NUMBER_SYNTAX_ERROR = 65808,
    U_FORMAT_INEXACT_ERROR = 65809,
    U_NUMBER_ARG_OUTOFBOUNDS_ERROR = 65810,
    U_NUMBER_SKELETON_SYNTAX_ERROR = 65811,
    U_FMT_PARSE_ERROR_LIMIT = 65812,
    U_BRK_INTERNAL_ERROR = 66048,
    U_BRK_HEX_DIGITS_EXPECTED = 66049,
    U_BRK_SEMICOLON_EXPECTED = 66050,
    U_BRK_RULE_SYNTAX = 66051,
    U_BRK_UNCLOSED_SET = 66052,
    U_BRK_ASSIGN_ERROR = 66053,
    U_BRK_VARIABLE_REDFINITION = 66054,
    U_BRK_MISMATCHED_PAREN = 66055,
    U_BRK_NEW_LINE_IN_QUOTED_STRING = 66056,
    U_BRK_UNDEFINED_VARIABLE = 66057,
    U_BRK_INIT_ERROR = 66058,
    U_BRK_RULE_EMPTY_SET = 66059,
    U_BRK_UNRECOGNIZED_OPTION = 66060,
    U_BRK_MALFORMED_RULE_TAG = 66061,
    U_BRK_ERROR_LIMIT = 66062,
    U_REGEX_INTERNAL_ERROR = 66304,
    U_REGEX_RULE_SYNTAX = 66305,
    U_REGEX_INVALID_STATE = 66306,
    U_REGEX_BAD_ESCAPE_SEQUENCE = 66307,
    U_REGEX_PROPERTY_SYNTAX = 66308,
    U_REGEX_UNIMPLEMENTED = 66309,
    U_REGEX_MISMATCHED_PAREN = 66310,
    U_REGEX_NUMBER_TOO_BIG = 66311,
    U_REGEX_BAD_INTERVAL = 66312,
    U_REGEX_MAX_LT_MIN = 66313,
    U_REGEX_INVALID_BACK_REF = 66314,
    U_REGEX_INVALID_FLAG = 66315,
    U_REGEX_LOOK_BEHIND_LIMIT = 66316,
    U_REGEX_SET_CONTAINS_STRING = 66317,
    U_REGEX_OCTAL_TOO_BIG = 66318,
    U_REGEX_MISSING_CLOSE_BRACKET = 66319,
    U_REGEX_INVALID_RANGE = 66320,
    U_REGEX_STACK_OVERFLOW = 66321,
    U_REGEX_TIME_OUT = 66322,
    U_REGEX_STOPPED_BY_CALLER = 66323,
    U_REGEX_PATTERN_TOO_BIG = 66324,
    U_REGEX_INVALID_CAPTURE_GROUP_NAME = 66325,
    U_REGEX_ERROR_LIMIT = 66326,
    U_IDNA_PROHIBITED_ERROR = 66560,
    U_IDNA_UNASSIGNED_ERROR = 66561,
    U_IDNA_CHECK_BIDI_ERROR = 66562,
    U_IDNA_STD3_ASCII_RULES_ERROR = 66563,
    U_IDNA_ACE_PREFIX_ERROR = 66564,
    U_IDNA_VERIFICATION_ERROR = 66565,
    U_IDNA_LABEL_TOO_LONG_ERROR = 66566,
    U_IDNA_ZERO_LENGTH_LABEL_ERROR = 66567,
    U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR = 66568,
    U_IDNA_ERROR_LIMIT = 66569,
    U_PLUGIN_ERROR_START = 66816,
    U_PLUGIN_DIDNT_SET_LEVEL = 66817,
    U_PLUGIN_ERROR_LIMIT = 66818,
}
extern "C" {
    pub fn u_errorName_64(code: UErrorCode) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UEnumeration {
    _unused: [u8; 0],
}
extern "C" {
    pub fn uenum_close_64(en: *mut UEnumeration);
}
extern "C" {
    pub fn uenum_count_64(en: *mut UEnumeration, status: *mut UErrorCode) -> i32;
}
extern "C" {
    pub fn uenum_unext_64(
        en: *mut UEnumeration,
        resultLength: *mut i32,
        status: *mut UErrorCode,
    ) -> *const UChar;
}
extern "C" {
    pub fn u_cleanup_64();
}
extern "C" {
    pub fn uenum_next_64(
        en: *mut UEnumeration,
        resultLength: *mut i32,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uenum_reset_64(en: *mut UEnumeration, status: *mut UErrorCode);
}
extern "C" {
    pub fn uenum_openUCharStringsEnumeration_64(
        strings: *const *const UChar,
        count: i32,
        ec: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn uenum_openCharStringsEnumeration_64(
        strings: *const *const ::std::os::raw::c_char,
        count: i32,
        ec: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum ULocDataLocaleType {
    ULOC_ACTUAL_LOCALE = 0,
    ULOC_VALID_LOCALE = 1,
    ULOC_REQUESTED_LOCALE = 2,
    ULOC_DATA_LOCALE_TYPE_LIMIT = 3,
}
extern "C" {
    pub fn uloc_getDefault_64() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_setDefault_64(localeID: *const ::std::os::raw::c_char, status: *mut UErrorCode);
}
extern "C" {
    pub fn uloc_getLanguage_64(
        localeID: *const ::std::os::raw::c_char,
        language: *mut ::std::os::raw::c_char,
        languageCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getScript_64(
        localeID: *const ::std::os::raw::c_char,
        script: *mut ::std::os::raw::c_char,
        scriptCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getCountry_64(
        localeID: *const ::std::os::raw::c_char,
        country: *mut ::std::os::raw::c_char,
        countryCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getVariant_64(
        localeID: *const ::std::os::raw::c_char,
        variant: *mut ::std::os::raw::c_char,
        variantCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getName_64(
        localeID: *const ::std::os::raw::c_char,
        name: *mut ::std::os::raw::c_char,
        nameCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_canonicalize_64(
        localeID: *const ::std::os::raw::c_char,
        name: *mut ::std::os::raw::c_char,
        nameCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getISO3Language_64(
        localeID: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_getISO3Country_64(
        localeID: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_getLCID_64(localeID: *const ::std::os::raw::c_char) -> u32;
}
extern "C" {
    pub fn uloc_getDisplayLanguage_64(
        locale: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        language: *mut UChar,
        languageCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayScript_64(
        locale: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        script: *mut UChar,
        scriptCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayCountry_64(
        locale: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        country: *mut UChar,
        countryCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayVariant_64(
        locale: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        variant: *mut UChar,
        variantCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayKeyword_64(
        keyword: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        dest: *mut UChar,
        destCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayKeywordValue_64(
        locale: *const ::std::os::raw::c_char,
        keyword: *const ::std::os::raw::c_char,
        displayLocale: *const ::std::os::raw::c_char,
        dest: *mut UChar,
        destCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getDisplayName_64(
        localeID: *const ::std::os::raw::c_char,
        inLocaleID: *const ::std::os::raw::c_char,
        result: *mut UChar,
        maxResultSize: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getAvailable_64(n: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_countAvailable_64() -> i32;
}
extern "C" {
    pub fn uloc_getISOLanguages_64() -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_getISOCountries_64() -> *const *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_getParent_64(
        localeID: *const ::std::os::raw::c_char,
        parent: *mut ::std::os::raw::c_char,
        parentCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getBaseName_64(
        localeID: *const ::std::os::raw::c_char,
        name: *mut ::std::os::raw::c_char,
        nameCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_openKeywords_64(
        localeID: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn uloc_getKeywordValue_64(
        localeID: *const ::std::os::raw::c_char,
        keywordName: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        bufferCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_setKeywordValue_64(
        keywordName: *const ::std::os::raw::c_char,
        keywordValue: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_char,
        bufferCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_isRightToLeft_64(locale: *const ::std::os::raw::c_char) -> UBool;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum ULayoutType {
    ULOC_LAYOUT_LTR = 0,
    ULOC_LAYOUT_RTL = 1,
    ULOC_LAYOUT_TTB = 2,
    ULOC_LAYOUT_BTT = 3,
    ULOC_LAYOUT_UNKNOWN = 4,
}
extern "C" {
    pub fn uloc_getCharacterOrientation_64(
        localeId: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> ULayoutType;
}
extern "C" {
    pub fn uloc_getLineOrientation_64(
        localeId: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    ) -> ULayoutType;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UAcceptResult {
    ULOC_ACCEPT_FAILED = 0,
    ULOC_ACCEPT_VALID = 1,
    ULOC_ACCEPT_FALLBACK = 2,
}
extern "C" {
    pub fn uloc_acceptLanguageFromHTTP_64(
        result: *mut ::std::os::raw::c_char,
        resultAvailable: i32,
        outResult: *mut UAcceptResult,
        httpAcceptLanguage: *const ::std::os::raw::c_char,
        availableLocales: *mut UEnumeration,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_acceptLanguage_64(
        result: *mut ::std::os::raw::c_char,
        resultAvailable: i32,
        outResult: *mut UAcceptResult,
        acceptList: *mut *const ::std::os::raw::c_char,
        acceptListCount: i32,
        availableLocales: *mut UEnumeration,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_getLocaleForLCID_64(
        hostID: u32,
        locale: *mut ::std::os::raw::c_char,
        localeCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_addLikelySubtags_64(
        localeID: *const ::std::os::raw::c_char,
        maximizedLocaleID: *mut ::std::os::raw::c_char,
        maximizedLocaleIDCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_minimizeSubtags_64(
        localeID: *const ::std::os::raw::c_char,
        minimizedLocaleID: *mut ::std::os::raw::c_char,
        minimizedLocaleIDCapacity: i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_forLanguageTag_64(
        langtag: *const ::std::os::raw::c_char,
        localeID: *mut ::std::os::raw::c_char,
        localeIDCapacity: i32,
        parsedLength: *mut i32,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_toLanguageTag_64(
        localeID: *const ::std::os::raw::c_char,
        langtag: *mut ::std::os::raw::c_char,
        langtagCapacity: i32,
        strict: UBool,
        err: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn uloc_toUnicodeLocaleKey_64(
        keyword: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_toUnicodeLocaleType_64(
        keyword: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_toLegacyKey_64(
        keyword: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn uloc_toLegacyType_64(
        keyword: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
pub type UCalendar = *mut ::std::os::raw::c_void;
impl UCalendarType {
    pub const UCAL_DEFAULT: UCalendarType = UCalendarType::UCAL_TRADITIONAL;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarType {
    UCAL_TRADITIONAL = 0,
    UCAL_GREGORIAN = 1,
}
impl UCalendarDateFields {
    pub const UCAL_DAY_OF_MONTH: UCalendarDateFields = UCalendarDateFields::UCAL_DATE;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarDateFields {
    UCAL_ERA = 0,
    UCAL_YEAR = 1,
    UCAL_MONTH = 2,
    UCAL_WEEK_OF_YEAR = 3,
    UCAL_WEEK_OF_MONTH = 4,
    UCAL_DATE = 5,
    UCAL_DAY_OF_YEAR = 6,
    UCAL_DAY_OF_WEEK = 7,
    UCAL_DAY_OF_WEEK_IN_MONTH = 8,
    UCAL_AM_PM = 9,
    UCAL_HOUR = 10,
    UCAL_HOUR_OF_DAY = 11,
    UCAL_MINUTE = 12,
    UCAL_SECOND = 13,
    UCAL_MILLISECOND = 14,
    UCAL_ZONE_OFFSET = 15,
    UCAL_DST_OFFSET = 16,
    UCAL_YEAR_WOY = 17,
    UCAL_DOW_LOCAL = 18,
    UCAL_EXTENDED_YEAR = 19,
    UCAL_JULIAN_DAY = 20,
    UCAL_MILLISECONDS_IN_DAY = 21,
    UCAL_IS_LEAP_MONTH = 22,
    UCAL_FIELD_COUNT = 23,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarDaysOfWeek {
    UCAL_SUNDAY = 1,
    UCAL_MONDAY = 2,
    UCAL_TUESDAY = 3,
    UCAL_WEDNESDAY = 4,
    UCAL_THURSDAY = 5,
    UCAL_FRIDAY = 6,
    UCAL_SATURDAY = 7,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarMonths {
    UCAL_JANUARY = 0,
    UCAL_FEBRUARY = 1,
    UCAL_MARCH = 2,
    UCAL_APRIL = 3,
    UCAL_MAY = 4,
    UCAL_JUNE = 5,
    UCAL_JULY = 6,
    UCAL_AUGUST = 7,
    UCAL_SEPTEMBER = 8,
    UCAL_OCTOBER = 9,
    UCAL_NOVEMBER = 10,
    UCAL_DECEMBER = 11,
    UCAL_UNDECIMBER = 12,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarAMPMs {
    UCAL_AM = 0,
    UCAL_PM = 1,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum USystemTimeZoneType {
    UCAL_ZONE_TYPE_ANY = 0,
    UCAL_ZONE_TYPE_CANONICAL = 1,
    UCAL_ZONE_TYPE_CANONICAL_LOCATION = 2,
}
extern "C" {
    pub fn ucal_openTimeZoneIDEnumeration_64(
        zoneType: USystemTimeZoneType,
        region: *const ::std::os::raw::c_char,
        rawOffset: *const i32,
        ec: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucal_openTimeZones_64(ec: *mut UErrorCode) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucal_openCountryTimeZones_64(
        country: *const ::std::os::raw::c_char,
        ec: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
extern "C" {
    pub fn ucal_getDefaultTimeZone_64(
        result: *mut UChar,
        resultCapacity: i32,
        ec: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_setDefaultTimeZone_64(zoneID: *const UChar, ec: *mut UErrorCode);
}
extern "C" {
    pub fn ucal_getDSTSavings_64(zoneID: *const UChar, ec: *mut UErrorCode) -> i32;
}
extern "C" {
    pub fn ucal_getNow_64() -> UDate;
}
extern "C" {
    pub fn ucal_open_64(
        zoneID: *const UChar,
        len: i32,
        locale: *const ::std::os::raw::c_char,
        type_: UCalendarType,
        status: *mut UErrorCode,
    ) -> *mut UCalendar;
}
extern "C" {
    pub fn ucal_close_64(cal: *mut UCalendar);
}
extern "C" {
    pub fn ucal_clone_64(cal: *const UCalendar, status: *mut UErrorCode) -> *mut UCalendar;
}
extern "C" {
    pub fn ucal_setTimeZone_64(
        cal: *mut UCalendar,
        zoneID: *const UChar,
        len: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_getTimeZoneID_64(
        cal: *const UCalendar,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarDisplayNameType {
    UCAL_STANDARD = 0,
    UCAL_SHORT_STANDARD = 1,
    UCAL_DST = 2,
    UCAL_SHORT_DST = 3,
}
extern "C" {
    pub fn ucal_getTimeZoneDisplayName_64(
        cal: *const UCalendar,
        type_: UCalendarDisplayNameType,
        locale: *const ::std::os::raw::c_char,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_inDaylightTime_64(cal: *const UCalendar, status: *mut UErrorCode) -> UBool;
}
extern "C" {
    pub fn ucal_setGregorianChange_64(
        cal: *mut UCalendar,
        date: UDate,
        pErrorCode: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_getGregorianChange_64(cal: *const UCalendar, pErrorCode: *mut UErrorCode) -> UDate;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarAttribute {
    UCAL_LENIENT = 0,
    UCAL_FIRST_DAY_OF_WEEK = 1,
    UCAL_MINIMAL_DAYS_IN_FIRST_WEEK = 2,
    UCAL_REPEATED_WALL_TIME = 3,
    UCAL_SKIPPED_WALL_TIME = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarWallTimeOption {
    UCAL_WALLTIME_LAST = 0,
    UCAL_WALLTIME_FIRST = 1,
    UCAL_WALLTIME_NEXT_VALID = 2,
}
extern "C" {
    pub fn ucal_getAttribute_64(cal: *const UCalendar, attr: UCalendarAttribute) -> i32;
}
extern "C" {
    pub fn ucal_setAttribute_64(cal: *mut UCalendar, attr: UCalendarAttribute, newValue: i32);
}
extern "C" {
    pub fn ucal_getAvailable_64(localeIndex: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucal_countAvailable_64() -> i32;
}
extern "C" {
    pub fn ucal_getMillis_64(cal: *const UCalendar, status: *mut UErrorCode) -> UDate;
}
extern "C" {
    pub fn ucal_setMillis_64(cal: *mut UCalendar, dateTime: UDate, status: *mut UErrorCode);
}
extern "C" {
    pub fn ucal_setDate_64(
        cal: *mut UCalendar,
        year: i32,
        month: i32,
        date: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_setDateTime_64(
        cal: *mut UCalendar,
        year: i32,
        month: i32,
        date: i32,
        hour: i32,
        minute: i32,
        second: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_equivalentTo_64(cal1: *const UCalendar, cal2: *const UCalendar) -> UBool;
}
extern "C" {
    pub fn ucal_add_64(
        cal: *mut UCalendar,
        field: UCalendarDateFields,
        amount: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_roll_64(
        cal: *mut UCalendar,
        field: UCalendarDateFields,
        amount: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn ucal_get_64(
        cal: *const UCalendar,
        field: UCalendarDateFields,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_set_64(cal: *mut UCalendar, field: UCalendarDateFields, value: i32);
}
extern "C" {
    pub fn ucal_isSet_64(cal: *const UCalendar, field: UCalendarDateFields) -> UBool;
}
extern "C" {
    pub fn ucal_clearField_64(cal: *mut UCalendar, field: UCalendarDateFields);
}
extern "C" {
    pub fn ucal_clear_64(calendar: *mut UCalendar);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarLimitType {
    UCAL_MINIMUM = 0,
    UCAL_MAXIMUM = 1,
    UCAL_GREATEST_MINIMUM = 2,
    UCAL_LEAST_MAXIMUM = 3,
    UCAL_ACTUAL_MINIMUM = 4,
    UCAL_ACTUAL_MAXIMUM = 5,
}
extern "C" {
    pub fn ucal_getLimit_64(
        cal: *const UCalendar,
        field: UCalendarDateFields,
        type_: UCalendarLimitType,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_getLocaleByType_64(
        cal: *const UCalendar,
        type_: ULocDataLocaleType,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucal_getTZDataVersion_64(status: *mut UErrorCode) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucal_getCanonicalTimeZoneID_64(
        id: *const UChar,
        len: i32,
        result: *mut UChar,
        resultCapacity: i32,
        isSystemID: *mut UBool,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_getType_64(
        cal: *const UCalendar,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ucal_getKeywordValuesForLocale_64(
        key: *const ::std::os::raw::c_char,
        locale: *const ::std::os::raw::c_char,
        commonlyUsed: UBool,
        status: *mut UErrorCode,
    ) -> *mut UEnumeration;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCalendarWeekdayType {
    UCAL_WEEKDAY = 0,
    UCAL_WEEKEND = 1,
    UCAL_WEEKEND_ONSET = 2,
    UCAL_WEEKEND_CEASE = 3,
}
extern "C" {
    pub fn ucal_getDayOfWeekType_64(
        cal: *const UCalendar,
        dayOfWeek: UCalendarDaysOfWeek,
        status: *mut UErrorCode,
    ) -> UCalendarWeekdayType;
}
extern "C" {
    pub fn ucal_getWeekendTransition_64(
        cal: *const UCalendar,
        dayOfWeek: UCalendarDaysOfWeek,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_isWeekend_64(cal: *const UCalendar, date: UDate, status: *mut UErrorCode) -> UBool;
}
extern "C" {
    pub fn ucal_getFieldDifference_64(
        cal: *mut UCalendar,
        target: UDate,
        field: UCalendarDateFields,
        status: *mut UErrorCode,
    ) -> i32;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UTimeZoneTransitionType {
    UCAL_TZ_TRANSITION_NEXT = 0,
    UCAL_TZ_TRANSITION_NEXT_INCLUSIVE = 1,
    UCAL_TZ_TRANSITION_PREVIOUS = 2,
    UCAL_TZ_TRANSITION_PREVIOUS_INCLUSIVE = 3,
}
extern "C" {
    pub fn ucal_getTimeZoneTransitionDate_64(
        cal: *const UCalendar,
        type_: UTimeZoneTransitionType,
        transition: *mut UDate,
        status: *mut UErrorCode,
    ) -> UBool;
}
extern "C" {
    pub fn ucal_getWindowsTimeZoneID_64(
        id: *const UChar,
        len: i32,
        winid: *mut UChar,
        winidCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn ucal_getTimeZoneIDForWindowsID_64(
        winid: *const UChar,
        len: i32,
        region: *const ::std::os::raw::c_char,
        id: *mut UChar,
        idCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UFieldPosition {
    pub field: i32,
    pub beginIndex: i32,
    pub endIndex: i32,
}
#[test]
fn bindgen_test_layout_UFieldPosition() {
    assert_eq!(
        ::std::mem::size_of::<UFieldPosition>(),
        12usize,
        concat!("Size of: ", stringify!(UFieldPosition))
    );
    assert_eq!(
        ::std::mem::align_of::<UFieldPosition>(),
        4usize,
        concat!("Alignment of ", stringify!(UFieldPosition))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UFieldPosition>())).field as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(UFieldPosition), "::", stringify!(field))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UFieldPosition>())).beginIndex as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(UFieldPosition), "::", stringify!(beginIndex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UFieldPosition>())).endIndex as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(UFieldPosition), "::", stringify!(endIndex))
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDisplayContextType {
    UDISPCTX_TYPE_DIALECT_HANDLING = 0,
    UDISPCTX_TYPE_CAPITALIZATION = 1,
    UDISPCTX_TYPE_DISPLAY_LENGTH = 2,
    UDISPCTX_TYPE_SUBSTITUTE_HANDLING = 3,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDisplayContext {
    UDISPCTX_STANDARD_NAMES = 0,
    UDISPCTX_DIALECT_NAMES = 1,
    UDISPCTX_CAPITALIZATION_NONE = 256,
    UDISPCTX_CAPITALIZATION_FOR_MIDDLE_OF_SENTENCE = 257,
    UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE = 258,
    UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU = 259,
    UDISPCTX_CAPITALIZATION_FOR_STANDALONE = 260,
    UDISPCTX_LENGTH_FULL = 512,
    UDISPCTX_LENGTH_SHORT = 513,
    UDISPCTX_SUBSTITUTE = 768,
    UDISPCTX_NO_SUBSTITUTE = 769,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UFieldPositionIterator {
    _unused: [u8; 0],
}
pub type UNumberFormat = *mut ::std::os::raw::c_void;
pub type UDateFormat = *mut ::std::os::raw::c_void;
impl UDateFormatStyle {
    pub const UDAT_DEFAULT: UDateFormatStyle = UDateFormatStyle::UDAT_MEDIUM;
}
impl UDateFormatStyle {
    pub const UDAT_FULL_RELATIVE: UDateFormatStyle = UDateFormatStyle::UDAT_RELATIVE;
}
impl UDateFormatStyle {
    pub const UDAT_IGNORE: UDateFormatStyle = UDateFormatStyle::UDAT_PATTERN;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDateFormatStyle {
    UDAT_FULL = 0,
    UDAT_LONG = 1,
    UDAT_MEDIUM = 2,
    UDAT_SHORT = 3,
    UDAT_RELATIVE = 128,
    UDAT_LONG_RELATIVE = 129,
    UDAT_MEDIUM_RELATIVE = 130,
    UDAT_SHORT_RELATIVE = 131,
    UDAT_NONE = -1,
    UDAT_PATTERN = -2,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDateFormatField {
    UDAT_ERA_FIELD = 0,
    UDAT_YEAR_FIELD = 1,
    UDAT_MONTH_FIELD = 2,
    UDAT_DATE_FIELD = 3,
    UDAT_HOUR_OF_DAY1_FIELD = 4,
    UDAT_HOUR_OF_DAY0_FIELD = 5,
    UDAT_MINUTE_FIELD = 6,
    UDAT_SECOND_FIELD = 7,
    UDAT_FRACTIONAL_SECOND_FIELD = 8,
    UDAT_DAY_OF_WEEK_FIELD = 9,
    UDAT_DAY_OF_YEAR_FIELD = 10,
    UDAT_DAY_OF_WEEK_IN_MONTH_FIELD = 11,
    UDAT_WEEK_OF_YEAR_FIELD = 12,
    UDAT_WEEK_OF_MONTH_FIELD = 13,
    UDAT_AM_PM_FIELD = 14,
    UDAT_HOUR1_FIELD = 15,
    UDAT_HOUR0_FIELD = 16,
    UDAT_TIMEZONE_FIELD = 17,
    UDAT_YEAR_WOY_FIELD = 18,
    UDAT_DOW_LOCAL_FIELD = 19,
    UDAT_EXTENDED_YEAR_FIELD = 20,
    UDAT_JULIAN_DAY_FIELD = 21,
    UDAT_MILLISECONDS_IN_DAY_FIELD = 22,
    UDAT_TIMEZONE_RFC_FIELD = 23,
    UDAT_TIMEZONE_GENERIC_FIELD = 24,
    UDAT_STANDALONE_DAY_FIELD = 25,
    UDAT_STANDALONE_MONTH_FIELD = 26,
    UDAT_QUARTER_FIELD = 27,
    UDAT_STANDALONE_QUARTER_FIELD = 28,
    UDAT_TIMEZONE_SPECIAL_FIELD = 29,
    UDAT_YEAR_NAME_FIELD = 30,
    UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD = 31,
    UDAT_TIMEZONE_ISO_FIELD = 32,
    UDAT_TIMEZONE_ISO_LOCAL_FIELD = 33,
    UDAT_RELATED_YEAR_FIELD = 34,
    UDAT_AM_PM_MIDNIGHT_NOON_FIELD = 35,
    UDAT_FLEXIBLE_DAY_PERIOD_FIELD = 36,
    UDAT_TIME_SEPARATOR_FIELD = 37,
    UDAT_FIELD_COUNT = 38,
}
extern "C" {
    pub fn udat_toCalendarDateField_64(field: UDateFormatField) -> UCalendarDateFields;
}
extern "C" {
    pub fn udat_open_64(
        timeStyle: UDateFormatStyle,
        dateStyle: UDateFormatStyle,
        locale: *const ::std::os::raw::c_char,
        tzID: *const UChar,
        tzIDLength: i32,
        pattern: *const UChar,
        patternLength: i32,
        status: *mut UErrorCode,
    ) -> *mut UDateFormat;
}
extern "C" {
    pub fn udat_close_64(format: *mut UDateFormat);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDateFormatBooleanAttribute {
    UDAT_PARSE_ALLOW_WHITESPACE = 0,
    UDAT_PARSE_ALLOW_NUMERIC = 1,
    UDAT_PARSE_PARTIAL_LITERAL_MATCH = 2,
    UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH = 3,
    UDAT_BOOLEAN_ATTRIBUTE_COUNT = 4,
}
extern "C" {
    pub fn udat_getBooleanAttribute_64(
        fmt: *const UDateFormat,
        attr: UDateFormatBooleanAttribute,
        status: *mut UErrorCode,
    ) -> UBool;
}
extern "C" {
    pub fn udat_setBooleanAttribute_64(
        fmt: *mut UDateFormat,
        attr: UDateFormatBooleanAttribute,
        newValue: UBool,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_clone_64(fmt: *const UDateFormat, status: *mut UErrorCode) -> *mut UDateFormat;
}
extern "C" {
    pub fn udat_format_64(
        format: *const UDateFormat,
        dateToFormat: UDate,
        result: *mut UChar,
        resultLength: i32,
        position: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_formatCalendar_64(
        format: *const UDateFormat,
        calendar: *mut UCalendar,
        result: *mut UChar,
        capacity: i32,
        position: *mut UFieldPosition,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_formatForFields_64(
        format: *const UDateFormat,
        dateToFormat: UDate,
        result: *mut UChar,
        resultLength: i32,
        fpositer: *mut UFieldPositionIterator,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_formatCalendarForFields_64(
        format: *const UDateFormat,
        calendar: *mut UCalendar,
        result: *mut UChar,
        capacity: i32,
        fpositer: *mut UFieldPositionIterator,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_parse_64(
        format: *const UDateFormat,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        status: *mut UErrorCode,
    ) -> UDate;
}
extern "C" {
    pub fn udat_parseCalendar_64(
        format: *const UDateFormat,
        calendar: *mut UCalendar,
        text: *const UChar,
        textLength: i32,
        parsePos: *mut i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_isLenient_64(fmt: *const UDateFormat) -> UBool;
}
extern "C" {
    pub fn udat_setLenient_64(fmt: *mut UDateFormat, isLenient: UBool);
}
extern "C" {
    pub fn udat_getCalendar_64(fmt: *const UDateFormat) -> *const UCalendar;
}
extern "C" {
    pub fn udat_setCalendar_64(fmt: *mut UDateFormat, calendarToSet: *const UCalendar);
}
extern "C" {
    pub fn udat_getNumberFormat_64(fmt: *const UDateFormat) -> *const UNumberFormat;
}
extern "C" {
    pub fn udat_getNumberFormatForField_64(
        fmt: *const UDateFormat,
        field: UChar,
    ) -> *const UNumberFormat;
}
extern "C" {
    pub fn udat_adoptNumberFormatForFields_64(
        fmt: *mut UDateFormat,
        fields: *const UChar,
        numberFormatToSet: *mut UNumberFormat,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_setNumberFormat_64(fmt: *mut UDateFormat, numberFormatToSet: *const UNumberFormat);
}
extern "C" {
    pub fn udat_adoptNumberFormat_64(
        fmt: *mut UDateFormat,
        numberFormatToAdopt: *mut UNumberFormat,
    );
}
extern "C" {
    pub fn udat_getAvailable_64(localeIndex: i32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udat_countAvailable_64() -> i32;
}
extern "C" {
    pub fn udat_get2DigitYearStart_64(fmt: *const UDateFormat, status: *mut UErrorCode) -> UDate;
}
extern "C" {
    pub fn udat_set2DigitYearStart_64(fmt: *mut UDateFormat, d: UDate, status: *mut UErrorCode);
}
extern "C" {
    pub fn udat_toPattern_64(
        fmt: *const UDateFormat,
        localized: UBool,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_applyPattern_64(
        format: *mut UDateFormat,
        localized: UBool,
        pattern: *const UChar,
        patternLength: i32,
    );
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDateFormatSymbolType {
    UDAT_ERAS = 0,
    UDAT_MONTHS = 1,
    UDAT_SHORT_MONTHS = 2,
    UDAT_WEEKDAYS = 3,
    UDAT_SHORT_WEEKDAYS = 4,
    UDAT_AM_PMS = 5,
    UDAT_LOCALIZED_CHARS = 6,
    UDAT_ERA_NAMES = 7,
    UDAT_NARROW_MONTHS = 8,
    UDAT_NARROW_WEEKDAYS = 9,
    UDAT_STANDALONE_MONTHS = 10,
    UDAT_STANDALONE_SHORT_MONTHS = 11,
    UDAT_STANDALONE_NARROW_MONTHS = 12,
    UDAT_STANDALONE_WEEKDAYS = 13,
    UDAT_STANDALONE_SHORT_WEEKDAYS = 14,
    UDAT_STANDALONE_NARROW_WEEKDAYS = 15,
    UDAT_QUARTERS = 16,
    UDAT_SHORT_QUARTERS = 17,
    UDAT_STANDALONE_QUARTERS = 18,
    UDAT_STANDALONE_SHORT_QUARTERS = 19,
    UDAT_SHORTER_WEEKDAYS = 20,
    UDAT_STANDALONE_SHORTER_WEEKDAYS = 21,
    UDAT_CYCLIC_YEARS_WIDE = 22,
    UDAT_CYCLIC_YEARS_ABBREVIATED = 23,
    UDAT_CYCLIC_YEARS_NARROW = 24,
    UDAT_ZODIAC_NAMES_WIDE = 25,
    UDAT_ZODIAC_NAMES_ABBREVIATED = 26,
    UDAT_ZODIAC_NAMES_NARROW = 27,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UDateFormatSymbols {
    _unused: [u8; 0],
}
extern "C" {
    pub fn udat_getSymbols_64(
        fmt: *const UDateFormat,
        type_: UDateFormatSymbolType,
        symbolIndex: i32,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_countSymbols_64(fmt: *const UDateFormat, type_: UDateFormatSymbolType) -> i32;
}
extern "C" {
    pub fn udat_setSymbols_64(
        format: *mut UDateFormat,
        type_: UDateFormatSymbolType,
        symbolIndex: i32,
        value: *mut UChar,
        valueLength: i32,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_getLocaleByType_64(
        fmt: *const UDateFormat,
        type_: ULocDataLocaleType,
        status: *mut UErrorCode,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn udat_setContext_64(
        fmt: *mut UDateFormat,
        value: UDisplayContext,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn udat_getContext_64(
        fmt: *const UDateFormat,
        type_: UDisplayContextType,
        status: *mut UErrorCode,
    ) -> UDisplayContext;
}
extern "C" {
    pub fn udat_toPatternRelativeDate_64(
        fmt: *const UDateFormat,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_toPatternRelativeTime_64(
        fmt: *const UDateFormat,
        result: *mut UChar,
        resultLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn udat_applyPatternRelative_64(
        format: *mut UDateFormat,
        datePattern: *const UChar,
        datePatternLength: i32,
        timePattern: *const UChar,
        timePatternLength: i32,
        status: *mut UErrorCode,
    );
}
pub type UDateFormatOpener = ::std::option::Option<
    unsafe extern "C" fn(
        timeStyle: UDateFormatStyle,
        dateStyle: UDateFormatStyle,
        locale: *const ::std::os::raw::c_char,
        tzID: *const UChar,
        tzIDLength: i32,
        pattern: *const UChar,
        patternLength: i32,
        status: *mut UErrorCode,
    ) -> *mut UDateFormat,
>;
extern "C" {
    pub fn udat_registerOpener_64(opener: UDateFormatOpener, status: *mut UErrorCode);
}
extern "C" {
    pub fn udat_unregisterOpener_64(
        opener: UDateFormatOpener,
        status: *mut UErrorCode,
    ) -> UDateFormatOpener;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UDataInfo {
    pub size: u16,
    pub reservedWord: u16,
    pub isBigEndian: u8,
    pub charsetFamily: u8,
    pub sizeofUChar: u8,
    pub reservedByte: u8,
    pub dataFormat: [u8; 4usize],
    pub formatVersion: [u8; 4usize],
    pub dataVersion: [u8; 4usize],
}
#[test]
fn bindgen_test_layout_UDataInfo() {
    assert_eq!(
        ::std::mem::size_of::<UDataInfo>(),
        20usize,
        concat!("Size of: ", stringify!(UDataInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<UDataInfo>(),
        2usize,
        concat!("Alignment of ", stringify!(UDataInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).size as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(UDataInfo), "::", stringify!(size))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).reservedWord as *const _ as usize },
        2usize,
        concat!("Offset of field: ", stringify!(UDataInfo), "::", stringify!(reservedWord))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).isBigEndian as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(UDataInfo), "::", stringify!(isBigEndian))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).charsetFamily as *const _ as usize },
        5usize,
        concat!("Offset of field: ", stringify!(UDataInfo), "::", stringify!(charsetFamily))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).sizeofUChar as *const _ as usize },
        6usize,
        concat!("Offset of field: ", stringify!(UDataInfo), "::", stringify!(sizeofUChar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).reservedByte as *const _ as usize },
        7usize,
        concat!("Offset of field: ", stringify!(UDataInfo), "::", stringify!(reservedByte))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).dataFormat as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(UDataInfo), "::", stringify!(dataFormat))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).formatVersion as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(UDataInfo), "::", stringify!(formatVersion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UDataInfo>())).dataVersion as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(UDataInfo), "::", stringify!(dataVersion))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UDataMemory {
    _unused: [u8; 0],
}
pub type UDataMemoryIsAcceptable = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        type_: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        pInfo: *const UDataInfo,
    ) -> UBool,
>;
extern "C" {
    pub fn udata_open_64(
        path: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UDataMemory;
}
extern "C" {
    pub fn udata_openChoice_64(
        path: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        isAcceptable: UDataMemoryIsAcceptable,
        context: *mut ::std::os::raw::c_void,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UDataMemory;
}
extern "C" {
    pub fn udata_close_64(pData: *mut UDataMemory);
}
extern "C" {
    pub fn udata_getMemory_64(pData: *mut UDataMemory) -> *const ::std::os::raw::c_void;
}
extern "C" {
    pub fn udata_getInfo_64(pData: *mut UDataMemory, pInfo: *mut UDataInfo);
}
extern "C" {
    pub fn udata_setCommonData_64(data: *const ::std::os::raw::c_void, err: *mut UErrorCode);
}
extern "C" {
    pub fn udata_setAppData_64(
        packageName: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        err: *mut UErrorCode,
    );
}
impl UDataFileAccess {
    pub const UDATA_DEFAULT_ACCESS: UDataFileAccess = UDataFileAccess::UDATA_FILES_FIRST;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UDataFileAccess {
    UDATA_FILES_FIRST = 0,
    UDATA_ONLY_PACKAGES = 1,
    UDATA_PACKAGES_FIRST = 2,
    UDATA_NO_FILES = 3,
    UDATA_FILE_ACCESS_COUNT = 4,
}
extern "C" {
    pub fn udata_setFileAccess_64(access: UDataFileAccess, status: *mut UErrorCode);
}
extern "C" {
    pub fn u_getDataDirectory_64() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_setDataDirectory_64(directory: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn u_getTimeZoneFilesDirectory_64(status: *mut UErrorCode)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_setTimeZoneFilesDirectory_64(
        path: *const ::std::os::raw::c_char,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn u_charsToUChars_64(cs: *const ::std::os::raw::c_char, us: *mut UChar, length: i32);
}
extern "C" {
    pub fn u_UCharsToChars_64(us: *const UChar, cs: *mut ::std::os::raw::c_char, length: i32);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCharIteratorOrigin {
    UITER_START = 0,
    UITER_CURRENT = 1,
    UITER_LIMIT = 2,
    UITER_ZERO = 3,
    UITER_LENGTH = 4,
}
pub type UCharIteratorGetIndex = ::std::option::Option<
    unsafe extern "C" fn(iter: *mut UCharIterator, origin: UCharIteratorOrigin) -> i32,
>;
pub type UCharIteratorMove = ::std::option::Option<
    unsafe extern "C" fn(iter: *mut UCharIterator, delta: i32, origin: UCharIteratorOrigin) -> i32,
>;
pub type UCharIteratorHasNext =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UBool>;
pub type UCharIteratorHasPrevious =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UBool>;
pub type UCharIteratorCurrent =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UChar32>;
pub type UCharIteratorNext =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UChar32>;
pub type UCharIteratorPrevious =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator) -> UChar32>;
pub type UCharIteratorReserved =
    ::std::option::Option<unsafe extern "C" fn(iter: *mut UCharIterator, something: i32) -> i32>;
pub type UCharIteratorGetState =
    ::std::option::Option<unsafe extern "C" fn(iter: *const UCharIterator) -> u32>;
pub type UCharIteratorSetState = ::std::option::Option<
    unsafe extern "C" fn(iter: *mut UCharIterator, state: u32, pErrorCode: *mut UErrorCode),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UCharIterator {
    pub context: *const ::std::os::raw::c_void,
    pub length: i32,
    pub start: i32,
    pub index: i32,
    pub limit: i32,
    pub reservedField: i32,
    pub getIndex: UCharIteratorGetIndex,
    pub move_: UCharIteratorMove,
    pub hasNext: UCharIteratorHasNext,
    pub hasPrevious: UCharIteratorHasPrevious,
    pub current: UCharIteratorCurrent,
    pub next: UCharIteratorNext,
    pub previous: UCharIteratorPrevious,
    pub reservedFn: UCharIteratorReserved,
    pub getState: UCharIteratorGetState,
    pub setState: UCharIteratorSetState,
}
#[test]
fn bindgen_test_layout_UCharIterator() {
    assert_eq!(
        ::std::mem::size_of::<UCharIterator>(),
        112usize,
        concat!("Size of: ", stringify!(UCharIterator))
    );
    assert_eq!(
        ::std::mem::align_of::<UCharIterator>(),
        8usize,
        concat!("Alignment of ", stringify!(UCharIterator))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).context as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(UCharIterator), "::", stringify!(context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).length as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(UCharIterator), "::", stringify!(length))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).start as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(UCharIterator), "::", stringify!(start))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).index as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(UCharIterator), "::", stringify!(index))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).limit as *const _ as usize },
        20usize,
        concat!("Offset of field: ", stringify!(UCharIterator), "::", stringify!(limit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).reservedField as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(UCharIterator), "::", stringify!(reservedField))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).getIndex as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(UCharIterator), "::", stringify!(getIndex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).move_ as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(UCharIterator), "::", stringify!(move_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).hasNext as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(UCharIterator), "::", stringify!(hasNext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).hasPrevious as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(UCharIterator), "::", stringify!(hasPrevious))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).current as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(UCharIterator), "::", stringify!(current))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).next as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(UCharIterator), "::", stringify!(next))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).previous as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(UCharIterator), "::", stringify!(previous))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).reservedFn as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(UCharIterator), "::", stringify!(reservedFn))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).getState as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(UCharIterator), "::", stringify!(getState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UCharIterator>())).setState as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(UCharIterator), "::", stringify!(setState))
    );
}
impl Default for UCharIterator {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UBreakIterator {
    _unused: [u8; 0],
}
extern "C" {
    pub fn u_strlen_64(s: *const UChar) -> i32;
}
extern "C" {
    pub fn u_countChar32_64(s: *const UChar, length: i32) -> i32;
}
extern "C" {
    pub fn u_strHasMoreChar32Than_64(s: *const UChar, length: i32, number: i32) -> UBool;
}
extern "C" {
    pub fn u_strcat_64(dst: *mut UChar, src: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strncat_64(dst: *mut UChar, src: *const UChar, n: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_strstr_64(s: *const UChar, substring: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strFindFirst_64(
        s: *const UChar,
        length: i32,
        substring: *const UChar,
        subLength: i32,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strchr_64(s: *const UChar, c: UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strchr32_64(s: *const UChar, c: UChar32) -> *mut UChar;
}
extern "C" {
    pub fn u_strrstr_64(s: *const UChar, substring: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strFindLast_64(
        s: *const UChar,
        length: i32,
        substring: *const UChar,
        subLength: i32,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strrchr_64(s: *const UChar, c: UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strrchr32_64(s: *const UChar, c: UChar32) -> *mut UChar;
}
extern "C" {
    pub fn u_strpbrk_64(string: *const UChar, matchSet: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strcspn_64(string: *const UChar, matchSet: *const UChar) -> i32;
}
extern "C" {
    pub fn u_strspn_64(string: *const UChar, matchSet: *const UChar) -> i32;
}
extern "C" {
    pub fn u_strtok_r_64(
        src: *mut UChar,
        delim: *const UChar,
        saveState: *mut *mut UChar,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strcmp_64(s1: *const UChar, s2: *const UChar) -> i32;
}
extern "C" {
    pub fn u_strcmpCodePointOrder_64(s1: *const UChar, s2: *const UChar) -> i32;
}
extern "C" {
    pub fn u_strCompare_64(
        s1: *const UChar,
        length1: i32,
        s2: *const UChar,
        length2: i32,
        codePointOrder: UBool,
    ) -> i32;
}
extern "C" {
    pub fn u_strCompareIter_64(
        iter1: *mut UCharIterator,
        iter2: *mut UCharIterator,
        codePointOrder: UBool,
    ) -> i32;
}
extern "C" {
    pub fn u_strCaseCompare_64(
        s1: *const UChar,
        length1: i32,
        s2: *const UChar,
        length2: i32,
        options: u32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strncmp_64(ucs1: *const UChar, ucs2: *const UChar, n: i32) -> i32;
}
extern "C" {
    pub fn u_strncmpCodePointOrder_64(s1: *const UChar, s2: *const UChar, n: i32) -> i32;
}
extern "C" {
    pub fn u_strcasecmp_64(s1: *const UChar, s2: *const UChar, options: u32) -> i32;
}
extern "C" {
    pub fn u_strncasecmp_64(s1: *const UChar, s2: *const UChar, n: i32, options: u32) -> i32;
}
extern "C" {
    pub fn u_memcasecmp_64(s1: *const UChar, s2: *const UChar, length: i32, options: u32) -> i32;
}
extern "C" {
    pub fn u_strcpy_64(dst: *mut UChar, src: *const UChar) -> *mut UChar;
}
extern "C" {
    pub fn u_strncpy_64(dst: *mut UChar, src: *const UChar, n: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_uastrcpy_64(dst: *mut UChar, src: *const ::std::os::raw::c_char) -> *mut UChar;
}
extern "C" {
    pub fn u_uastrncpy_64(
        dst: *mut UChar,
        src: *const ::std::os::raw::c_char,
        n: i32,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_austrcpy_64(
        dst: *mut ::std::os::raw::c_char,
        src: *const UChar,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_austrncpy_64(
        dst: *mut ::std::os::raw::c_char,
        src: *const UChar,
        n: i32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_memcpy_64(dest: *mut UChar, src: *const UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memmove_64(dest: *mut UChar, src: *const UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memset_64(dest: *mut UChar, c: UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memcmp_64(buf1: *const UChar, buf2: *const UChar, count: i32) -> i32;
}
extern "C" {
    pub fn u_memcmpCodePointOrder_64(s1: *const UChar, s2: *const UChar, count: i32) -> i32;
}
extern "C" {
    pub fn u_memchr_64(s: *const UChar, c: UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memchr32_64(s: *const UChar, c: UChar32, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memrchr_64(s: *const UChar, c: UChar, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_memrchr32_64(s: *const UChar, c: UChar32, count: i32) -> *mut UChar;
}
extern "C" {
    pub fn u_unescape_64(
        src: *const ::std::os::raw::c_char,
        dest: *mut UChar,
        destCapacity: i32,
    ) -> i32;
}
pub type UNESCAPE_CHAR_AT = ::std::option::Option<
    unsafe extern "C" fn(offset: i32, context: *mut ::std::os::raw::c_void) -> UChar,
>;
extern "C" {
    pub fn u_unescapeAt_64(
        charAt: UNESCAPE_CHAR_AT,
        offset: *mut i32,
        length: i32,
        context: *mut ::std::os::raw::c_void,
    ) -> UChar32;
}
extern "C" {
    pub fn u_strToUpper_64(
        dest: *mut UChar,
        destCapacity: i32,
        src: *const UChar,
        srcLength: i32,
        locale: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strToLower_64(
        dest: *mut UChar,
        destCapacity: i32,
        src: *const UChar,
        srcLength: i32,
        locale: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strToTitle_64(
        dest: *mut UChar,
        destCapacity: i32,
        src: *const UChar,
        srcLength: i32,
        titleIter: *mut UBreakIterator,
        locale: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strFoldCase_64(
        dest: *mut UChar,
        destCapacity: i32,
        src: *const UChar,
        srcLength: i32,
        options: u32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_strToWCS_64(
        dest: *mut wchar_t,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn u_strFromWCS_64(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const wchar_t,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToUTF8_64(
        dest: *mut ::std::os::raw::c_char,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_strFromUTF8_64(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const ::std::os::raw::c_char,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToUTF8WithSub_64(
        dest: *mut ::std::os::raw::c_char,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_strFromUTF8WithSub_64(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const ::std::os::raw::c_char,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strFromUTF8Lenient_64(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const ::std::os::raw::c_char,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToUTF32_64(
        dest: *mut UChar32,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar32;
}
extern "C" {
    pub fn u_strFromUTF32_64(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar32,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToUTF32WithSub_64(
        dest: *mut UChar32,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar32;
}
extern "C" {
    pub fn u_strFromUTF32WithSub_64(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar32,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
extern "C" {
    pub fn u_strToJavaModifiedUTF8_64(
        dest: *mut ::std::os::raw::c_char,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const UChar,
        srcLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_strFromJavaModifiedUTF8WithSub_64(
        dest: *mut UChar,
        destCapacity: i32,
        pDestLength: *mut i32,
        src: *const ::std::os::raw::c_char,
        srcLength: i32,
        subchar: UChar32,
        pNumSubstitutions: *mut i32,
        pErrorCode: *mut UErrorCode,
    ) -> *mut UChar;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UCPMap {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USet {
    _unused: [u8; 0],
}
impl UProperty {
    pub const UCHAR_BINARY_START: UProperty = UProperty::UCHAR_ALPHABETIC;
}
impl UProperty {
    pub const UCHAR_INT_START: UProperty = UProperty::UCHAR_BIDI_CLASS;
}
impl UProperty {
    pub const UCHAR_MASK_START: UProperty = UProperty::UCHAR_GENERAL_CATEGORY_MASK;
}
impl UProperty {
    pub const UCHAR_DOUBLE_START: UProperty = UProperty::UCHAR_NUMERIC_VALUE;
}
impl UProperty {
    pub const UCHAR_STRING_START: UProperty = UProperty::UCHAR_AGE;
}
impl UProperty {
    pub const UCHAR_OTHER_PROPERTY_START: UProperty = UProperty::UCHAR_SCRIPT_EXTENSIONS;
}
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UProperty {
    UCHAR_ALPHABETIC = 0,
    UCHAR_ASCII_HEX_DIGIT = 1,
    UCHAR_BIDI_CONTROL = 2,
    UCHAR_BIDI_MIRRORED = 3,
    UCHAR_DASH = 4,
    UCHAR_DEFAULT_IGNORABLE_CODE_POINT = 5,
    UCHAR_DEPRECATED = 6,
    UCHAR_DIACRITIC = 7,
    UCHAR_EXTENDER = 8,
    UCHAR_FULL_COMPOSITION_EXCLUSION = 9,
    UCHAR_GRAPHEME_BASE = 10,
    UCHAR_GRAPHEME_EXTEND = 11,
    UCHAR_GRAPHEME_LINK = 12,
    UCHAR_HEX_DIGIT = 13,
    UCHAR_HYPHEN = 14,
    UCHAR_ID_CONTINUE = 15,
    UCHAR_ID_START = 16,
    UCHAR_IDEOGRAPHIC = 17,
    UCHAR_IDS_BINARY_OPERATOR = 18,
    UCHAR_IDS_TRINARY_OPERATOR = 19,
    UCHAR_JOIN_CONTROL = 20,
    UCHAR_LOGICAL_ORDER_EXCEPTION = 21,
    UCHAR_LOWERCASE = 22,
    UCHAR_MATH = 23,
    UCHAR_NONCHARACTER_CODE_POINT = 24,
    UCHAR_QUOTATION_MARK = 25,
    UCHAR_RADICAL = 26,
    UCHAR_SOFT_DOTTED = 27,
    UCHAR_TERMINAL_PUNCTUATION = 28,
    UCHAR_UNIFIED_IDEOGRAPH = 29,
    UCHAR_UPPERCASE = 30,
    UCHAR_WHITE_SPACE = 31,
    UCHAR_XID_CONTINUE = 32,
    UCHAR_XID_START = 33,
    UCHAR_CASE_SENSITIVE = 34,
    UCHAR_S_TERM = 35,
    UCHAR_VARIATION_SELECTOR = 36,
    UCHAR_NFD_INERT = 37,
    UCHAR_NFKD_INERT = 38,
    UCHAR_NFC_INERT = 39,
    UCHAR_NFKC_INERT = 40,
    UCHAR_SEGMENT_STARTER = 41,
    UCHAR_PATTERN_SYNTAX = 42,
    UCHAR_PATTERN_WHITE_SPACE = 43,
    UCHAR_POSIX_ALNUM = 44,
    UCHAR_POSIX_BLANK = 45,
    UCHAR_POSIX_GRAPH = 46,
    UCHAR_POSIX_PRINT = 47,
    UCHAR_POSIX_XDIGIT = 48,
    UCHAR_CASED = 49,
    UCHAR_CASE_IGNORABLE = 50,
    UCHAR_CHANGES_WHEN_LOWERCASED = 51,
    UCHAR_CHANGES_WHEN_UPPERCASED = 52,
    UCHAR_CHANGES_WHEN_TITLECASED = 53,
    UCHAR_CHANGES_WHEN_CASEFOLDED = 54,
    UCHAR_CHANGES_WHEN_CASEMAPPED = 55,
    UCHAR_CHANGES_WHEN_NFKC_CASEFOLDED = 56,
    UCHAR_EMOJI = 57,
    UCHAR_EMOJI_PRESENTATION = 58,
    UCHAR_EMOJI_MODIFIER = 59,
    UCHAR_EMOJI_MODIFIER_BASE = 60,
    UCHAR_EMOJI_COMPONENT = 61,
    UCHAR_REGIONAL_INDICATOR = 62,
    UCHAR_PREPENDED_CONCATENATION_MARK = 63,
    UCHAR_EXTENDED_PICTOGRAPHIC = 64,
    UCHAR_BINARY_LIMIT = 65,
    UCHAR_BIDI_CLASS = 4096,
    UCHAR_BLOCK = 4097,
    UCHAR_CANONICAL_COMBINING_CLASS = 4098,
    UCHAR_DECOMPOSITION_TYPE = 4099,
    UCHAR_EAST_ASIAN_WIDTH = 4100,
    UCHAR_GENERAL_CATEGORY = 4101,
    UCHAR_JOINING_GROUP = 4102,
    UCHAR_JOINING_TYPE = 4103,
    UCHAR_LINE_BREAK = 4104,
    UCHAR_NUMERIC_TYPE = 4105,
    UCHAR_SCRIPT = 4106,
    UCHAR_HANGUL_SYLLABLE_TYPE = 4107,
    UCHAR_NFD_QUICK_CHECK = 4108,
    UCHAR_NFKD_QUICK_CHECK = 4109,
    UCHAR_NFC_QUICK_CHECK = 4110,
    UCHAR_NFKC_QUICK_CHECK = 4111,
    UCHAR_LEAD_CANONICAL_COMBINING_CLASS = 4112,
    UCHAR_TRAIL_CANONICAL_COMBINING_CLASS = 4113,
    UCHAR_GRAPHEME_CLUSTER_BREAK = 4114,
    UCHAR_SENTENCE_BREAK = 4115,
    UCHAR_WORD_BREAK = 4116,
    UCHAR_BIDI_PAIRED_BRACKET_TYPE = 4117,
    UCHAR_INDIC_POSITIONAL_CATEGORY = 4118,
    UCHAR_INDIC_SYLLABIC_CATEGORY = 4119,
    UCHAR_VERTICAL_ORIENTATION = 4120,
    UCHAR_INT_LIMIT = 4121,
    UCHAR_GENERAL_CATEGORY_MASK = 8192,
    UCHAR_MASK_LIMIT = 8193,
    UCHAR_NUMERIC_VALUE = 12288,
    UCHAR_DOUBLE_LIMIT = 12289,
    UCHAR_AGE = 16384,
    UCHAR_BIDI_MIRRORING_GLYPH = 16385,
    UCHAR_CASE_FOLDING = 16386,
    UCHAR_ISO_COMMENT = 16387,
    UCHAR_LOWERCASE_MAPPING = 16388,
    UCHAR_NAME = 16389,
    UCHAR_SIMPLE_CASE_FOLDING = 16390,
    UCHAR_SIMPLE_LOWERCASE_MAPPING = 16391,
    UCHAR_SIMPLE_TITLECASE_MAPPING = 16392,
    UCHAR_SIMPLE_UPPERCASE_MAPPING = 16393,
    UCHAR_TITLECASE_MAPPING = 16394,
    UCHAR_UNICODE_1_NAME = 16395,
    UCHAR_UPPERCASE_MAPPING = 16396,
    UCHAR_BIDI_PAIRED_BRACKET = 16397,
    UCHAR_STRING_LIMIT = 16398,
    UCHAR_SCRIPT_EXTENSIONS = 28672,
    UCHAR_OTHER_PROPERTY_LIMIT = 28673,
    UCHAR_INVALID_CODE = -1,
}
impl UCharCategory {
    pub const U_GENERAL_OTHER_TYPES: UCharCategory = UCharCategory::U_UNASSIGNED;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCharCategory {
    U_UNASSIGNED = 0,
    U_UPPERCASE_LETTER = 1,
    U_LOWERCASE_LETTER = 2,
    U_TITLECASE_LETTER = 3,
    U_MODIFIER_LETTER = 4,
    U_OTHER_LETTER = 5,
    U_NON_SPACING_MARK = 6,
    U_ENCLOSING_MARK = 7,
    U_COMBINING_SPACING_MARK = 8,
    U_DECIMAL_DIGIT_NUMBER = 9,
    U_LETTER_NUMBER = 10,
    U_OTHER_NUMBER = 11,
    U_SPACE_SEPARATOR = 12,
    U_LINE_SEPARATOR = 13,
    U_PARAGRAPH_SEPARATOR = 14,
    U_CONTROL_CHAR = 15,
    U_FORMAT_CHAR = 16,
    U_PRIVATE_USE_CHAR = 17,
    U_SURROGATE = 18,
    U_DASH_PUNCTUATION = 19,
    U_START_PUNCTUATION = 20,
    U_END_PUNCTUATION = 21,
    U_CONNECTOR_PUNCTUATION = 22,
    U_OTHER_PUNCTUATION = 23,
    U_MATH_SYMBOL = 24,
    U_CURRENCY_SYMBOL = 25,
    U_MODIFIER_SYMBOL = 26,
    U_OTHER_SYMBOL = 27,
    U_INITIAL_PUNCTUATION = 28,
    U_FINAL_PUNCTUATION = 29,
    U_CHAR_CATEGORY_COUNT = 30,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCharDirection {
    U_LEFT_TO_RIGHT = 0,
    U_RIGHT_TO_LEFT = 1,
    U_EUROPEAN_NUMBER = 2,
    U_EUROPEAN_NUMBER_SEPARATOR = 3,
    U_EUROPEAN_NUMBER_TERMINATOR = 4,
    U_ARABIC_NUMBER = 5,
    U_COMMON_NUMBER_SEPARATOR = 6,
    U_BLOCK_SEPARATOR = 7,
    U_SEGMENT_SEPARATOR = 8,
    U_WHITE_SPACE_NEUTRAL = 9,
    U_OTHER_NEUTRAL = 10,
    U_LEFT_TO_RIGHT_EMBEDDING = 11,
    U_LEFT_TO_RIGHT_OVERRIDE = 12,
    U_RIGHT_TO_LEFT_ARABIC = 13,
    U_RIGHT_TO_LEFT_EMBEDDING = 14,
    U_RIGHT_TO_LEFT_OVERRIDE = 15,
    U_POP_DIRECTIONAL_FORMAT = 16,
    U_DIR_NON_SPACING_MARK = 17,
    U_BOUNDARY_NEUTRAL = 18,
    U_FIRST_STRONG_ISOLATE = 19,
    U_LEFT_TO_RIGHT_ISOLATE = 20,
    U_RIGHT_TO_LEFT_ISOLATE = 21,
    U_POP_DIRECTIONAL_ISOLATE = 22,
    U_CHAR_DIRECTION_COUNT = 23,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UCharNameChoice {
    U_UNICODE_CHAR_NAME = 0,
    U_UNICODE_10_CHAR_NAME = 1,
    U_EXTENDED_CHAR_NAME = 2,
    U_CHAR_NAME_ALIAS = 3,
    U_CHAR_NAME_CHOICE_COUNT = 4,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd)]
pub enum UPropertyNameChoice {
    U_SHORT_PROPERTY_NAME = 0,
    U_LONG_PROPERTY_NAME = 1,
    U_PROPERTY_NAME_CHOICE_COUNT = 2,
}
extern "C" {
    pub fn u_hasBinaryProperty_64(c: UChar32, which: UProperty) -> UBool;
}
extern "C" {
    pub fn u_getBinaryPropertySet_64(
        property: UProperty,
        pErrorCode: *mut UErrorCode,
    ) -> *const USet;
}
extern "C" {
    pub fn u_isUAlphabetic_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isULowercase_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isUUppercase_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isUWhiteSpace_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_getIntPropertyValue_64(c: UChar32, which: UProperty) -> i32;
}
extern "C" {
    pub fn u_getIntPropertyMinValue_64(which: UProperty) -> i32;
}
extern "C" {
    pub fn u_getIntPropertyMaxValue_64(which: UProperty) -> i32;
}
extern "C" {
    pub fn u_getIntPropertyMap_64(
        property: UProperty,
        pErrorCode: *mut UErrorCode,
    ) -> *const UCPMap;
}
extern "C" {
    pub fn u_getNumericValue_64(c: UChar32) -> f64;
}
extern "C" {
    pub fn u_islower_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isupper_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_istitle_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isdigit_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isalpha_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isalnum_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isxdigit_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_ispunct_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isgraph_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isblank_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isdefined_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isspace_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isJavaSpaceChar_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isWhitespace_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_iscntrl_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isISOControl_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isprint_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isbase_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_charDirection_64(c: UChar32) -> UCharDirection;
}
extern "C" {
    pub fn u_isMirrored_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_charMirror_64(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_getBidiPairedBracket_64(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_charType_64(c: UChar32) -> i8;
}
pub type UCharEnumTypeRange = ::std::option::Option<
    unsafe extern "C" fn(
        context: *const ::std::os::raw::c_void,
        start: UChar32,
        limit: UChar32,
        type_: UCharCategory,
    ) -> UBool,
>;
extern "C" {
    pub fn u_enumCharTypes_64(
        enumRange: UCharEnumTypeRange,
        context: *const ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn u_getCombiningClass_64(c: UChar32) -> u8;
}
extern "C" {
    pub fn u_charDigitValue_64(c: UChar32) -> i32;
}
extern "C" {
    pub fn u_charName_64(
        code: UChar32,
        nameChoice: UCharNameChoice,
        buffer: *mut ::std::os::raw::c_char,
        bufferLength: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_getISOComment_64(
        c: UChar32,
        dest: *mut ::std::os::raw::c_char,
        destCapacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn u_charFromName_64(
        nameChoice: UCharNameChoice,
        name: *const ::std::os::raw::c_char,
        pErrorCode: *mut UErrorCode,
    ) -> UChar32;
}
pub type UEnumCharNamesFn = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut ::std::os::raw::c_void,
        code: UChar32,
        nameChoice: UCharNameChoice,
        name: *const ::std::os::raw::c_char,
        length: i32,
    ) -> UBool,
>;
extern "C" {
    pub fn u_enumCharNames_64(
        start: UChar32,
        limit: UChar32,
        fn_: UEnumCharNamesFn,
        context: *mut ::std::os::raw::c_void,
        nameChoice: UCharNameChoice,
        pErrorCode: *mut UErrorCode,
    );
}
extern "C" {
    pub fn u_getPropertyName_64(
        property: UProperty,
        nameChoice: UPropertyNameChoice,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_getPropertyEnum_64(alias: *const ::std::os::raw::c_char) -> UProperty;
}
extern "C" {
    pub fn u_getPropertyValueName_64(
        property: UProperty,
        value: i32,
        nameChoice: UPropertyNameChoice,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn u_getPropertyValueEnum_64(
        property: UProperty,
        alias: *const ::std::os::raw::c_char,
    ) -> i32;
}
extern "C" {
    pub fn u_isIDStart_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isIDPart_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isIDIgnorable_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isJavaIDStart_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_isJavaIDPart_64(c: UChar32) -> UBool;
}
extern "C" {
    pub fn u_tolower_64(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_toupper_64(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_totitle_64(c: UChar32) -> UChar32;
}
extern "C" {
    pub fn u_foldCase_64(c: UChar32, options: u32) -> UChar32;
}
extern "C" {
    pub fn u_digit_64(ch: UChar32, radix: i8) -> i32;
}
extern "C" {
    pub fn u_forDigit_64(digit: i32, radix: i8) -> UChar32;
}
extern "C" {
    pub fn u_charAge_64(c: UChar32, versionArray: *mut u8);
}
extern "C" {
    pub fn u_getUnicodeVersion_64(versionArray: *mut u8);
}
extern "C" {
    pub fn u_getFC_NFKC_Closure_64(
        c: UChar32,
        dest: *mut UChar,
        destCapacity: i32,
        pErrorCode: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn utext_close_64(ut: *mut UText) -> *mut UText;
}
extern "C" {
    pub fn utext_openUTF8_64(
        ut: *mut UText,
        s: *const ::std::os::raw::c_char,
        length: i64,
        status: *mut UErrorCode,
    ) -> *mut UText;
}
extern "C" {
    pub fn utext_openUChars_64(
        ut: *mut UText,
        s: *const UChar,
        length: i64,
        status: *mut UErrorCode,
    ) -> *mut UText;
}
extern "C" {
    pub fn utext_clone_64(
        dest: *mut UText,
        src: *const UText,
        deep: UBool,
        readOnly: UBool,
        status: *mut UErrorCode,
    ) -> *mut UText;
}
extern "C" {
    pub fn utext_equals_64(a: *const UText, b: *const UText) -> UBool;
}
extern "C" {
    pub fn utext_nativeLength_64(ut: *mut UText) -> i64;
}
extern "C" {
    pub fn utext_isLengthExpensive_64(ut: *const UText) -> UBool;
}
extern "C" {
    pub fn utext_char32At_64(ut: *mut UText, nativeIndex: i64) -> UChar32;
}
extern "C" {
    pub fn utext_current32_64(ut: *mut UText) -> UChar32;
}
extern "C" {
    pub fn utext_next32_64(ut: *mut UText) -> UChar32;
}
extern "C" {
    pub fn utext_previous32_64(ut: *mut UText) -> UChar32;
}
extern "C" {
    pub fn utext_next32From_64(ut: *mut UText, nativeIndex: i64) -> UChar32;
}
extern "C" {
    pub fn utext_previous32From_64(ut: *mut UText, nativeIndex: i64) -> UChar32;
}
extern "C" {
    pub fn utext_getNativeIndex_64(ut: *const UText) -> i64;
}
extern "C" {
    pub fn utext_setNativeIndex_64(ut: *mut UText, nativeIndex: i64);
}
extern "C" {
    pub fn utext_moveIndex32_64(ut: *mut UText, delta: i32) -> UBool;
}
extern "C" {
    pub fn utext_getPreviousNativeIndex_64(ut: *mut UText) -> i64;
}
extern "C" {
    pub fn utext_extract_64(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        dest: *mut UChar,
        destCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn utext_isWritable_64(ut: *const UText) -> UBool;
}
extern "C" {
    pub fn utext_hasMetaData_64(ut: *const UText) -> UBool;
}
extern "C" {
    pub fn utext_replace_64(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        replacementText: *const UChar,
        replacementLength: i32,
        status: *mut UErrorCode,
    ) -> i32;
}
extern "C" {
    pub fn utext_copy_64(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        destIndex: i64,
        move_: UBool,
        status: *mut UErrorCode,
    );
}
extern "C" {
    pub fn utext_freeze_64(ut: *mut UText);
}
pub type UTextClone = ::std::option::Option<
    unsafe extern "C" fn(
        dest: *mut UText,
        src: *const UText,
        deep: UBool,
        status: *mut UErrorCode,
    ) -> *mut UText,
>;
pub type UTextNativeLength = ::std::option::Option<unsafe extern "C" fn(ut: *mut UText) -> i64>;
pub type UTextAccess = ::std::option::Option<
    unsafe extern "C" fn(ut: *mut UText, nativeIndex: i64, forward: UBool) -> UBool,
>;
pub type UTextExtract = ::std::option::Option<
    unsafe extern "C" fn(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        dest: *mut UChar,
        destCapacity: i32,
        status: *mut UErrorCode,
    ) -> i32,
>;
pub type UTextReplace = ::std::option::Option<
    unsafe extern "C" fn(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        replacementText: *const UChar,
        replacmentLength: i32,
        status: *mut UErrorCode,
    ) -> i32,
>;
pub type UTextCopy = ::std::option::Option<
    unsafe extern "C" fn(
        ut: *mut UText,
        nativeStart: i64,
        nativeLimit: i64,
        nativeDest: i64,
        move_: UBool,
        status: *mut UErrorCode,
    ),
>;
pub type UTextMapOffsetToNative =
    ::std::option::Option<unsafe extern "C" fn(ut: *const UText) -> i64>;
pub type UTextMapNativeIndexToUTF16 =
    ::std::option::Option<unsafe extern "C" fn(ut: *const UText, nativeIndex: i64) -> i32>;
pub type UTextClose = ::std::option::Option<unsafe extern "C" fn(ut: *mut UText)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UTextFuncs {
    pub tableSize: i32,
    pub reserved1: i32,
    pub reserved2: i32,
    pub reserved3: i32,
    pub clone: UTextClone,
    pub nativeLength: UTextNativeLength,
    pub access: UTextAccess,
    pub extract: UTextExtract,
    pub replace: UTextReplace,
    pub copy: UTextCopy,
    pub mapOffsetToNative: UTextMapOffsetToNative,
    pub mapNativeIndexToUTF16: UTextMapNativeIndexToUTF16,
    pub close: UTextClose,
    pub spare1: UTextClose,
    pub spare2: UTextClose,
    pub spare3: UTextClose,
}
#[test]
fn bindgen_test_layout_UTextFuncs() {
    assert_eq!(
        ::std::mem::size_of::<UTextFuncs>(),
        112usize,
        concat!("Size of: ", stringify!(UTextFuncs))
    );
    assert_eq!(
        ::std::mem::align_of::<UTextFuncs>(),
        8usize,
        concat!("Alignment of ", stringify!(UTextFuncs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).tableSize as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(UTextFuncs), "::", stringify!(tableSize))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).reserved1 as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(UTextFuncs), "::", stringify!(reserved1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).reserved2 as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(UTextFuncs), "::", stringify!(reserved2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).reserved3 as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(UTextFuncs), "::", stringify!(reserved3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).clone as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(UTextFuncs), "::", stringify!(clone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).nativeLength as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(UTextFuncs), "::", stringify!(nativeLength))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).access as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(UTextFuncs), "::", stringify!(access))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).extract as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(UTextFuncs), "::", stringify!(extract))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).replace as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(UTextFuncs), "::", stringify!(replace))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).copy as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(UTextFuncs), "::", stringify!(copy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).mapOffsetToNative as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(UTextFuncs), "::", stringify!(mapOffsetToNative))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<UTextFuncs>())).mapNativeIndexToUTF16 as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(UTextFuncs),
            "::",
            stringify!(mapNativeIndexToUTF16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).close as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(UTextFuncs), "::", stringify!(close))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).spare1 as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(UTextFuncs), "::", stringify!(spare1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).spare2 as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(UTextFuncs), "::", stringify!(spare2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UTextFuncs>())).spare3 as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(UTextFuncs), "::", stringify!(spare3))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, PartialEq)]
pub struct UText {
    pub magic: u32,
    pub flags: i32,
    pub providerProperties: i32,
    pub sizeOfStruct: i32,
    pub chunkNativeLimit: i64,
    pub extraSize: i32,
    pub nativeIndexingLimit: i32,
    pub chunkNativeStart: i64,
    pub chunkOffset: i32,
    pub chunkLength: i32,
    pub chunkContents: *const UChar,
    pub pFuncs: *const UTextFuncs,
    pub pExtra: *mut ::std::os::raw::c_void,
    pub context: *const ::std::os::raw::c_void,
    pub p: *const ::std::os::raw::c_void,
    pub q: *const ::std::os::raw::c_void,
    pub r: *const ::std::os::raw::c_void,
    pub privP: *mut ::std::os::raw::c_void,
    pub a: i64,
    pub b: i32,
    pub c: i32,
    pub privA: i64,
    pub privB: i32,
    pub privC: i32,
}
#[test]
fn bindgen_test_layout_UText() {
    assert_eq!(::std::mem::size_of::<UText>(), 144usize, concat!("Size of: ", stringify!(UText)));
    assert_eq!(
        ::std::mem::align_of::<UText>(),
        8usize,
        concat!("Alignment of ", stringify!(UText))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).magic as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(magic))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).flags as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(flags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).providerProperties as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(providerProperties))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).sizeOfStruct as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(sizeOfStruct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkNativeLimit as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(chunkNativeLimit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).extraSize as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(extraSize))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).nativeIndexingLimit as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(nativeIndexingLimit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkNativeStart as *const _ as usize },
        32usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(chunkNativeStart))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkOffset as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(chunkOffset))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkLength as *const _ as usize },
        44usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(chunkLength))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).chunkContents as *const _ as usize },
        48usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(chunkContents))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).pFuncs as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(pFuncs))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).pExtra as *const _ as usize },
        64usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(pExtra))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).context as *const _ as usize },
        72usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).p as *const _ as usize },
        80usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).q as *const _ as usize },
        88usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(q))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).r as *const _ as usize },
        96usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(r))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).privP as *const _ as usize },
        104usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(privP))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).a as *const _ as usize },
        112usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(a))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).b as *const _ as usize },
        120usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(b))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).c as *const _ as usize },
        124usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(c))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).privA as *const _ as usize },
        128usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(privA))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).privB as *const _ as usize },
        136usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(privB))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<UText>())).privC as *const _ as usize },
        140usize,
        concat!("Offset of field: ", stringify!(UText), "::", stringify!(privC))
    );
}
impl Default for UText {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn utext_setup_64(ut: *mut UText, extraSpace: i32, status: *mut UErrorCode) -> *mut UText;
}
