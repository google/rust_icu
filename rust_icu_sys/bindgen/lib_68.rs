/* automatically generated by rust-bindgen 0.59.1 */

pub type size_t = :: std :: os :: raw :: c_ulong ; pub type wchar_t = :: std :: os :: raw :: c_int ; pub type __int8_t = :: std :: os :: raw :: c_schar ; pub type __uint8_t = :: std :: os :: raw :: c_uchar ; pub type __uint16_t = :: std :: os :: raw :: c_ushort ; pub type __int32_t = :: std :: os :: raw :: c_int ; pub type __uint32_t = :: std :: os :: raw :: c_uint ; pub type __int64_t = :: std :: os :: raw :: c_long ; pub type UBool = i8 ; pub type UChar = u16 ; pub type OldUChar = :: std :: os :: raw :: c_ushort ; pub type UChar32 = i32 ; pub type UVersionInfo = [u8 ; 4usize] ; extern "C" { pub fn u_versionFromString_68 (versionArray : * mut u8 , versionString : * const :: std :: os :: raw :: c_char) ; } extern "C" { pub fn u_versionFromUString_68 (versionArray : * mut u8 , versionString : * const UChar) ; } extern "C" { pub fn u_versionToString_68 (versionArray : * mut u8 , versionString : * mut :: std :: os :: raw :: c_char) ; } extern "C" { pub fn u_getVersion_68 (versionArray : * mut u8) ; } pub type UDate = f64 ; impl UErrorCode { pub const U_ERROR_WARNING_START : UErrorCode = UErrorCode :: U_USING_FALLBACK_WARNING ; } impl UErrorCode { pub const U_PARSE_ERROR_START : UErrorCode = UErrorCode :: U_BAD_VARIABLE_DEFINITION ; } impl UErrorCode { pub const U_FMT_PARSE_ERROR_START : UErrorCode = UErrorCode :: U_UNEXPECTED_TOKEN ; } impl UErrorCode { pub const U_MULTIPLE_DECIMAL_SEPERATORS : UErrorCode = UErrorCode :: U_MULTIPLE_DECIMAL_SEPARATORS ; } impl UErrorCode { pub const U_BRK_ERROR_START : UErrorCode = UErrorCode :: U_BRK_INTERNAL_ERROR ; } impl UErrorCode { pub const U_REGEX_ERROR_START : UErrorCode = UErrorCode :: U_REGEX_INTERNAL_ERROR ; } impl UErrorCode { pub const U_IDNA_ERROR_START : UErrorCode = UErrorCode :: U_IDNA_PROHIBITED_ERROR ; } impl UErrorCode { pub const U_STRINGPREP_PROHIBITED_ERROR : UErrorCode = UErrorCode :: U_IDNA_PROHIBITED_ERROR ; } impl UErrorCode { pub const U_STRINGPREP_UNASSIGNED_ERROR : UErrorCode = UErrorCode :: U_IDNA_UNASSIGNED_ERROR ; } impl UErrorCode { pub const U_STRINGPREP_CHECK_BIDI_ERROR : UErrorCode = UErrorCode :: U_IDNA_CHECK_BIDI_ERROR ; } impl UErrorCode { pub const U_PLUGIN_TOO_HIGH : UErrorCode = UErrorCode :: U_PLUGIN_ERROR_START ; } impl UErrorCode { pub const U_ERROR_LIMIT : UErrorCode = UErrorCode :: U_PLUGIN_ERROR_LIMIT ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UErrorCode { U_USING_FALLBACK_WARNING = - 128 , U_USING_DEFAULT_WARNING = - 127 , U_SAFECLONE_ALLOCATED_WARNING = - 126 , U_STATE_OLD_WARNING = - 125 , U_STRING_NOT_TERMINATED_WARNING = - 124 , U_SORT_KEY_TOO_SHORT_WARNING = - 123 , U_AMBIGUOUS_ALIAS_WARNING = - 122 , U_DIFFERENT_UCA_VERSION = - 121 , U_PLUGIN_CHANGED_LEVEL_WARNING = - 120 , U_ERROR_WARNING_LIMIT = - 119 , U_ZERO_ERROR = 0 , U_ILLEGAL_ARGUMENT_ERROR = 1 , U_MISSING_RESOURCE_ERROR = 2 , U_INVALID_FORMAT_ERROR = 3 , U_FILE_ACCESS_ERROR = 4 , U_INTERNAL_PROGRAM_ERROR = 5 , U_MESSAGE_PARSE_ERROR = 6 , U_MEMORY_ALLOCATION_ERROR = 7 , U_INDEX_OUTOFBOUNDS_ERROR = 8 , U_PARSE_ERROR = 9 , U_INVALID_CHAR_FOUND = 10 , U_TRUNCATED_CHAR_FOUND = 11 , U_ILLEGAL_CHAR_FOUND = 12 , U_INVALID_TABLE_FORMAT = 13 , U_INVALID_TABLE_FILE = 14 , U_BUFFER_OVERFLOW_ERROR = 15 , U_UNSUPPORTED_ERROR = 16 , U_RESOURCE_TYPE_MISMATCH = 17 , U_ILLEGAL_ESCAPE_SEQUENCE = 18 , U_UNSUPPORTED_ESCAPE_SEQUENCE = 19 , U_NO_SPACE_AVAILABLE = 20 , U_CE_NOT_FOUND_ERROR = 21 , U_PRIMARY_TOO_LONG_ERROR = 22 , U_STATE_TOO_OLD_ERROR = 23 , U_TOO_MANY_ALIASES_ERROR = 24 , U_ENUM_OUT_OF_SYNC_ERROR = 25 , U_INVARIANT_CONVERSION_ERROR = 26 , U_INVALID_STATE_ERROR = 27 , U_COLLATOR_VERSION_MISMATCH = 28 , U_USELESS_COLLATOR_ERROR = 29 , U_NO_WRITE_PERMISSION = 30 , U_INPUT_TOO_LONG_ERROR = 31 , U_STANDARD_ERROR_LIMIT = 32 , U_BAD_VARIABLE_DEFINITION = 65536 , U_MALFORMED_RULE = 65537 , U_MALFORMED_SET = 65538 , U_MALFORMED_SYMBOL_REFERENCE = 65539 , U_MALFORMED_UNICODE_ESCAPE = 65540 , U_MALFORMED_VARIABLE_DEFINITION = 65541 , U_MALFORMED_VARIABLE_REFERENCE = 65542 , U_MISMATCHED_SEGMENT_DELIMITERS = 65543 , U_MISPLACED_ANCHOR_START = 65544 , U_MISPLACED_CURSOR_OFFSET = 65545 , U_MISPLACED_QUANTIFIER = 65546 , U_MISSING_OPERATOR = 65547 , U_MISSING_SEGMENT_CLOSE = 65548 , U_MULTIPLE_ANTE_CONTEXTS = 65549 , U_MULTIPLE_CURSORS = 65550 , U_MULTIPLE_POST_CONTEXTS = 65551 , U_TRAILING_BACKSLASH = 65552 , U_UNDEFINED_SEGMENT_REFERENCE = 65553 , U_UNDEFINED_VARIABLE = 65554 , U_UNQUOTED_SPECIAL = 65555 , U_UNTERMINATED_QUOTE = 65556 , U_RULE_MASK_ERROR = 65557 , U_MISPLACED_COMPOUND_FILTER = 65558 , U_MULTIPLE_COMPOUND_FILTERS = 65559 , U_INVALID_RBT_SYNTAX = 65560 , U_INVALID_PROPERTY_PATTERN = 65561 , U_MALFORMED_PRAGMA = 65562 , U_UNCLOSED_SEGMENT = 65563 , U_ILLEGAL_CHAR_IN_SEGMENT = 65564 , U_VARIABLE_RANGE_EXHAUSTED = 65565 , U_VARIABLE_RANGE_OVERLAP = 65566 , U_ILLEGAL_CHARACTER = 65567 , U_INTERNAL_TRANSLITERATOR_ERROR = 65568 , U_INVALID_ID = 65569 , U_INVALID_FUNCTION = 65570 , U_PARSE_ERROR_LIMIT = 65571 , U_UNEXPECTED_TOKEN = 65792 , U_MULTIPLE_DECIMAL_SEPARATORS = 65793 , U_MULTIPLE_EXPONENTIAL_SYMBOLS = 65794 , U_MALFORMED_EXPONENTIAL_PATTERN = 65795 , U_MULTIPLE_PERCENT_SYMBOLS = 65796 , U_MULTIPLE_PERMILL_SYMBOLS = 65797 , U_MULTIPLE_PAD_SPECIFIERS = 65798 , U_PATTERN_SYNTAX_ERROR = 65799 , U_ILLEGAL_PAD_POSITION = 65800 , U_UNMATCHED_BRACES = 65801 , U_UNSUPPORTED_PROPERTY = 65802 , U_UNSUPPORTED_ATTRIBUTE = 65803 , U_ARGUMENT_TYPE_MISMATCH = 65804 , U_DUPLICATE_KEYWORD = 65805 , U_UNDEFINED_KEYWORD = 65806 , U_DEFAULT_KEYWORD_MISSING = 65807 , U_DECIMAL_NUMBER_SYNTAX_ERROR = 65808 , U_FORMAT_INEXACT_ERROR = 65809 , U_NUMBER_ARG_OUTOFBOUNDS_ERROR = 65810 , U_NUMBER_SKELETON_SYNTAX_ERROR = 65811 , U_FMT_PARSE_ERROR_LIMIT = 65812 , U_BRK_INTERNAL_ERROR = 66048 , U_BRK_HEX_DIGITS_EXPECTED = 66049 , U_BRK_SEMICOLON_EXPECTED = 66050 , U_BRK_RULE_SYNTAX = 66051 , U_BRK_UNCLOSED_SET = 66052 , U_BRK_ASSIGN_ERROR = 66053 , U_BRK_VARIABLE_REDFINITION = 66054 , U_BRK_MISMATCHED_PAREN = 66055 , U_BRK_NEW_LINE_IN_QUOTED_STRING = 66056 , U_BRK_UNDEFINED_VARIABLE = 66057 , U_BRK_INIT_ERROR = 66058 , U_BRK_RULE_EMPTY_SET = 66059 , U_BRK_UNRECOGNIZED_OPTION = 66060 , U_BRK_MALFORMED_RULE_TAG = 66061 , U_BRK_ERROR_LIMIT = 66062 , U_REGEX_INTERNAL_ERROR = 66304 , U_REGEX_RULE_SYNTAX = 66305 , U_REGEX_INVALID_STATE = 66306 , U_REGEX_BAD_ESCAPE_SEQUENCE = 66307 , U_REGEX_PROPERTY_SYNTAX = 66308 , U_REGEX_UNIMPLEMENTED = 66309 , U_REGEX_MISMATCHED_PAREN = 66310 , U_REGEX_NUMBER_TOO_BIG = 66311 , U_REGEX_BAD_INTERVAL = 66312 , U_REGEX_MAX_LT_MIN = 66313 , U_REGEX_INVALID_BACK_REF = 66314 , U_REGEX_INVALID_FLAG = 66315 , U_REGEX_LOOK_BEHIND_LIMIT = 66316 , U_REGEX_SET_CONTAINS_STRING = 66317 , U_REGEX_OCTAL_TOO_BIG = 66318 , U_REGEX_MISSING_CLOSE_BRACKET = 66319 , U_REGEX_INVALID_RANGE = 66320 , U_REGEX_STACK_OVERFLOW = 66321 , U_REGEX_TIME_OUT = 66322 , U_REGEX_STOPPED_BY_CALLER = 66323 , U_REGEX_PATTERN_TOO_BIG = 66324 , U_REGEX_INVALID_CAPTURE_GROUP_NAME = 66325 , U_REGEX_ERROR_LIMIT = 66326 , U_IDNA_PROHIBITED_ERROR = 66560 , U_IDNA_UNASSIGNED_ERROR = 66561 , U_IDNA_CHECK_BIDI_ERROR = 66562 , U_IDNA_STD3_ASCII_RULES_ERROR = 66563 , U_IDNA_ACE_PREFIX_ERROR = 66564 , U_IDNA_VERIFICATION_ERROR = 66565 , U_IDNA_LABEL_TOO_LONG_ERROR = 66566 , U_IDNA_ZERO_LENGTH_LABEL_ERROR = 66567 , U_IDNA_DOMAIN_NAME_TOO_LONG_ERROR = 66568 , U_IDNA_ERROR_LIMIT = 66569 , U_PLUGIN_ERROR_START = 66816 , U_PLUGIN_DIDNT_SET_LEVEL = 66817 , U_PLUGIN_ERROR_LIMIT = 66818 , } extern "C" { pub fn u_errorName_68 (code : UErrorCode) -> * const :: std :: os :: raw :: c_char ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct UEnumeration { _unused : [u8 ; 0] , } extern "C" { pub fn uenum_close_68 (en : * mut UEnumeration) ; } extern "C" { pub fn uenum_count_68 (en : * mut UEnumeration , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uenum_unext_68 (en : * mut UEnumeration , resultLength : * mut i32 , status : * mut UErrorCode) -> * const UChar ; } extern "C" { pub fn uenum_next_68 (en : * mut UEnumeration , resultLength : * mut i32 , status : * mut UErrorCode) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn uenum_reset_68 (en : * mut UEnumeration , status : * mut UErrorCode) ; } extern "C" { pub fn uenum_openUCharStringsEnumeration_68 (strings : * const * const UChar , count : i32 , ec : * mut UErrorCode) -> * mut UEnumeration ; } extern "C" { pub fn uenum_openCharStringsEnumeration_68 (strings : * const * const :: std :: os :: raw :: c_char , count : i32 , ec : * mut UErrorCode) -> * mut UEnumeration ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum ULocDataLocaleType { ULOC_ACTUAL_LOCALE = 0 , ULOC_VALID_LOCALE = 1 , ULOC_REQUESTED_LOCALE = 2 , ULOC_DATA_LOCALE_TYPE_LIMIT = 3 , } extern "C" { pub fn uloc_getDefault_68 () -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn uloc_setDefault_68 (localeID : * const :: std :: os :: raw :: c_char , status : * mut UErrorCode) ; } extern "C" { pub fn uloc_getLanguage_68 (localeID : * const :: std :: os :: raw :: c_char , language : * mut :: std :: os :: raw :: c_char , languageCapacity : i32 , err : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_getScript_68 (localeID : * const :: std :: os :: raw :: c_char , script : * mut :: std :: os :: raw :: c_char , scriptCapacity : i32 , err : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_getCountry_68 (localeID : * const :: std :: os :: raw :: c_char , country : * mut :: std :: os :: raw :: c_char , countryCapacity : i32 , err : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_getVariant_68 (localeID : * const :: std :: os :: raw :: c_char , variant : * mut :: std :: os :: raw :: c_char , variantCapacity : i32 , err : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_getName_68 (localeID : * const :: std :: os :: raw :: c_char , name : * mut :: std :: os :: raw :: c_char , nameCapacity : i32 , err : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_canonicalize_68 (localeID : * const :: std :: os :: raw :: c_char , name : * mut :: std :: os :: raw :: c_char , nameCapacity : i32 , err : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_getISO3Language_68 (localeID : * const :: std :: os :: raw :: c_char) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn uloc_getISO3Country_68 (localeID : * const :: std :: os :: raw :: c_char) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn uloc_getLCID_68 (localeID : * const :: std :: os :: raw :: c_char) -> u32 ; } extern "C" { pub fn uloc_getDisplayLanguage_68 (locale : * const :: std :: os :: raw :: c_char , displayLocale : * const :: std :: os :: raw :: c_char , language : * mut UChar , languageCapacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_getDisplayScript_68 (locale : * const :: std :: os :: raw :: c_char , displayLocale : * const :: std :: os :: raw :: c_char , script : * mut UChar , scriptCapacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_getDisplayCountry_68 (locale : * const :: std :: os :: raw :: c_char , displayLocale : * const :: std :: os :: raw :: c_char , country : * mut UChar , countryCapacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_getDisplayVariant_68 (locale : * const :: std :: os :: raw :: c_char , displayLocale : * const :: std :: os :: raw :: c_char , variant : * mut UChar , variantCapacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_getDisplayKeyword_68 (keyword : * const :: std :: os :: raw :: c_char , displayLocale : * const :: std :: os :: raw :: c_char , dest : * mut UChar , destCapacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_getDisplayKeywordValue_68 (locale : * const :: std :: os :: raw :: c_char , keyword : * const :: std :: os :: raw :: c_char , displayLocale : * const :: std :: os :: raw :: c_char , dest : * mut UChar , destCapacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_getDisplayName_68 (localeID : * const :: std :: os :: raw :: c_char , inLocaleID : * const :: std :: os :: raw :: c_char , result : * mut UChar , maxResultSize : i32 , err : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_getAvailable_68 (n : i32) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn uloc_countAvailable_68 () -> i32 ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum ULocAvailableType { ULOC_AVAILABLE_DEFAULT = 0 , ULOC_AVAILABLE_ONLY_LEGACY_ALIASES = 1 , ULOC_AVAILABLE_WITH_LEGACY_ALIASES = 2 , ULOC_AVAILABLE_COUNT = 3 , } extern "C" { pub fn uloc_openAvailableByType_68 (type_ : ULocAvailableType , status : * mut UErrorCode) -> * mut UEnumeration ; } extern "C" { pub fn uloc_getISOLanguages_68 () -> * const * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn uloc_getISOCountries_68 () -> * const * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn uloc_getParent_68 (localeID : * const :: std :: os :: raw :: c_char , parent : * mut :: std :: os :: raw :: c_char , parentCapacity : i32 , err : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_getBaseName_68 (localeID : * const :: std :: os :: raw :: c_char , name : * mut :: std :: os :: raw :: c_char , nameCapacity : i32 , err : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_openKeywords_68 (localeID : * const :: std :: os :: raw :: c_char , status : * mut UErrorCode) -> * mut UEnumeration ; } extern "C" { pub fn uloc_getKeywordValue_68 (localeID : * const :: std :: os :: raw :: c_char , keywordName : * const :: std :: os :: raw :: c_char , buffer : * mut :: std :: os :: raw :: c_char , bufferCapacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_setKeywordValue_68 (keywordName : * const :: std :: os :: raw :: c_char , keywordValue : * const :: std :: os :: raw :: c_char , buffer : * mut :: std :: os :: raw :: c_char , bufferCapacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_isRightToLeft_68 (locale : * const :: std :: os :: raw :: c_char) -> UBool ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum ULayoutType { ULOC_LAYOUT_LTR = 0 , ULOC_LAYOUT_RTL = 1 , ULOC_LAYOUT_TTB = 2 , ULOC_LAYOUT_BTT = 3 , ULOC_LAYOUT_UNKNOWN = 4 , } extern "C" { pub fn uloc_getCharacterOrientation_68 (localeId : * const :: std :: os :: raw :: c_char , status : * mut UErrorCode) -> ULayoutType ; } extern "C" { pub fn uloc_getLineOrientation_68 (localeId : * const :: std :: os :: raw :: c_char , status : * mut UErrorCode) -> ULayoutType ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UAcceptResult { ULOC_ACCEPT_FAILED = 0 , ULOC_ACCEPT_VALID = 1 , ULOC_ACCEPT_FALLBACK = 2 , } extern "C" { pub fn uloc_acceptLanguageFromHTTP_68 (result : * mut :: std :: os :: raw :: c_char , resultAvailable : i32 , outResult : * mut UAcceptResult , httpAcceptLanguage : * const :: std :: os :: raw :: c_char , availableLocales : * mut UEnumeration , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_acceptLanguage_68 (result : * mut :: std :: os :: raw :: c_char , resultAvailable : i32 , outResult : * mut UAcceptResult , acceptList : * mut * const :: std :: os :: raw :: c_char , acceptListCount : i32 , availableLocales : * mut UEnumeration , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_getLocaleForLCID_68 (hostID : u32 , locale : * mut :: std :: os :: raw :: c_char , localeCapacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_addLikelySubtags_68 (localeID : * const :: std :: os :: raw :: c_char , maximizedLocaleID : * mut :: std :: os :: raw :: c_char , maximizedLocaleIDCapacity : i32 , err : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_minimizeSubtags_68 (localeID : * const :: std :: os :: raw :: c_char , minimizedLocaleID : * mut :: std :: os :: raw :: c_char , minimizedLocaleIDCapacity : i32 , err : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_forLanguageTag_68 (langtag : * const :: std :: os :: raw :: c_char , localeID : * mut :: std :: os :: raw :: c_char , localeIDCapacity : i32 , parsedLength : * mut i32 , err : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_toLanguageTag_68 (localeID : * const :: std :: os :: raw :: c_char , langtag : * mut :: std :: os :: raw :: c_char , langtagCapacity : i32 , strict : UBool , err : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uloc_toUnicodeLocaleKey_68 (keyword : * const :: std :: os :: raw :: c_char) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn uloc_toUnicodeLocaleType_68 (keyword : * const :: std :: os :: raw :: c_char , value : * const :: std :: os :: raw :: c_char) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn uloc_toLegacyKey_68 (keyword : * const :: std :: os :: raw :: c_char) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn uloc_toLegacyType_68 (keyword : * const :: std :: os :: raw :: c_char , value : * const :: std :: os :: raw :: c_char) -> * const :: std :: os :: raw :: c_char ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct UCPMap { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct USet { _unused : [u8 ; 0] , } impl UProperty { pub const UCHAR_BINARY_START : UProperty = UProperty :: UCHAR_ALPHABETIC ; } impl UProperty { pub const UCHAR_INT_START : UProperty = UProperty :: UCHAR_BIDI_CLASS ; } impl UProperty { pub const UCHAR_MASK_START : UProperty = UProperty :: UCHAR_GENERAL_CATEGORY_MASK ; } impl UProperty { pub const UCHAR_DOUBLE_START : UProperty = UProperty :: UCHAR_NUMERIC_VALUE ; } impl UProperty { pub const UCHAR_STRING_START : UProperty = UProperty :: UCHAR_AGE ; } impl UProperty { pub const UCHAR_OTHER_PROPERTY_START : UProperty = UProperty :: UCHAR_SCRIPT_EXTENSIONS ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UProperty { UCHAR_ALPHABETIC = 0 , UCHAR_ASCII_HEX_DIGIT = 1 , UCHAR_BIDI_CONTROL = 2 , UCHAR_BIDI_MIRRORED = 3 , UCHAR_DASH = 4 , UCHAR_DEFAULT_IGNORABLE_CODE_POINT = 5 , UCHAR_DEPRECATED = 6 , UCHAR_DIACRITIC = 7 , UCHAR_EXTENDER = 8 , UCHAR_FULL_COMPOSITION_EXCLUSION = 9 , UCHAR_GRAPHEME_BASE = 10 , UCHAR_GRAPHEME_EXTEND = 11 , UCHAR_GRAPHEME_LINK = 12 , UCHAR_HEX_DIGIT = 13 , UCHAR_HYPHEN = 14 , UCHAR_ID_CONTINUE = 15 , UCHAR_ID_START = 16 , UCHAR_IDEOGRAPHIC = 17 , UCHAR_IDS_BINARY_OPERATOR = 18 , UCHAR_IDS_TRINARY_OPERATOR = 19 , UCHAR_JOIN_CONTROL = 20 , UCHAR_LOGICAL_ORDER_EXCEPTION = 21 , UCHAR_LOWERCASE = 22 , UCHAR_MATH = 23 , UCHAR_NONCHARACTER_CODE_POINT = 24 , UCHAR_QUOTATION_MARK = 25 , UCHAR_RADICAL = 26 , UCHAR_SOFT_DOTTED = 27 , UCHAR_TERMINAL_PUNCTUATION = 28 , UCHAR_UNIFIED_IDEOGRAPH = 29 , UCHAR_UPPERCASE = 30 , UCHAR_WHITE_SPACE = 31 , UCHAR_XID_CONTINUE = 32 , UCHAR_XID_START = 33 , UCHAR_CASE_SENSITIVE = 34 , UCHAR_S_TERM = 35 , UCHAR_VARIATION_SELECTOR = 36 , UCHAR_NFD_INERT = 37 , UCHAR_NFKD_INERT = 38 , UCHAR_NFC_INERT = 39 , UCHAR_NFKC_INERT = 40 , UCHAR_SEGMENT_STARTER = 41 , UCHAR_PATTERN_SYNTAX = 42 , UCHAR_PATTERN_WHITE_SPACE = 43 , UCHAR_POSIX_ALNUM = 44 , UCHAR_POSIX_BLANK = 45 , UCHAR_POSIX_GRAPH = 46 , UCHAR_POSIX_PRINT = 47 , UCHAR_POSIX_XDIGIT = 48 , UCHAR_CASED = 49 , UCHAR_CASE_IGNORABLE = 50 , UCHAR_CHANGES_WHEN_LOWERCASED = 51 , UCHAR_CHANGES_WHEN_UPPERCASED = 52 , UCHAR_CHANGES_WHEN_TITLECASED = 53 , UCHAR_CHANGES_WHEN_CASEFOLDED = 54 , UCHAR_CHANGES_WHEN_CASEMAPPED = 55 , UCHAR_CHANGES_WHEN_NFKC_CASEFOLDED = 56 , UCHAR_EMOJI = 57 , UCHAR_EMOJI_PRESENTATION = 58 , UCHAR_EMOJI_MODIFIER = 59 , UCHAR_EMOJI_MODIFIER_BASE = 60 , UCHAR_EMOJI_COMPONENT = 61 , UCHAR_REGIONAL_INDICATOR = 62 , UCHAR_PREPENDED_CONCATENATION_MARK = 63 , UCHAR_EXTENDED_PICTOGRAPHIC = 64 , UCHAR_BINARY_LIMIT = 65 , UCHAR_BIDI_CLASS = 4096 , UCHAR_BLOCK = 4097 , UCHAR_CANONICAL_COMBINING_CLASS = 4098 , UCHAR_DECOMPOSITION_TYPE = 4099 , UCHAR_EAST_ASIAN_WIDTH = 4100 , UCHAR_GENERAL_CATEGORY = 4101 , UCHAR_JOINING_GROUP = 4102 , UCHAR_JOINING_TYPE = 4103 , UCHAR_LINE_BREAK = 4104 , UCHAR_NUMERIC_TYPE = 4105 , UCHAR_SCRIPT = 4106 , UCHAR_HANGUL_SYLLABLE_TYPE = 4107 , UCHAR_NFD_QUICK_CHECK = 4108 , UCHAR_NFKD_QUICK_CHECK = 4109 , UCHAR_NFC_QUICK_CHECK = 4110 , UCHAR_NFKC_QUICK_CHECK = 4111 , UCHAR_LEAD_CANONICAL_COMBINING_CLASS = 4112 , UCHAR_TRAIL_CANONICAL_COMBINING_CLASS = 4113 , UCHAR_GRAPHEME_CLUSTER_BREAK = 4114 , UCHAR_SENTENCE_BREAK = 4115 , UCHAR_WORD_BREAK = 4116 , UCHAR_BIDI_PAIRED_BRACKET_TYPE = 4117 , UCHAR_INDIC_POSITIONAL_CATEGORY = 4118 , UCHAR_INDIC_SYLLABIC_CATEGORY = 4119 , UCHAR_VERTICAL_ORIENTATION = 4120 , UCHAR_INT_LIMIT = 4121 , UCHAR_GENERAL_CATEGORY_MASK = 8192 , UCHAR_MASK_LIMIT = 8193 , UCHAR_NUMERIC_VALUE = 12288 , UCHAR_DOUBLE_LIMIT = 12289 , UCHAR_AGE = 16384 , UCHAR_BIDI_MIRRORING_GLYPH = 16385 , UCHAR_CASE_FOLDING = 16386 , UCHAR_ISO_COMMENT = 16387 , UCHAR_LOWERCASE_MAPPING = 16388 , UCHAR_NAME = 16389 , UCHAR_SIMPLE_CASE_FOLDING = 16390 , UCHAR_SIMPLE_LOWERCASE_MAPPING = 16391 , UCHAR_SIMPLE_TITLECASE_MAPPING = 16392 , UCHAR_SIMPLE_UPPERCASE_MAPPING = 16393 , UCHAR_TITLECASE_MAPPING = 16394 , UCHAR_UNICODE_1_NAME = 16395 , UCHAR_UPPERCASE_MAPPING = 16396 , UCHAR_BIDI_PAIRED_BRACKET = 16397 , UCHAR_STRING_LIMIT = 16398 , UCHAR_SCRIPT_EXTENSIONS = 28672 , UCHAR_OTHER_PROPERTY_LIMIT = 28673 , UCHAR_INVALID_CODE = - 1 , } impl UCharCategory { pub const U_GENERAL_OTHER_TYPES : UCharCategory = UCharCategory :: U_UNASSIGNED ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UCharCategory { U_UNASSIGNED = 0 , U_UPPERCASE_LETTER = 1 , U_LOWERCASE_LETTER = 2 , U_TITLECASE_LETTER = 3 , U_MODIFIER_LETTER = 4 , U_OTHER_LETTER = 5 , U_NON_SPACING_MARK = 6 , U_ENCLOSING_MARK = 7 , U_COMBINING_SPACING_MARK = 8 , U_DECIMAL_DIGIT_NUMBER = 9 , U_LETTER_NUMBER = 10 , U_OTHER_NUMBER = 11 , U_SPACE_SEPARATOR = 12 , U_LINE_SEPARATOR = 13 , U_PARAGRAPH_SEPARATOR = 14 , U_CONTROL_CHAR = 15 , U_FORMAT_CHAR = 16 , U_PRIVATE_USE_CHAR = 17 , U_SURROGATE = 18 , U_DASH_PUNCTUATION = 19 , U_START_PUNCTUATION = 20 , U_END_PUNCTUATION = 21 , U_CONNECTOR_PUNCTUATION = 22 , U_OTHER_PUNCTUATION = 23 , U_MATH_SYMBOL = 24 , U_CURRENCY_SYMBOL = 25 , U_MODIFIER_SYMBOL = 26 , U_OTHER_SYMBOL = 27 , U_INITIAL_PUNCTUATION = 28 , U_FINAL_PUNCTUATION = 29 , U_CHAR_CATEGORY_COUNT = 30 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UCharDirection { U_LEFT_TO_RIGHT = 0 , U_RIGHT_TO_LEFT = 1 , U_EUROPEAN_NUMBER = 2 , U_EUROPEAN_NUMBER_SEPARATOR = 3 , U_EUROPEAN_NUMBER_TERMINATOR = 4 , U_ARABIC_NUMBER = 5 , U_COMMON_NUMBER_SEPARATOR = 6 , U_BLOCK_SEPARATOR = 7 , U_SEGMENT_SEPARATOR = 8 , U_WHITE_SPACE_NEUTRAL = 9 , U_OTHER_NEUTRAL = 10 , U_LEFT_TO_RIGHT_EMBEDDING = 11 , U_LEFT_TO_RIGHT_OVERRIDE = 12 , U_RIGHT_TO_LEFT_ARABIC = 13 , U_RIGHT_TO_LEFT_EMBEDDING = 14 , U_RIGHT_TO_LEFT_OVERRIDE = 15 , U_POP_DIRECTIONAL_FORMAT = 16 , U_DIR_NON_SPACING_MARK = 17 , U_BOUNDARY_NEUTRAL = 18 , U_FIRST_STRONG_ISOLATE = 19 , U_LEFT_TO_RIGHT_ISOLATE = 20 , U_RIGHT_TO_LEFT_ISOLATE = 21 , U_POP_DIRECTIONAL_ISOLATE = 22 , U_CHAR_DIRECTION_COUNT = 23 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UCharNameChoice { U_UNICODE_CHAR_NAME = 0 , U_UNICODE_10_CHAR_NAME = 1 , U_EXTENDED_CHAR_NAME = 2 , U_CHAR_NAME_ALIAS = 3 , U_CHAR_NAME_CHOICE_COUNT = 4 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UPropertyNameChoice { U_SHORT_PROPERTY_NAME = 0 , U_LONG_PROPERTY_NAME = 1 , U_PROPERTY_NAME_CHOICE_COUNT = 2 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UWordBreakValues { U_WB_OTHER = 0 , U_WB_ALETTER = 1 , U_WB_FORMAT = 2 , U_WB_KATAKANA = 3 , U_WB_MIDLETTER = 4 , U_WB_MIDNUM = 5 , U_WB_NUMERIC = 6 , U_WB_EXTENDNUMLET = 7 , U_WB_CR = 8 , U_WB_EXTEND = 9 , U_WB_LF = 10 , U_WB_MIDNUMLET = 11 , U_WB_NEWLINE = 12 , U_WB_REGIONAL_INDICATOR = 13 , U_WB_HEBREW_LETTER = 14 , U_WB_SINGLE_QUOTE = 15 , U_WB_DOUBLE_QUOTE = 16 , U_WB_E_BASE = 17 , U_WB_E_BASE_GAZ = 18 , U_WB_E_MODIFIER = 19 , U_WB_GLUE_AFTER_ZWJ = 20 , U_WB_ZWJ = 21 , U_WB_WSEGSPACE = 22 , U_WB_COUNT = 23 , } extern "C" { pub fn u_hasBinaryProperty_68 (c : UChar32 , which : UProperty) -> UBool ; } extern "C" { pub fn u_getBinaryPropertySet_68 (property : UProperty , pErrorCode : * mut UErrorCode) -> * const USet ; } extern "C" { pub fn u_isUAlphabetic_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isULowercase_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isUUppercase_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isUWhiteSpace_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_getIntPropertyValue_68 (c : UChar32 , which : UProperty) -> i32 ; } extern "C" { pub fn u_getIntPropertyMinValue_68 (which : UProperty) -> i32 ; } extern "C" { pub fn u_getIntPropertyMaxValue_68 (which : UProperty) -> i32 ; } extern "C" { pub fn u_getIntPropertyMap_68 (property : UProperty , pErrorCode : * mut UErrorCode) -> * const UCPMap ; } extern "C" { pub fn u_getNumericValue_68 (c : UChar32) -> f64 ; } extern "C" { pub fn u_islower_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isupper_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_istitle_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isdigit_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isalpha_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isalnum_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isxdigit_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_ispunct_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isgraph_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isblank_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isdefined_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isspace_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isJavaSpaceChar_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isWhitespace_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_iscntrl_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isISOControl_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isprint_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isbase_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_charDirection_68 (c : UChar32) -> UCharDirection ; } extern "C" { pub fn u_isMirrored_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_charMirror_68 (c : UChar32) -> UChar32 ; } extern "C" { pub fn u_getBidiPairedBracket_68 (c : UChar32) -> UChar32 ; } extern "C" { pub fn u_charType_68 (c : UChar32) -> i8 ; } pub type UCharEnumTypeRange = :: std :: option :: Option < unsafe extern "C" fn (context : * const :: std :: os :: raw :: c_void , start : UChar32 , limit : UChar32 , type_ : UCharCategory) -> UBool > ; extern "C" { pub fn u_enumCharTypes_68 (enumRange : UCharEnumTypeRange , context : * const :: std :: os :: raw :: c_void) ; } extern "C" { pub fn u_getCombiningClass_68 (c : UChar32) -> u8 ; } extern "C" { pub fn u_charDigitValue_68 (c : UChar32) -> i32 ; } extern "C" { pub fn u_charName_68 (code : UChar32 , nameChoice : UCharNameChoice , buffer : * mut :: std :: os :: raw :: c_char , bufferLength : i32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn u_getISOComment_68 (c : UChar32 , dest : * mut :: std :: os :: raw :: c_char , destCapacity : i32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn u_charFromName_68 (nameChoice : UCharNameChoice , name : * const :: std :: os :: raw :: c_char , pErrorCode : * mut UErrorCode) -> UChar32 ; } pub type UEnumCharNamesFn = :: std :: option :: Option < unsafe extern "C" fn (context : * mut :: std :: os :: raw :: c_void , code : UChar32 , nameChoice : UCharNameChoice , name : * const :: std :: os :: raw :: c_char , length : i32) -> UBool > ; extern "C" { pub fn u_enumCharNames_68 (start : UChar32 , limit : UChar32 , fn_ : UEnumCharNamesFn , context : * mut :: std :: os :: raw :: c_void , nameChoice : UCharNameChoice , pErrorCode : * mut UErrorCode) ; } extern "C" { pub fn u_getPropertyName_68 (property : UProperty , nameChoice : UPropertyNameChoice) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn u_getPropertyEnum_68 (alias : * const :: std :: os :: raw :: c_char) -> UProperty ; } extern "C" { pub fn u_getPropertyValueName_68 (property : UProperty , value : i32 , nameChoice : UPropertyNameChoice) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn u_getPropertyValueEnum_68 (property : UProperty , alias : * const :: std :: os :: raw :: c_char) -> i32 ; } extern "C" { pub fn u_isIDStart_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isIDPart_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isIDIgnorable_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isJavaIDStart_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_isJavaIDPart_68 (c : UChar32) -> UBool ; } extern "C" { pub fn u_tolower_68 (c : UChar32) -> UChar32 ; } extern "C" { pub fn u_toupper_68 (c : UChar32) -> UChar32 ; } extern "C" { pub fn u_totitle_68 (c : UChar32) -> UChar32 ; } extern "C" { pub fn u_foldCase_68 (c : UChar32 , options : u32) -> UChar32 ; } extern "C" { pub fn u_digit_68 (ch : UChar32 , radix : i8) -> i32 ; } extern "C" { pub fn u_forDigit_68 (digit : i32 , radix : i8) -> UChar32 ; } extern "C" { pub fn u_charAge_68 (c : UChar32 , versionArray : * mut u8) ; } extern "C" { pub fn u_getUnicodeVersion_68 (versionArray : * mut u8) ; } extern "C" { pub fn u_getFC_NFKC_Closure_68 (c : UChar32 , dest : * mut UChar , destCapacity : i32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn utext_close_68 (ut : * mut UText) -> * mut UText ; } extern "C" { pub fn utext_openUTF8_68 (ut : * mut UText , s : * const :: std :: os :: raw :: c_char , length : i64 , status : * mut UErrorCode) -> * mut UText ; } extern "C" { pub fn utext_openUChars_68 (ut : * mut UText , s : * const UChar , length : i64 , status : * mut UErrorCode) -> * mut UText ; } extern "C" { pub fn utext_clone_68 (dest : * mut UText , src : * const UText , deep : UBool , readOnly : UBool , status : * mut UErrorCode) -> * mut UText ; } extern "C" { pub fn utext_equals_68 (a : * const UText , b : * const UText) -> UBool ; } extern "C" { pub fn utext_nativeLength_68 (ut : * mut UText) -> i64 ; } extern "C" { pub fn utext_isLengthExpensive_68 (ut : * const UText) -> UBool ; } extern "C" { pub fn utext_char32At_68 (ut : * mut UText , nativeIndex : i64) -> UChar32 ; } extern "C" { pub fn utext_current32_68 (ut : * mut UText) -> UChar32 ; } extern "C" { pub fn utext_next32_68 (ut : * mut UText) -> UChar32 ; } extern "C" { pub fn utext_previous32_68 (ut : * mut UText) -> UChar32 ; } extern "C" { pub fn utext_next32From_68 (ut : * mut UText , nativeIndex : i64) -> UChar32 ; } extern "C" { pub fn utext_previous32From_68 (ut : * mut UText , nativeIndex : i64) -> UChar32 ; } extern "C" { pub fn utext_getNativeIndex_68 (ut : * const UText) -> i64 ; } extern "C" { pub fn utext_setNativeIndex_68 (ut : * mut UText , nativeIndex : i64) ; } extern "C" { pub fn utext_moveIndex32_68 (ut : * mut UText , delta : i32) -> UBool ; } extern "C" { pub fn utext_getPreviousNativeIndex_68 (ut : * mut UText) -> i64 ; } extern "C" { pub fn utext_extract_68 (ut : * mut UText , nativeStart : i64 , nativeLimit : i64 , dest : * mut UChar , destCapacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn utext_isWritable_68 (ut : * const UText) -> UBool ; } extern "C" { pub fn utext_hasMetaData_68 (ut : * const UText) -> UBool ; } extern "C" { pub fn utext_replace_68 (ut : * mut UText , nativeStart : i64 , nativeLimit : i64 , replacementText : * const UChar , replacementLength : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn utext_copy_68 (ut : * mut UText , nativeStart : i64 , nativeLimit : i64 , destIndex : i64 , move_ : UBool , status : * mut UErrorCode) ; } extern "C" { pub fn utext_freeze_68 (ut : * mut UText) ; } pub type UTextClone = :: std :: option :: Option < unsafe extern "C" fn (dest : * mut UText , src : * const UText , deep : UBool , status : * mut UErrorCode) -> * mut UText > ; pub type UTextNativeLength = :: std :: option :: Option < unsafe extern "C" fn (ut : * mut UText) -> i64 > ; pub type UTextAccess = :: std :: option :: Option < unsafe extern "C" fn (ut : * mut UText , nativeIndex : i64 , forward : UBool) -> UBool > ; pub type UTextExtract = :: std :: option :: Option < unsafe extern "C" fn (ut : * mut UText , nativeStart : i64 , nativeLimit : i64 , dest : * mut UChar , destCapacity : i32 , status : * mut UErrorCode) -> i32 > ; pub type UTextReplace = :: std :: option :: Option < unsafe extern "C" fn (ut : * mut UText , nativeStart : i64 , nativeLimit : i64 , replacementText : * const UChar , replacmentLength : i32 , status : * mut UErrorCode) -> i32 > ; pub type UTextCopy = :: std :: option :: Option < unsafe extern "C" fn (ut : * mut UText , nativeStart : i64 , nativeLimit : i64 , nativeDest : i64 , move_ : UBool , status : * mut UErrorCode) > ; pub type UTextMapOffsetToNative = :: std :: option :: Option < unsafe extern "C" fn (ut : * const UText) -> i64 > ; pub type UTextMapNativeIndexToUTF16 = :: std :: option :: Option < unsafe extern "C" fn (ut : * const UText , nativeIndex : i64) -> i32 > ; pub type UTextClose = :: std :: option :: Option < unsafe extern "C" fn (ut : * mut UText) > ; # [repr (C)] # [derive (Debug , Default , Copy , Clone , Hash , PartialOrd , PartialEq)] pub struct UTextFuncs { pub tableSize : i32 , pub reserved1 : i32 , pub reserved2 : i32 , pub reserved3 : i32 , pub clone : UTextClone , pub nativeLength : UTextNativeLength , pub access : UTextAccess , pub extract : UTextExtract , pub replace : UTextReplace , pub copy : UTextCopy , pub mapOffsetToNative : UTextMapOffsetToNative , pub mapNativeIndexToUTF16 : UTextMapNativeIndexToUTF16 , pub close : UTextClose , pub spare1 : UTextClose , pub spare2 : UTextClose , pub spare3 : UTextClose , } # [test] fn bindgen_test_layout_UTextFuncs () { assert_eq ! (:: std :: mem :: size_of :: < UTextFuncs > () , 112usize , concat ! ("Size of: " , stringify ! (UTextFuncs))) ; assert_eq ! (:: std :: mem :: align_of :: < UTextFuncs > () , 8usize , concat ! ("Alignment of " , stringify ! (UTextFuncs))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTextFuncs > ())) . tableSize as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (UTextFuncs) , "::" , stringify ! (tableSize))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTextFuncs > ())) . reserved1 as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (UTextFuncs) , "::" , stringify ! (reserved1))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTextFuncs > ())) . reserved2 as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (UTextFuncs) , "::" , stringify ! (reserved2))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTextFuncs > ())) . reserved3 as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (UTextFuncs) , "::" , stringify ! (reserved3))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTextFuncs > ())) . clone as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (UTextFuncs) , "::" , stringify ! (clone))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTextFuncs > ())) . nativeLength as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (UTextFuncs) , "::" , stringify ! (nativeLength))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTextFuncs > ())) . access as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (UTextFuncs) , "::" , stringify ! (access))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTextFuncs > ())) . extract as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (UTextFuncs) , "::" , stringify ! (extract))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTextFuncs > ())) . replace as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (UTextFuncs) , "::" , stringify ! (replace))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTextFuncs > ())) . copy as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (UTextFuncs) , "::" , stringify ! (copy))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTextFuncs > ())) . mapOffsetToNative as * const _ as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (UTextFuncs) , "::" , stringify ! (mapOffsetToNative))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTextFuncs > ())) . mapNativeIndexToUTF16 as * const _ as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (UTextFuncs) , "::" , stringify ! (mapNativeIndexToUTF16))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTextFuncs > ())) . close as * const _ as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (UTextFuncs) , "::" , stringify ! (close))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTextFuncs > ())) . spare1 as * const _ as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (UTextFuncs) , "::" , stringify ! (spare1))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTextFuncs > ())) . spare2 as * const _ as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (UTextFuncs) , "::" , stringify ! (spare2))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTextFuncs > ())) . spare3 as * const _ as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (UTextFuncs) , "::" , stringify ! (spare3))) ; } # [repr (C)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq)] pub struct UText { pub magic : u32 , pub flags : i32 , pub providerProperties : i32 , pub sizeOfStruct : i32 , pub chunkNativeLimit : i64 , pub extraSize : i32 , pub nativeIndexingLimit : i32 , pub chunkNativeStart : i64 , pub chunkOffset : i32 , pub chunkLength : i32 , pub chunkContents : * const UChar , pub pFuncs : * const UTextFuncs , pub pExtra : * mut :: std :: os :: raw :: c_void , pub context : * const :: std :: os :: raw :: c_void , pub p : * const :: std :: os :: raw :: c_void , pub q : * const :: std :: os :: raw :: c_void , pub r : * const :: std :: os :: raw :: c_void , pub privP : * mut :: std :: os :: raw :: c_void , pub a : i64 , pub b : i32 , pub c : i32 , pub privA : i64 , pub privB : i32 , pub privC : i32 , } # [test] fn bindgen_test_layout_UText () { assert_eq ! (:: std :: mem :: size_of :: < UText > () , 144usize , concat ! ("Size of: " , stringify ! (UText))) ; assert_eq ! (:: std :: mem :: align_of :: < UText > () , 8usize , concat ! ("Alignment of " , stringify ! (UText))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . magic as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (magic))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . flags as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (flags))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . providerProperties as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (providerProperties))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . sizeOfStruct as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (sizeOfStruct))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . chunkNativeLimit as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (chunkNativeLimit))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . extraSize as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (extraSize))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . nativeIndexingLimit as * const _ as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (nativeIndexingLimit))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . chunkNativeStart as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (chunkNativeStart))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . chunkOffset as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (chunkOffset))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . chunkLength as * const _ as usize } , 44usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (chunkLength))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . chunkContents as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (chunkContents))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . pFuncs as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (pFuncs))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . pExtra as * const _ as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (pExtra))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . context as * const _ as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (context))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . p as * const _ as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (p))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . q as * const _ as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (q))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . r as * const _ as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (r))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . privP as * const _ as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (privP))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . a as * const _ as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (a))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . b as * const _ as usize } , 120usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (b))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . c as * const _ as usize } , 124usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (c))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . privA as * const _ as usize } , 128usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (privA))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . privB as * const _ as usize } , 136usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (privB))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UText > ())) . privC as * const _ as usize } , 140usize , concat ! ("Offset of field: " , stringify ! (UText) , "::" , stringify ! (privC))) ; } impl Default for UText { fn default () -> Self { let mut s = :: std :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: std :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } extern "C" { pub fn utext_setup_68 (ut : * mut UText , extraSpace : i32 , status : * mut UErrorCode) -> * mut UText ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct UBreakIterator { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Default , Copy , Clone , Hash , PartialOrd , PartialEq)] pub struct UParseError { pub line : i32 , pub offset : i32 , pub preContext : [UChar ; 16usize] , pub postContext : [UChar ; 16usize] , } # [test] fn bindgen_test_layout_UParseError () { assert_eq ! (:: std :: mem :: size_of :: < UParseError > () , 72usize , concat ! ("Size of: " , stringify ! (UParseError))) ; assert_eq ! (:: std :: mem :: align_of :: < UParseError > () , 4usize , concat ! ("Alignment of " , stringify ! (UParseError))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UParseError > ())) . line as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (UParseError) , "::" , stringify ! (line))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UParseError > ())) . offset as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (UParseError) , "::" , stringify ! (offset))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UParseError > ())) . preContext as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (UParseError) , "::" , stringify ! (preContext))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UParseError > ())) . postContext as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (UParseError) , "::" , stringify ! (postContext))) ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UBreakIteratorType { UBRK_CHARACTER = 0 , UBRK_WORD = 1 , UBRK_LINE = 2 , UBRK_SENTENCE = 3 , UBRK_TITLE = 4 , UBRK_COUNT = 5 , } impl UWordBreak { pub const UBRK_WORD_NUMBER : UWordBreak = UWordBreak :: UBRK_WORD_NONE_LIMIT ; } impl UWordBreak { pub const UBRK_WORD_LETTER : UWordBreak = UWordBreak :: UBRK_WORD_NUMBER_LIMIT ; } impl UWordBreak { pub const UBRK_WORD_KANA : UWordBreak = UWordBreak :: UBRK_WORD_LETTER_LIMIT ; } impl UWordBreak { pub const UBRK_WORD_IDEO : UWordBreak = UWordBreak :: UBRK_WORD_KANA_LIMIT ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UWordBreak { UBRK_WORD_NONE = 0 , UBRK_WORD_NONE_LIMIT = 100 , UBRK_WORD_NUMBER_LIMIT = 200 , UBRK_WORD_LETTER_LIMIT = 300 , UBRK_WORD_KANA_LIMIT = 400 , UBRK_WORD_IDEO_LIMIT = 500 , } impl ULineBreakTag { pub const UBRK_LINE_HARD : ULineBreakTag = ULineBreakTag :: UBRK_LINE_SOFT_LIMIT ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum ULineBreakTag { UBRK_LINE_SOFT = 0 , UBRK_LINE_SOFT_LIMIT = 100 , UBRK_LINE_HARD_LIMIT = 200 , } impl USentenceBreakTag { pub const UBRK_SENTENCE_SEP : USentenceBreakTag = USentenceBreakTag :: UBRK_SENTENCE_TERM_LIMIT ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum USentenceBreakTag { UBRK_SENTENCE_TERM = 0 , UBRK_SENTENCE_TERM_LIMIT = 100 , UBRK_SENTENCE_SEP_LIMIT = 200 , } extern "C" { pub fn ubrk_open_68 (type_ : UBreakIteratorType , locale : * const :: std :: os :: raw :: c_char , text : * const UChar , textLength : i32 , status : * mut UErrorCode) -> * mut UBreakIterator ; } extern "C" { pub fn ubrk_openRules_68 (rules : * const UChar , rulesLength : i32 , text : * const UChar , textLength : i32 , parseErr : * mut UParseError , status : * mut UErrorCode) -> * mut UBreakIterator ; } extern "C" { pub fn ubrk_openBinaryRules_68 (binaryRules : * const u8 , rulesLength : i32 , text : * const UChar , textLength : i32 , status : * mut UErrorCode) -> * mut UBreakIterator ; } extern "C" { pub fn ubrk_safeClone_68 (bi : * const UBreakIterator , stackBuffer : * mut :: std :: os :: raw :: c_void , pBufferSize : * mut i32 , status : * mut UErrorCode) -> * mut UBreakIterator ; } extern "C" { pub fn ubrk_close_68 (bi : * mut UBreakIterator) ; } extern "C" { pub fn ubrk_setText_68 (bi : * mut UBreakIterator , text : * const UChar , textLength : i32 , status : * mut UErrorCode) ; } extern "C" { pub fn ubrk_setUText_68 (bi : * mut UBreakIterator , text : * mut UText , status : * mut UErrorCode) ; } extern "C" { pub fn ubrk_current_68 (bi : * const UBreakIterator) -> i32 ; } extern "C" { pub fn ubrk_next_68 (bi : * mut UBreakIterator) -> i32 ; } extern "C" { pub fn ubrk_previous_68 (bi : * mut UBreakIterator) -> i32 ; } extern "C" { pub fn ubrk_first_68 (bi : * mut UBreakIterator) -> i32 ; } extern "C" { pub fn ubrk_last_68 (bi : * mut UBreakIterator) -> i32 ; } extern "C" { pub fn ubrk_preceding_68 (bi : * mut UBreakIterator , offset : i32) -> i32 ; } extern "C" { pub fn ubrk_following_68 (bi : * mut UBreakIterator , offset : i32) -> i32 ; } extern "C" { pub fn ubrk_getAvailable_68 (index : i32) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn ubrk_countAvailable_68 () -> i32 ; } extern "C" { pub fn ubrk_isBoundary_68 (bi : * mut UBreakIterator , offset : i32) -> UBool ; } extern "C" { pub fn ubrk_getRuleStatus_68 (bi : * mut UBreakIterator) -> i32 ; } extern "C" { pub fn ubrk_getRuleStatusVec_68 (bi : * mut UBreakIterator , fillInVec : * mut i32 , capacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ubrk_getLocaleByType_68 (bi : * const UBreakIterator , type_ : ULocDataLocaleType , status : * mut UErrorCode) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn ubrk_refreshUText_68 (bi : * mut UBreakIterator , text : * mut UText , status : * mut UErrorCode) ; } extern "C" { pub fn ubrk_getBinaryRules_68 (bi : * mut UBreakIterator , binaryRules : * mut u8 , rulesCapacity : i32 , status : * mut UErrorCode) -> i32 ; } pub type UCalendar = * mut :: std :: os :: raw :: c_void ; impl UCalendarType { pub const UCAL_DEFAULT : UCalendarType = UCalendarType :: UCAL_TRADITIONAL ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UCalendarType { UCAL_TRADITIONAL = 0 , UCAL_GREGORIAN = 1 , } impl UCalendarDateFields { pub const UCAL_DAY_OF_MONTH : UCalendarDateFields = UCalendarDateFields :: UCAL_DATE ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UCalendarDateFields { UCAL_ERA = 0 , UCAL_YEAR = 1 , UCAL_MONTH = 2 , UCAL_WEEK_OF_YEAR = 3 , UCAL_WEEK_OF_MONTH = 4 , UCAL_DATE = 5 , UCAL_DAY_OF_YEAR = 6 , UCAL_DAY_OF_WEEK = 7 , UCAL_DAY_OF_WEEK_IN_MONTH = 8 , UCAL_AM_PM = 9 , UCAL_HOUR = 10 , UCAL_HOUR_OF_DAY = 11 , UCAL_MINUTE = 12 , UCAL_SECOND = 13 , UCAL_MILLISECOND = 14 , UCAL_ZONE_OFFSET = 15 , UCAL_DST_OFFSET = 16 , UCAL_YEAR_WOY = 17 , UCAL_DOW_LOCAL = 18 , UCAL_EXTENDED_YEAR = 19 , UCAL_JULIAN_DAY = 20 , UCAL_MILLISECONDS_IN_DAY = 21 , UCAL_IS_LEAP_MONTH = 22 , UCAL_FIELD_COUNT = 23 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UCalendarDaysOfWeek { UCAL_SUNDAY = 1 , UCAL_MONDAY = 2 , UCAL_TUESDAY = 3 , UCAL_WEDNESDAY = 4 , UCAL_THURSDAY = 5 , UCAL_FRIDAY = 6 , UCAL_SATURDAY = 7 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UCalendarMonths { UCAL_JANUARY = 0 , UCAL_FEBRUARY = 1 , UCAL_MARCH = 2 , UCAL_APRIL = 3 , UCAL_MAY = 4 , UCAL_JUNE = 5 , UCAL_JULY = 6 , UCAL_AUGUST = 7 , UCAL_SEPTEMBER = 8 , UCAL_OCTOBER = 9 , UCAL_NOVEMBER = 10 , UCAL_DECEMBER = 11 , UCAL_UNDECIMBER = 12 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UCalendarAMPMs { UCAL_AM = 0 , UCAL_PM = 1 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum USystemTimeZoneType { UCAL_ZONE_TYPE_ANY = 0 , UCAL_ZONE_TYPE_CANONICAL = 1 , UCAL_ZONE_TYPE_CANONICAL_LOCATION = 2 , } extern "C" { pub fn ucal_openTimeZoneIDEnumeration_68 (zoneType : USystemTimeZoneType , region : * const :: std :: os :: raw :: c_char , rawOffset : * const i32 , ec : * mut UErrorCode) -> * mut UEnumeration ; } extern "C" { pub fn ucal_openTimeZones_68 (ec : * mut UErrorCode) -> * mut UEnumeration ; } extern "C" { pub fn ucal_openCountryTimeZones_68 (country : * const :: std :: os :: raw :: c_char , ec : * mut UErrorCode) -> * mut UEnumeration ; } extern "C" { pub fn ucal_getDefaultTimeZone_68 (result : * mut UChar , resultCapacity : i32 , ec : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucal_setDefaultTimeZone_68 (zoneID : * const UChar , ec : * mut UErrorCode) ; } extern "C" { pub fn ucal_getHostTimeZone_68 (result : * mut UChar , resultCapacity : i32 , ec : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucal_getDSTSavings_68 (zoneID : * const UChar , ec : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucal_getNow_68 () -> UDate ; } extern "C" { pub fn ucal_open_68 (zoneID : * const UChar , len : i32 , locale : * const :: std :: os :: raw :: c_char , type_ : UCalendarType , status : * mut UErrorCode) -> * mut UCalendar ; } extern "C" { pub fn ucal_close_68 (cal : * mut UCalendar) ; } extern "C" { pub fn ucal_clone_68 (cal : * const UCalendar , status : * mut UErrorCode) -> * mut UCalendar ; } extern "C" { pub fn ucal_setTimeZone_68 (cal : * mut UCalendar , zoneID : * const UChar , len : i32 , status : * mut UErrorCode) ; } extern "C" { pub fn ucal_getTimeZoneID_68 (cal : * const UCalendar , result : * mut UChar , resultLength : i32 , status : * mut UErrorCode) -> i32 ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UCalendarDisplayNameType { UCAL_STANDARD = 0 , UCAL_SHORT_STANDARD = 1 , UCAL_DST = 2 , UCAL_SHORT_DST = 3 , } extern "C" { pub fn ucal_getTimeZoneDisplayName_68 (cal : * const UCalendar , type_ : UCalendarDisplayNameType , locale : * const :: std :: os :: raw :: c_char , result : * mut UChar , resultLength : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucal_inDaylightTime_68 (cal : * const UCalendar , status : * mut UErrorCode) -> UBool ; } extern "C" { pub fn ucal_setGregorianChange_68 (cal : * mut UCalendar , date : UDate , pErrorCode : * mut UErrorCode) ; } extern "C" { pub fn ucal_getGregorianChange_68 (cal : * const UCalendar , pErrorCode : * mut UErrorCode) -> UDate ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UCalendarAttribute { UCAL_LENIENT = 0 , UCAL_FIRST_DAY_OF_WEEK = 1 , UCAL_MINIMAL_DAYS_IN_FIRST_WEEK = 2 , UCAL_REPEATED_WALL_TIME = 3 , UCAL_SKIPPED_WALL_TIME = 4 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UCalendarWallTimeOption { UCAL_WALLTIME_LAST = 0 , UCAL_WALLTIME_FIRST = 1 , UCAL_WALLTIME_NEXT_VALID = 2 , } extern "C" { pub fn ucal_getAttribute_68 (cal : * const UCalendar , attr : UCalendarAttribute) -> i32 ; } extern "C" { pub fn ucal_setAttribute_68 (cal : * mut UCalendar , attr : UCalendarAttribute , newValue : i32) ; } extern "C" { pub fn ucal_getAvailable_68 (localeIndex : i32) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn ucal_countAvailable_68 () -> i32 ; } extern "C" { pub fn ucal_getMillis_68 (cal : * const UCalendar , status : * mut UErrorCode) -> UDate ; } extern "C" { pub fn ucal_setMillis_68 (cal : * mut UCalendar , dateTime : UDate , status : * mut UErrorCode) ; } extern "C" { pub fn ucal_setDate_68 (cal : * mut UCalendar , year : i32 , month : i32 , date : i32 , status : * mut UErrorCode) ; } extern "C" { pub fn ucal_setDateTime_68 (cal : * mut UCalendar , year : i32 , month : i32 , date : i32 , hour : i32 , minute : i32 , second : i32 , status : * mut UErrorCode) ; } extern "C" { pub fn ucal_equivalentTo_68 (cal1 : * const UCalendar , cal2 : * const UCalendar) -> UBool ; } extern "C" { pub fn ucal_add_68 (cal : * mut UCalendar , field : UCalendarDateFields , amount : i32 , status : * mut UErrorCode) ; } extern "C" { pub fn ucal_roll_68 (cal : * mut UCalendar , field : UCalendarDateFields , amount : i32 , status : * mut UErrorCode) ; } extern "C" { pub fn ucal_get_68 (cal : * const UCalendar , field : UCalendarDateFields , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucal_set_68 (cal : * mut UCalendar , field : UCalendarDateFields , value : i32) ; } extern "C" { pub fn ucal_isSet_68 (cal : * const UCalendar , field : UCalendarDateFields) -> UBool ; } extern "C" { pub fn ucal_clearField_68 (cal : * mut UCalendar , field : UCalendarDateFields) ; } extern "C" { pub fn ucal_clear_68 (calendar : * mut UCalendar) ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UCalendarLimitType { UCAL_MINIMUM = 0 , UCAL_MAXIMUM = 1 , UCAL_GREATEST_MINIMUM = 2 , UCAL_LEAST_MAXIMUM = 3 , UCAL_ACTUAL_MINIMUM = 4 , UCAL_ACTUAL_MAXIMUM = 5 , } extern "C" { pub fn ucal_getLimit_68 (cal : * const UCalendar , field : UCalendarDateFields , type_ : UCalendarLimitType , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucal_getLocaleByType_68 (cal : * const UCalendar , type_ : ULocDataLocaleType , status : * mut UErrorCode) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn ucal_getTZDataVersion_68 (status : * mut UErrorCode) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn ucal_getCanonicalTimeZoneID_68 (id : * const UChar , len : i32 , result : * mut UChar , resultCapacity : i32 , isSystemID : * mut UBool , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucal_getType_68 (cal : * const UCalendar , status : * mut UErrorCode) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn ucal_getKeywordValuesForLocale_68 (key : * const :: std :: os :: raw :: c_char , locale : * const :: std :: os :: raw :: c_char , commonlyUsed : UBool , status : * mut UErrorCode) -> * mut UEnumeration ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UCalendarWeekdayType { UCAL_WEEKDAY = 0 , UCAL_WEEKEND = 1 , UCAL_WEEKEND_ONSET = 2 , UCAL_WEEKEND_CEASE = 3 , } extern "C" { pub fn ucal_getDayOfWeekType_68 (cal : * const UCalendar , dayOfWeek : UCalendarDaysOfWeek , status : * mut UErrorCode) -> UCalendarWeekdayType ; } extern "C" { pub fn ucal_getWeekendTransition_68 (cal : * const UCalendar , dayOfWeek : UCalendarDaysOfWeek , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucal_isWeekend_68 (cal : * const UCalendar , date : UDate , status : * mut UErrorCode) -> UBool ; } extern "C" { pub fn ucal_getFieldDifference_68 (cal : * mut UCalendar , target : UDate , field : UCalendarDateFields , status : * mut UErrorCode) -> i32 ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UTimeZoneTransitionType { UCAL_TZ_TRANSITION_NEXT = 0 , UCAL_TZ_TRANSITION_NEXT_INCLUSIVE = 1 , UCAL_TZ_TRANSITION_PREVIOUS = 2 , UCAL_TZ_TRANSITION_PREVIOUS_INCLUSIVE = 3 , } extern "C" { pub fn ucal_getTimeZoneTransitionDate_68 (cal : * const UCalendar , type_ : UTimeZoneTransitionType , transition : * mut UDate , status : * mut UErrorCode) -> UBool ; } extern "C" { pub fn ucal_getWindowsTimeZoneID_68 (id : * const UChar , len : i32 , winid : * mut UChar , winidCapacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucal_getTimeZoneIDForWindowsID_68 (winid : * const UChar , len : i32 , region : * const :: std :: os :: raw :: c_char , id : * mut UChar , idCapacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn u_init_68 (status : * mut UErrorCode) ; } extern "C" { pub fn u_cleanup_68 () ; } pub type UMemAllocFn = :: std :: option :: Option < unsafe extern "C" fn (context : * const :: std :: os :: raw :: c_void , size : size_t) -> * mut :: std :: os :: raw :: c_void > ; pub type UMemReallocFn = :: std :: option :: Option < unsafe extern "C" fn (context : * const :: std :: os :: raw :: c_void , mem : * mut :: std :: os :: raw :: c_void , size : size_t) -> * mut :: std :: os :: raw :: c_void > ; pub type UMemFreeFn = :: std :: option :: Option < unsafe extern "C" fn (context : * const :: std :: os :: raw :: c_void , mem : * mut :: std :: os :: raw :: c_void) > ; extern "C" { pub fn u_setMemoryFunctions_68 (context : * const :: std :: os :: raw :: c_void , a : UMemAllocFn , r : UMemReallocFn , f : UMemFreeFn , status : * mut UErrorCode) ; } pub type UMTX = * mut :: std :: os :: raw :: c_void ; pub type UMtxInitFn = :: std :: option :: Option < unsafe extern "C" fn (context : * const :: std :: os :: raw :: c_void , mutex : * mut UMTX , status : * mut UErrorCode) > ; pub type UMtxFn = :: std :: option :: Option < unsafe extern "C" fn (context : * const :: std :: os :: raw :: c_void , mutex : * mut UMTX) > ; extern "C" { pub fn u_setMutexFunctions_68 (context : * const :: std :: os :: raw :: c_void , init : UMtxInitFn , destroy : UMtxFn , lock : UMtxFn , unlock : UMtxFn , status : * mut UErrorCode) ; } pub type UMtxAtomicFn = :: std :: option :: Option < unsafe extern "C" fn (context : * const :: std :: os :: raw :: c_void , p : * mut i32) -> i32 > ; extern "C" { pub fn u_setAtomicIncDecFunctions_68 (context : * const :: std :: os :: raw :: c_void , inc : UMtxAtomicFn , dec : UMtxAtomicFn , status : * mut UErrorCode) ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UCharIteratorOrigin { UITER_START = 0 , UITER_CURRENT = 1 , UITER_LIMIT = 2 , UITER_ZERO = 3 , UITER_LENGTH = 4 , } pub type UCharIteratorGetIndex = :: std :: option :: Option < unsafe extern "C" fn (iter : * mut UCharIterator , origin : UCharIteratorOrigin) -> i32 > ; pub type UCharIteratorMove = :: std :: option :: Option < unsafe extern "C" fn (iter : * mut UCharIterator , delta : i32 , origin : UCharIteratorOrigin) -> i32 > ; pub type UCharIteratorHasNext = :: std :: option :: Option < unsafe extern "C" fn (iter : * mut UCharIterator) -> UBool > ; pub type UCharIteratorHasPrevious = :: std :: option :: Option < unsafe extern "C" fn (iter : * mut UCharIterator) -> UBool > ; pub type UCharIteratorCurrent = :: std :: option :: Option < unsafe extern "C" fn (iter : * mut UCharIterator) -> UChar32 > ; pub type UCharIteratorNext = :: std :: option :: Option < unsafe extern "C" fn (iter : * mut UCharIterator) -> UChar32 > ; pub type UCharIteratorPrevious = :: std :: option :: Option < unsafe extern "C" fn (iter : * mut UCharIterator) -> UChar32 > ; pub type UCharIteratorReserved = :: std :: option :: Option < unsafe extern "C" fn (iter : * mut UCharIterator , something : i32) -> i32 > ; pub type UCharIteratorGetState = :: std :: option :: Option < unsafe extern "C" fn (iter : * const UCharIterator) -> u32 > ; pub type UCharIteratorSetState = :: std :: option :: Option < unsafe extern "C" fn (iter : * mut UCharIterator , state : u32 , pErrorCode : * mut UErrorCode) > ; # [repr (C)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq)] pub struct UCharIterator { pub context : * const :: std :: os :: raw :: c_void , pub length : i32 , pub start : i32 , pub index : i32 , pub limit : i32 , pub reservedField : i32 , pub getIndex : UCharIteratorGetIndex , pub move_ : UCharIteratorMove , pub hasNext : UCharIteratorHasNext , pub hasPrevious : UCharIteratorHasPrevious , pub current : UCharIteratorCurrent , pub next : UCharIteratorNext , pub previous : UCharIteratorPrevious , pub reservedFn : UCharIteratorReserved , pub getState : UCharIteratorGetState , pub setState : UCharIteratorSetState , } # [test] fn bindgen_test_layout_UCharIterator () { assert_eq ! (:: std :: mem :: size_of :: < UCharIterator > () , 112usize , concat ! ("Size of: " , stringify ! (UCharIterator))) ; assert_eq ! (:: std :: mem :: align_of :: < UCharIterator > () , 8usize , concat ! ("Alignment of " , stringify ! (UCharIterator))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UCharIterator > ())) . context as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (UCharIterator) , "::" , stringify ! (context))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UCharIterator > ())) . length as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (UCharIterator) , "::" , stringify ! (length))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UCharIterator > ())) . start as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (UCharIterator) , "::" , stringify ! (start))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UCharIterator > ())) . index as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (UCharIterator) , "::" , stringify ! (index))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UCharIterator > ())) . limit as * const _ as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (UCharIterator) , "::" , stringify ! (limit))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UCharIterator > ())) . reservedField as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (UCharIterator) , "::" , stringify ! (reservedField))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UCharIterator > ())) . getIndex as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (UCharIterator) , "::" , stringify ! (getIndex))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UCharIterator > ())) . move_ as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (UCharIterator) , "::" , stringify ! (move_))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UCharIterator > ())) . hasNext as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (UCharIterator) , "::" , stringify ! (hasNext))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UCharIterator > ())) . hasPrevious as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (UCharIterator) , "::" , stringify ! (hasPrevious))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UCharIterator > ())) . current as * const _ as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (UCharIterator) , "::" , stringify ! (current))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UCharIterator > ())) . next as * const _ as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (UCharIterator) , "::" , stringify ! (next))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UCharIterator > ())) . previous as * const _ as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (UCharIterator) , "::" , stringify ! (previous))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UCharIterator > ())) . reservedFn as * const _ as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (UCharIterator) , "::" , stringify ! (reservedFn))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UCharIterator > ())) . getState as * const _ as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (UCharIterator) , "::" , stringify ! (getState))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UCharIterator > ())) . setState as * const _ as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (UCharIterator) , "::" , stringify ! (setState))) ; } impl Default for UCharIterator { fn default () -> Self { let mut s = :: std :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: std :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum USetSpanCondition { USET_SPAN_NOT_CONTAINED = 0 , USET_SPAN_CONTAINED = 1 , USET_SPAN_SIMPLE = 2 , USET_SPAN_CONDITION_COUNT = 3 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UNormalization2Mode { UNORM2_COMPOSE = 0 , UNORM2_DECOMPOSE = 1 , UNORM2_FCD = 2 , UNORM2_COMPOSE_CONTIGUOUS = 3 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UNormalizationCheckResult { UNORM_NO = 0 , UNORM_YES = 1 , UNORM_MAYBE = 2 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct UNormalizer2 { _unused : [u8 ; 0] , } extern "C" { pub fn unorm2_getNFCInstance_68 (pErrorCode : * mut UErrorCode) -> * const UNormalizer2 ; } extern "C" { pub fn unorm2_getNFDInstance_68 (pErrorCode : * mut UErrorCode) -> * const UNormalizer2 ; } extern "C" { pub fn unorm2_getNFKCInstance_68 (pErrorCode : * mut UErrorCode) -> * const UNormalizer2 ; } extern "C" { pub fn unorm2_getNFKDInstance_68 (pErrorCode : * mut UErrorCode) -> * const UNormalizer2 ; } extern "C" { pub fn unorm2_getNFKCCasefoldInstance_68 (pErrorCode : * mut UErrorCode) -> * const UNormalizer2 ; } extern "C" { pub fn unorm2_getInstance_68 (packageName : * const :: std :: os :: raw :: c_char , name : * const :: std :: os :: raw :: c_char , mode : UNormalization2Mode , pErrorCode : * mut UErrorCode) -> * const UNormalizer2 ; } extern "C" { pub fn unorm2_openFiltered_68 (norm2 : * const UNormalizer2 , filterSet : * const USet , pErrorCode : * mut UErrorCode) -> * mut UNormalizer2 ; } extern "C" { pub fn unorm2_close_68 (norm2 : * mut UNormalizer2) ; } extern "C" { pub fn unorm2_normalize_68 (norm2 : * const UNormalizer2 , src : * const UChar , length : i32 , dest : * mut UChar , capacity : i32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unorm2_normalizeSecondAndAppend_68 (norm2 : * const UNormalizer2 , first : * mut UChar , firstLength : i32 , firstCapacity : i32 , second : * const UChar , secondLength : i32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unorm2_append_68 (norm2 : * const UNormalizer2 , first : * mut UChar , firstLength : i32 , firstCapacity : i32 , second : * const UChar , secondLength : i32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unorm2_getDecomposition_68 (norm2 : * const UNormalizer2 , c : UChar32 , decomposition : * mut UChar , capacity : i32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unorm2_getRawDecomposition_68 (norm2 : * const UNormalizer2 , c : UChar32 , decomposition : * mut UChar , capacity : i32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unorm2_composePair_68 (norm2 : * const UNormalizer2 , a : UChar32 , b : UChar32) -> UChar32 ; } extern "C" { pub fn unorm2_getCombiningClass_68 (norm2 : * const UNormalizer2 , c : UChar32) -> u8 ; } extern "C" { pub fn unorm2_isNormalized_68 (norm2 : * const UNormalizer2 , s : * const UChar , length : i32 , pErrorCode : * mut UErrorCode) -> UBool ; } extern "C" { pub fn unorm2_quickCheck_68 (norm2 : * const UNormalizer2 , s : * const UChar , length : i32 , pErrorCode : * mut UErrorCode) -> UNormalizationCheckResult ; } extern "C" { pub fn unorm2_spanQuickCheckYes_68 (norm2 : * const UNormalizer2 , s : * const UChar , length : i32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unorm2_hasBoundaryBefore_68 (norm2 : * const UNormalizer2 , c : UChar32) -> UBool ; } extern "C" { pub fn unorm2_hasBoundaryAfter_68 (norm2 : * const UNormalizer2 , c : UChar32) -> UBool ; } extern "C" { pub fn unorm2_isInert_68 (norm2 : * const UNormalizer2 , c : UChar32) -> UBool ; } impl UNormalizationMode { pub const UNORM_DEFAULT : UNormalizationMode = UNormalizationMode :: UNORM_NFC ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UNormalizationMode { UNORM_NONE = 1 , UNORM_NFD = 2 , UNORM_NFKD = 3 , UNORM_NFC = 4 , UNORM_NFKC = 5 , UNORM_FCD = 6 , UNORM_MODE_COUNT = 7 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct UCollator { _unused : [u8 ; 0] , } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UCollationResult { UCOL_EQUAL = 0 , UCOL_GREATER = 1 , UCOL_LESS = - 1 , } impl UColAttributeValue { pub const UCOL_DEFAULT_STRENGTH : UColAttributeValue = UColAttributeValue :: UCOL_TERTIARY ; } impl UColAttributeValue { pub const UCOL_QUATERNARY : UColAttributeValue = UColAttributeValue :: UCOL_CE_STRENGTH_LIMIT ; } impl UColAttributeValue { pub const UCOL_OFF : UColAttributeValue = UColAttributeValue :: UCOL_STRENGTH_LIMIT ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UColAttributeValue { UCOL_DEFAULT = - 1 , UCOL_PRIMARY = 0 , UCOL_SECONDARY = 1 , UCOL_TERTIARY = 2 , UCOL_CE_STRENGTH_LIMIT = 3 , UCOL_IDENTICAL = 15 , UCOL_STRENGTH_LIMIT = 16 , UCOL_ON = 17 , UCOL_SHIFTED = 20 , UCOL_NON_IGNORABLE = 21 , UCOL_LOWER_FIRST = 24 , UCOL_UPPER_FIRST = 25 , UCOL_ATTRIBUTE_VALUE_COUNT = 26 , } impl UColReorderCode { pub const UCOL_REORDER_CODE_OTHERS : UColReorderCode = UColReorderCode :: UCOL_REORDER_CODE_NONE ; } impl UColReorderCode { pub const UCOL_REORDER_CODE_FIRST : UColReorderCode = UColReorderCode :: UCOL_REORDER_CODE_SPACE ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UColReorderCode { UCOL_REORDER_CODE_DEFAULT = - 1 , UCOL_REORDER_CODE_NONE = 103 , UCOL_REORDER_CODE_SPACE = 4096 , UCOL_REORDER_CODE_PUNCTUATION = 4097 , UCOL_REORDER_CODE_SYMBOL = 4098 , UCOL_REORDER_CODE_CURRENCY = 4099 , UCOL_REORDER_CODE_DIGIT = 4100 , UCOL_REORDER_CODE_LIMIT = 4101 , } pub use self :: UColAttributeValue as UCollationStrength ; impl UColAttribute { pub const UCOL_DECOMPOSITION_MODE : UColAttribute = UColAttribute :: UCOL_NORMALIZATION_MODE ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UColAttribute { UCOL_FRENCH_COLLATION = 0 , UCOL_ALTERNATE_HANDLING = 1 , UCOL_CASE_FIRST = 2 , UCOL_CASE_LEVEL = 3 , UCOL_NORMALIZATION_MODE = 4 , UCOL_STRENGTH = 5 , UCOL_HIRAGANA_QUATERNARY_MODE = 6 , UCOL_NUMERIC_COLLATION = 7 , UCOL_ATTRIBUTE_COUNT = 8 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UColRuleOption { UCOL_TAILORING_ONLY = 0 , UCOL_FULL_RULES = 1 , } extern "C" { pub fn ucol_open_68 (loc : * const :: std :: os :: raw :: c_char , status : * mut UErrorCode) -> * mut UCollator ; } extern "C" { pub fn ucol_openRules_68 (rules : * const UChar , rulesLength : i32 , normalizationMode : UColAttributeValue , strength : UCollationStrength , parseError : * mut UParseError , status : * mut UErrorCode) -> * mut UCollator ; } extern "C" { pub fn ucol_openFromShortString_68 (definition : * const :: std :: os :: raw :: c_char , forceDefaults : UBool , parseError : * mut UParseError , status : * mut UErrorCode) -> * mut UCollator ; } extern "C" { pub fn ucol_getContractions_68 (coll : * const UCollator , conts : * mut USet , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucol_getContractionsAndExpansions_68 (coll : * const UCollator , contractions : * mut USet , expansions : * mut USet , addPrefixes : UBool , status : * mut UErrorCode) ; } extern "C" { pub fn ucol_close_68 (coll : * mut UCollator) ; } extern "C" { pub fn ucol_strcoll_68 (coll : * const UCollator , source : * const UChar , sourceLength : i32 , target : * const UChar , targetLength : i32) -> UCollationResult ; } extern "C" { pub fn ucol_strcollUTF8_68 (coll : * const UCollator , source : * const :: std :: os :: raw :: c_char , sourceLength : i32 , target : * const :: std :: os :: raw :: c_char , targetLength : i32 , status : * mut UErrorCode) -> UCollationResult ; } extern "C" { pub fn ucol_greater_68 (coll : * const UCollator , source : * const UChar , sourceLength : i32 , target : * const UChar , targetLength : i32) -> UBool ; } extern "C" { pub fn ucol_greaterOrEqual_68 (coll : * const UCollator , source : * const UChar , sourceLength : i32 , target : * const UChar , targetLength : i32) -> UBool ; } extern "C" { pub fn ucol_equal_68 (coll : * const UCollator , source : * const UChar , sourceLength : i32 , target : * const UChar , targetLength : i32) -> UBool ; } extern "C" { pub fn ucol_strcollIter_68 (coll : * const UCollator , sIter : * mut UCharIterator , tIter : * mut UCharIterator , status : * mut UErrorCode) -> UCollationResult ; } extern "C" { pub fn ucol_getStrength_68 (coll : * const UCollator) -> UCollationStrength ; } extern "C" { pub fn ucol_setStrength_68 (coll : * mut UCollator , strength : UCollationStrength) ; } extern "C" { pub fn ucol_getReorderCodes_68 (coll : * const UCollator , dest : * mut i32 , destCapacity : i32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucol_setReorderCodes_68 (coll : * mut UCollator , reorderCodes : * const i32 , reorderCodesLength : i32 , pErrorCode : * mut UErrorCode) ; } extern "C" { pub fn ucol_getEquivalentReorderCodes_68 (reorderCode : i32 , dest : * mut i32 , destCapacity : i32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucol_getDisplayName_68 (objLoc : * const :: std :: os :: raw :: c_char , dispLoc : * const :: std :: os :: raw :: c_char , result : * mut UChar , resultLength : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucol_getAvailable_68 (localeIndex : i32) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn ucol_countAvailable_68 () -> i32 ; } extern "C" { pub fn ucol_openAvailableLocales_68 (status : * mut UErrorCode) -> * mut UEnumeration ; } extern "C" { pub fn ucol_getKeywords_68 (status : * mut UErrorCode) -> * mut UEnumeration ; } extern "C" { pub fn ucol_getKeywordValues_68 (keyword : * const :: std :: os :: raw :: c_char , status : * mut UErrorCode) -> * mut UEnumeration ; } extern "C" { pub fn ucol_getKeywordValuesForLocale_68 (key : * const :: std :: os :: raw :: c_char , locale : * const :: std :: os :: raw :: c_char , commonlyUsed : UBool , status : * mut UErrorCode) -> * mut UEnumeration ; } extern "C" { pub fn ucol_getFunctionalEquivalent_68 (result : * mut :: std :: os :: raw :: c_char , resultCapacity : i32 , keyword : * const :: std :: os :: raw :: c_char , locale : * const :: std :: os :: raw :: c_char , isAvailable : * mut UBool , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucol_getRules_68 (coll : * const UCollator , length : * mut i32) -> * const UChar ; } extern "C" { pub fn ucol_getShortDefinitionString_68 (coll : * const UCollator , locale : * const :: std :: os :: raw :: c_char , buffer : * mut :: std :: os :: raw :: c_char , capacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucol_normalizeShortDefinitionString_68 (source : * const :: std :: os :: raw :: c_char , destination : * mut :: std :: os :: raw :: c_char , capacity : i32 , parseError : * mut UParseError , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucol_getSortKey_68 (coll : * const UCollator , source : * const UChar , sourceLength : i32 , result : * mut u8 , resultLength : i32) -> i32 ; } extern "C" { pub fn ucol_nextSortKeyPart_68 (coll : * const UCollator , iter : * mut UCharIterator , state : * mut u32 , dest : * mut u8 , count : i32 , status : * mut UErrorCode) -> i32 ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UColBoundMode { UCOL_BOUND_LOWER = 0 , UCOL_BOUND_UPPER = 1 , UCOL_BOUND_UPPER_LONG = 2 , UCOL_BOUND_VALUE_COUNT = 3 , } extern "C" { pub fn ucol_getBound_68 (source : * const u8 , sourceLength : i32 , boundType : UColBoundMode , noOfLevels : u32 , result : * mut u8 , resultLength : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucol_getVersion_68 (coll : * const UCollator , info : * mut u8) ; } extern "C" { pub fn ucol_getUCAVersion_68 (coll : * const UCollator , info : * mut u8) ; } extern "C" { pub fn ucol_mergeSortkeys_68 (src1 : * const u8 , src1Length : i32 , src2 : * const u8 , src2Length : i32 , dest : * mut u8 , destCapacity : i32) -> i32 ; } extern "C" { pub fn ucol_setAttribute_68 (coll : * mut UCollator , attr : UColAttribute , value : UColAttributeValue , status : * mut UErrorCode) ; } extern "C" { pub fn ucol_getAttribute_68 (coll : * const UCollator , attr : UColAttribute , status : * mut UErrorCode) -> UColAttributeValue ; } extern "C" { pub fn ucol_setMaxVariable_68 (coll : * mut UCollator , group : UColReorderCode , pErrorCode : * mut UErrorCode) ; } extern "C" { pub fn ucol_getMaxVariable_68 (coll : * const UCollator) -> UColReorderCode ; } extern "C" { pub fn ucol_setVariableTop_68 (coll : * mut UCollator , varTop : * const UChar , len : i32 , status : * mut UErrorCode) -> u32 ; } extern "C" { pub fn ucol_getVariableTop_68 (coll : * const UCollator , status : * mut UErrorCode) -> u32 ; } extern "C" { pub fn ucol_restoreVariableTop_68 (coll : * mut UCollator , varTop : u32 , status : * mut UErrorCode) ; } extern "C" { pub fn ucol_safeClone_68 (coll : * const UCollator , stackBuffer : * mut :: std :: os :: raw :: c_void , pBufferSize : * mut i32 , status : * mut UErrorCode) -> * mut UCollator ; } extern "C" { pub fn ucol_getRulesEx_68 (coll : * const UCollator , delta : UColRuleOption , buffer : * mut UChar , bufferLen : i32) -> i32 ; } extern "C" { pub fn ucol_getLocale_68 (coll : * const UCollator , type_ : ULocDataLocaleType , status : * mut UErrorCode) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn ucol_getLocaleByType_68 (coll : * const UCollator , type_ : ULocDataLocaleType , status : * mut UErrorCode) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn ucol_getTailoredSet_68 (coll : * const UCollator , status : * mut UErrorCode) -> * mut USet ; } extern "C" { pub fn ucol_getUnsafeSet_68 (coll : * const UCollator , unsafe_ : * mut USet , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucol_prepareShortStringOpen_68 (definition : * const :: std :: os :: raw :: c_char , forceDefaults : UBool , parseError : * mut UParseError , status : * mut UErrorCode) ; } extern "C" { pub fn ucol_cloneBinary_68 (coll : * const UCollator , buffer : * mut u8 , capacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ucol_openBinary_68 (bin : * const u8 , length : i32 , base : * const UCollator , status : * mut UErrorCode) -> * mut UCollator ; } # [repr (C)] # [derive (Debug , Default , Copy , Clone , Hash , PartialOrd , PartialEq)] pub struct UFieldPosition { pub field : i32 , pub beginIndex : i32 , pub endIndex : i32 , } # [test] fn bindgen_test_layout_UFieldPosition () { assert_eq ! (:: std :: mem :: size_of :: < UFieldPosition > () , 12usize , concat ! ("Size of: " , stringify ! (UFieldPosition))) ; assert_eq ! (:: std :: mem :: align_of :: < UFieldPosition > () , 4usize , concat ! ("Alignment of " , stringify ! (UFieldPosition))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UFieldPosition > ())) . field as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (UFieldPosition) , "::" , stringify ! (field))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UFieldPosition > ())) . beginIndex as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (UFieldPosition) , "::" , stringify ! (beginIndex))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UFieldPosition > ())) . endIndex as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (UFieldPosition) , "::" , stringify ! (endIndex))) ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UFormattableType { UFMT_DATE = 0 , UFMT_DOUBLE = 1 , UFMT_LONG = 2 , UFMT_STRING = 3 , UFMT_ARRAY = 4 , UFMT_INT64 = 5 , UFMT_OBJECT = 6 , UFMT_COUNT = 7 , } pub type UFormattable = * mut :: std :: os :: raw :: c_void ; extern "C" { pub fn ufmt_open_68 (status : * mut UErrorCode) -> * mut UFormattable ; } extern "C" { pub fn ufmt_close_68 (fmt : * mut UFormattable) ; } extern "C" { pub fn ufmt_getType_68 (fmt : * const UFormattable , status : * mut UErrorCode) -> UFormattableType ; } extern "C" { pub fn ufmt_isNumeric_68 (fmt : * const UFormattable) -> UBool ; } extern "C" { pub fn ufmt_getDate_68 (fmt : * const UFormattable , status : * mut UErrorCode) -> UDate ; } extern "C" { pub fn ufmt_getDouble_68 (fmt : * mut UFormattable , status : * mut UErrorCode) -> f64 ; } extern "C" { pub fn ufmt_getLong_68 (fmt : * mut UFormattable , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ufmt_getInt64_68 (fmt : * mut UFormattable , status : * mut UErrorCode) -> i64 ; } extern "C" { pub fn ufmt_getObject_68 (fmt : * const UFormattable , status : * mut UErrorCode) -> * const :: std :: os :: raw :: c_void ; } extern "C" { pub fn ufmt_getUChars_68 (fmt : * mut UFormattable , len : * mut i32 , status : * mut UErrorCode) -> * const UChar ; } extern "C" { pub fn ufmt_getArrayLength_68 (fmt : * const UFormattable , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ufmt_getArrayItemByIndex_68 (fmt : * mut UFormattable , n : i32 , status : * mut UErrorCode) -> * mut UFormattable ; } extern "C" { pub fn ufmt_getDecNumChars_68 (fmt : * mut UFormattable , len : * mut i32 , status : * mut UErrorCode) -> * const :: std :: os :: raw :: c_char ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UDisplayContextType { UDISPCTX_TYPE_DIALECT_HANDLING = 0 , UDISPCTX_TYPE_CAPITALIZATION = 1 , UDISPCTX_TYPE_DISPLAY_LENGTH = 2 , UDISPCTX_TYPE_SUBSTITUTE_HANDLING = 3 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UDisplayContext { UDISPCTX_STANDARD_NAMES = 0 , UDISPCTX_DIALECT_NAMES = 1 , UDISPCTX_CAPITALIZATION_NONE = 256 , UDISPCTX_CAPITALIZATION_FOR_MIDDLE_OF_SENTENCE = 257 , UDISPCTX_CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE = 258 , UDISPCTX_CAPITALIZATION_FOR_UI_LIST_OR_MENU = 259 , UDISPCTX_CAPITALIZATION_FOR_STANDALONE = 260 , UDISPCTX_LENGTH_FULL = 512 , UDISPCTX_LENGTH_SHORT = 513 , UDISPCTX_SUBSTITUTE = 768 , UDISPCTX_NO_SUBSTITUTE = 769 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct UFieldPositionIterator { _unused : [u8 ; 0] , } extern "C" { pub fn ufieldpositer_open_68 (status : * mut UErrorCode) -> * mut UFieldPositionIterator ; } extern "C" { pub fn ufieldpositer_close_68 (fpositer : * mut UFieldPositionIterator) ; } extern "C" { pub fn ufieldpositer_next_68 (fpositer : * mut UFieldPositionIterator , beginIndex : * mut i32 , endIndex : * mut i32) -> i32 ; } pub type UNumberFormat = * mut :: std :: os :: raw :: c_void ; impl UNumberFormatStyle { pub const UNUM_DEFAULT : UNumberFormatStyle = UNumberFormatStyle :: UNUM_DECIMAL ; } impl UNumberFormatStyle { pub const UNUM_IGNORE : UNumberFormatStyle = UNumberFormatStyle :: UNUM_PATTERN_DECIMAL ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UNumberFormatStyle { UNUM_PATTERN_DECIMAL = 0 , UNUM_DECIMAL = 1 , UNUM_CURRENCY = 2 , UNUM_PERCENT = 3 , UNUM_SCIENTIFIC = 4 , UNUM_SPELLOUT = 5 , UNUM_ORDINAL = 6 , UNUM_DURATION = 7 , UNUM_NUMBERING_SYSTEM = 8 , UNUM_PATTERN_RULEBASED = 9 , UNUM_CURRENCY_ISO = 10 , UNUM_CURRENCY_PLURAL = 11 , UNUM_CURRENCY_ACCOUNTING = 12 , UNUM_CASH_CURRENCY = 13 , UNUM_DECIMAL_COMPACT_SHORT = 14 , UNUM_DECIMAL_COMPACT_LONG = 15 , UNUM_CURRENCY_STANDARD = 16 , UNUM_FORMAT_STYLE_COUNT = 17 , } extern "C" { pub fn unum_open_68 (style : UNumberFormatStyle , pattern : * const UChar , patternLength : i32 , locale : * const :: std :: os :: raw :: c_char , parseErr : * mut UParseError , status : * mut UErrorCode) -> * mut UNumberFormat ; } extern "C" { pub fn unum_close_68 (fmt : * mut UNumberFormat) ; } extern "C" { pub fn unum_clone_68 (fmt : * const UNumberFormat , status : * mut UErrorCode) -> * mut UNumberFormat ; } extern "C" { pub fn unum_format_68 (fmt : * const UNumberFormat , number : i32 , result : * mut UChar , resultLength : i32 , pos : * mut UFieldPosition , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unum_formatInt64_68 (fmt : * const UNumberFormat , number : i64 , result : * mut UChar , resultLength : i32 , pos : * mut UFieldPosition , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unum_formatDouble_68 (fmt : * const UNumberFormat , number : f64 , result : * mut UChar , resultLength : i32 , pos : * mut UFieldPosition , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unum_formatDoubleForFields_68 (format : * const UNumberFormat , number : f64 , result : * mut UChar , resultLength : i32 , fpositer : * mut UFieldPositionIterator , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unum_formatDecimal_68 (fmt : * const UNumberFormat , number : * const :: std :: os :: raw :: c_char , length : i32 , result : * mut UChar , resultLength : i32 , pos : * mut UFieldPosition , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unum_formatDoubleCurrency_68 (fmt : * const UNumberFormat , number : f64 , currency : * mut UChar , result : * mut UChar , resultLength : i32 , pos : * mut UFieldPosition , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unum_formatUFormattable_68 (fmt : * const UNumberFormat , number : * const UFormattable , result : * mut UChar , resultLength : i32 , pos : * mut UFieldPosition , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unum_parse_68 (fmt : * const UNumberFormat , text : * const UChar , textLength : i32 , parsePos : * mut i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unum_parseInt64_68 (fmt : * const UNumberFormat , text : * const UChar , textLength : i32 , parsePos : * mut i32 , status : * mut UErrorCode) -> i64 ; } extern "C" { pub fn unum_parseDouble_68 (fmt : * const UNumberFormat , text : * const UChar , textLength : i32 , parsePos : * mut i32 , status : * mut UErrorCode) -> f64 ; } extern "C" { pub fn unum_parseDecimal_68 (fmt : * const UNumberFormat , text : * const UChar , textLength : i32 , parsePos : * mut i32 , outBuf : * mut :: std :: os :: raw :: c_char , outBufLength : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unum_parseDoubleCurrency_68 (fmt : * const UNumberFormat , text : * const UChar , textLength : i32 , parsePos : * mut i32 , currency : * mut UChar , status : * mut UErrorCode) -> f64 ; } extern "C" { pub fn unum_parseToUFormattable_68 (fmt : * const UNumberFormat , result : * mut UFormattable , text : * const UChar , textLength : i32 , parsePos : * mut i32 , status : * mut UErrorCode) -> * mut UFormattable ; } extern "C" { pub fn unum_applyPattern_68 (format : * mut UNumberFormat , localized : UBool , pattern : * const UChar , patternLength : i32 , parseError : * mut UParseError , status : * mut UErrorCode) ; } extern "C" { pub fn unum_getAvailable_68 (localeIndex : i32) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn unum_countAvailable_68 () -> i32 ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UNumberFormatAttribute { UNUM_PARSE_INT_ONLY = 0 , UNUM_GROUPING_USED = 1 , UNUM_DECIMAL_ALWAYS_SHOWN = 2 , UNUM_MAX_INTEGER_DIGITS = 3 , UNUM_MIN_INTEGER_DIGITS = 4 , UNUM_INTEGER_DIGITS = 5 , UNUM_MAX_FRACTION_DIGITS = 6 , UNUM_MIN_FRACTION_DIGITS = 7 , UNUM_FRACTION_DIGITS = 8 , UNUM_MULTIPLIER = 9 , UNUM_GROUPING_SIZE = 10 , UNUM_ROUNDING_MODE = 11 , UNUM_ROUNDING_INCREMENT = 12 , UNUM_FORMAT_WIDTH = 13 , UNUM_PADDING_POSITION = 14 , UNUM_SECONDARY_GROUPING_SIZE = 15 , UNUM_SIGNIFICANT_DIGITS_USED = 16 , UNUM_MIN_SIGNIFICANT_DIGITS = 17 , UNUM_MAX_SIGNIFICANT_DIGITS = 18 , UNUM_LENIENT_PARSE = 19 , UNUM_PARSE_ALL_INPUT = 20 , UNUM_SCALE = 21 , UNUM_MINIMUM_GROUPING_DIGITS = 22 , UNUM_CURRENCY_USAGE = 23 , UNUM_MAX_NONBOOLEAN_ATTRIBUTE = 4095 , UNUM_FORMAT_FAIL_IF_MORE_THAN_MAX_DIGITS = 4096 , UNUM_PARSE_NO_EXPONENT = 4097 , UNUM_PARSE_DECIMAL_MARK_REQUIRED = 4098 , UNUM_PARSE_CASE_SENSITIVE = 4099 , UNUM_SIGN_ALWAYS_SHOWN = 4100 , UNUM_LIMIT_BOOLEAN_ATTRIBUTE = 4101 , } extern "C" { pub fn unum_getAttribute_68 (fmt : * const UNumberFormat , attr : UNumberFormatAttribute) -> i32 ; } extern "C" { pub fn unum_setAttribute_68 (fmt : * mut UNumberFormat , attr : UNumberFormatAttribute , newValue : i32) ; } extern "C" { pub fn unum_getDoubleAttribute_68 (fmt : * const UNumberFormat , attr : UNumberFormatAttribute) -> f64 ; } extern "C" { pub fn unum_setDoubleAttribute_68 (fmt : * mut UNumberFormat , attr : UNumberFormatAttribute , newValue : f64) ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UNumberFormatTextAttribute { UNUM_POSITIVE_PREFIX = 0 , UNUM_POSITIVE_SUFFIX = 1 , UNUM_NEGATIVE_PREFIX = 2 , UNUM_NEGATIVE_SUFFIX = 3 , UNUM_PADDING_CHARACTER = 4 , UNUM_CURRENCY_CODE = 5 , UNUM_DEFAULT_RULESET = 6 , UNUM_PUBLIC_RULESETS = 7 , } extern "C" { pub fn unum_getTextAttribute_68 (fmt : * const UNumberFormat , tag : UNumberFormatTextAttribute , result : * mut UChar , resultLength : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unum_setTextAttribute_68 (fmt : * mut UNumberFormat , tag : UNumberFormatTextAttribute , newValue : * const UChar , newValueLength : i32 , status : * mut UErrorCode) ; } extern "C" { pub fn unum_toPattern_68 (fmt : * const UNumberFormat , isPatternLocalized : UBool , result : * mut UChar , resultLength : i32 , status : * mut UErrorCode) -> i32 ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UNumberFormatSymbol { UNUM_DECIMAL_SEPARATOR_SYMBOL = 0 , UNUM_GROUPING_SEPARATOR_SYMBOL = 1 , UNUM_PATTERN_SEPARATOR_SYMBOL = 2 , UNUM_PERCENT_SYMBOL = 3 , UNUM_ZERO_DIGIT_SYMBOL = 4 , UNUM_DIGIT_SYMBOL = 5 , UNUM_MINUS_SIGN_SYMBOL = 6 , UNUM_PLUS_SIGN_SYMBOL = 7 , UNUM_CURRENCY_SYMBOL = 8 , UNUM_INTL_CURRENCY_SYMBOL = 9 , UNUM_MONETARY_SEPARATOR_SYMBOL = 10 , UNUM_EXPONENTIAL_SYMBOL = 11 , UNUM_PERMILL_SYMBOL = 12 , UNUM_PAD_ESCAPE_SYMBOL = 13 , UNUM_INFINITY_SYMBOL = 14 , UNUM_NAN_SYMBOL = 15 , UNUM_SIGNIFICANT_DIGIT_SYMBOL = 16 , UNUM_MONETARY_GROUPING_SEPARATOR_SYMBOL = 17 , UNUM_ONE_DIGIT_SYMBOL = 18 , UNUM_TWO_DIGIT_SYMBOL = 19 , UNUM_THREE_DIGIT_SYMBOL = 20 , UNUM_FOUR_DIGIT_SYMBOL = 21 , UNUM_FIVE_DIGIT_SYMBOL = 22 , UNUM_SIX_DIGIT_SYMBOL = 23 , UNUM_SEVEN_DIGIT_SYMBOL = 24 , UNUM_EIGHT_DIGIT_SYMBOL = 25 , UNUM_NINE_DIGIT_SYMBOL = 26 , UNUM_EXPONENT_MULTIPLICATION_SYMBOL = 27 , UNUM_FORMAT_SYMBOL_COUNT = 28 , } extern "C" { pub fn unum_getSymbol_68 (fmt : * const UNumberFormat , symbol : UNumberFormatSymbol , buffer : * mut UChar , size : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unum_setSymbol_68 (fmt : * mut UNumberFormat , symbol : UNumberFormatSymbol , value : * const UChar , length : i32 , status : * mut UErrorCode) ; } extern "C" { pub fn unum_getLocaleByType_68 (fmt : * const UNumberFormat , type_ : ULocDataLocaleType , status : * mut UErrorCode) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn unum_setContext_68 (fmt : * mut UNumberFormat , value : UDisplayContext , status : * mut UErrorCode) ; } extern "C" { pub fn unum_getContext_68 (fmt : * const UNumberFormat , type_ : UDisplayContextType , status : * mut UErrorCode) -> UDisplayContext ; } pub type UDateFormat = * mut :: std :: os :: raw :: c_void ; impl UDateFormatStyle { pub const UDAT_DEFAULT : UDateFormatStyle = UDateFormatStyle :: UDAT_MEDIUM ; } impl UDateFormatStyle { pub const UDAT_FULL_RELATIVE : UDateFormatStyle = UDateFormatStyle :: UDAT_RELATIVE ; } impl UDateFormatStyle { pub const UDAT_IGNORE : UDateFormatStyle = UDateFormatStyle :: UDAT_PATTERN ; } # [repr (i32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UDateFormatStyle { UDAT_FULL = 0 , UDAT_LONG = 1 , UDAT_MEDIUM = 2 , UDAT_SHORT = 3 , UDAT_RELATIVE = 128 , UDAT_LONG_RELATIVE = 129 , UDAT_MEDIUM_RELATIVE = 130 , UDAT_SHORT_RELATIVE = 131 , UDAT_NONE = - 1 , UDAT_PATTERN = - 2 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UDateFormatField { UDAT_ERA_FIELD = 0 , UDAT_YEAR_FIELD = 1 , UDAT_MONTH_FIELD = 2 , UDAT_DATE_FIELD = 3 , UDAT_HOUR_OF_DAY1_FIELD = 4 , UDAT_HOUR_OF_DAY0_FIELD = 5 , UDAT_MINUTE_FIELD = 6 , UDAT_SECOND_FIELD = 7 , UDAT_FRACTIONAL_SECOND_FIELD = 8 , UDAT_DAY_OF_WEEK_FIELD = 9 , UDAT_DAY_OF_YEAR_FIELD = 10 , UDAT_DAY_OF_WEEK_IN_MONTH_FIELD = 11 , UDAT_WEEK_OF_YEAR_FIELD = 12 , UDAT_WEEK_OF_MONTH_FIELD = 13 , UDAT_AM_PM_FIELD = 14 , UDAT_HOUR1_FIELD = 15 , UDAT_HOUR0_FIELD = 16 , UDAT_TIMEZONE_FIELD = 17 , UDAT_YEAR_WOY_FIELD = 18 , UDAT_DOW_LOCAL_FIELD = 19 , UDAT_EXTENDED_YEAR_FIELD = 20 , UDAT_JULIAN_DAY_FIELD = 21 , UDAT_MILLISECONDS_IN_DAY_FIELD = 22 , UDAT_TIMEZONE_RFC_FIELD = 23 , UDAT_TIMEZONE_GENERIC_FIELD = 24 , UDAT_STANDALONE_DAY_FIELD = 25 , UDAT_STANDALONE_MONTH_FIELD = 26 , UDAT_QUARTER_FIELD = 27 , UDAT_STANDALONE_QUARTER_FIELD = 28 , UDAT_TIMEZONE_SPECIAL_FIELD = 29 , UDAT_YEAR_NAME_FIELD = 30 , UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD = 31 , UDAT_TIMEZONE_ISO_FIELD = 32 , UDAT_TIMEZONE_ISO_LOCAL_FIELD = 33 , UDAT_RELATED_YEAR_FIELD = 34 , UDAT_AM_PM_MIDNIGHT_NOON_FIELD = 35 , UDAT_FLEXIBLE_DAY_PERIOD_FIELD = 36 , UDAT_TIME_SEPARATOR_FIELD = 37 , UDAT_FIELD_COUNT = 38 , } extern "C" { pub fn udat_toCalendarDateField_68 (field : UDateFormatField) -> UCalendarDateFields ; } extern "C" { pub fn udat_open_68 (timeStyle : UDateFormatStyle , dateStyle : UDateFormatStyle , locale : * const :: std :: os :: raw :: c_char , tzID : * const UChar , tzIDLength : i32 , pattern : * const UChar , patternLength : i32 , status : * mut UErrorCode) -> * mut UDateFormat ; } extern "C" { pub fn udat_close_68 (format : * mut UDateFormat) ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UDateFormatBooleanAttribute { UDAT_PARSE_ALLOW_WHITESPACE = 0 , UDAT_PARSE_ALLOW_NUMERIC = 1 , UDAT_PARSE_PARTIAL_LITERAL_MATCH = 2 , UDAT_PARSE_MULTIPLE_PATTERNS_FOR_MATCH = 3 , UDAT_BOOLEAN_ATTRIBUTE_COUNT = 4 , } extern "C" { pub fn udat_getBooleanAttribute_68 (fmt : * const UDateFormat , attr : UDateFormatBooleanAttribute , status : * mut UErrorCode) -> UBool ; } extern "C" { pub fn udat_setBooleanAttribute_68 (fmt : * mut UDateFormat , attr : UDateFormatBooleanAttribute , newValue : UBool , status : * mut UErrorCode) ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UDateFormatHourCycle { UDAT_HOUR_CYCLE_11 = 0 , UDAT_HOUR_CYCLE_12 = 1 , UDAT_HOUR_CYCLE_23 = 2 , UDAT_HOUR_CYCLE_24 = 3 , } extern "C" { pub fn udat_clone_68 (fmt : * const UDateFormat , status : * mut UErrorCode) -> * mut UDateFormat ; } extern "C" { pub fn udat_format_68 (format : * const UDateFormat , dateToFormat : UDate , result : * mut UChar , resultLength : i32 , position : * mut UFieldPosition , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn udat_formatCalendar_68 (format : * const UDateFormat , calendar : * mut UCalendar , result : * mut UChar , capacity : i32 , position : * mut UFieldPosition , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn udat_formatForFields_68 (format : * const UDateFormat , dateToFormat : UDate , result : * mut UChar , resultLength : i32 , fpositer : * mut UFieldPositionIterator , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn udat_formatCalendarForFields_68 (format : * const UDateFormat , calendar : * mut UCalendar , result : * mut UChar , capacity : i32 , fpositer : * mut UFieldPositionIterator , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn udat_parse_68 (format : * const UDateFormat , text : * const UChar , textLength : i32 , parsePos : * mut i32 , status : * mut UErrorCode) -> UDate ; } extern "C" { pub fn udat_parseCalendar_68 (format : * const UDateFormat , calendar : * mut UCalendar , text : * const UChar , textLength : i32 , parsePos : * mut i32 , status : * mut UErrorCode) ; } extern "C" { pub fn udat_isLenient_68 (fmt : * const UDateFormat) -> UBool ; } extern "C" { pub fn udat_setLenient_68 (fmt : * mut UDateFormat , isLenient : UBool) ; } extern "C" { pub fn udat_getCalendar_68 (fmt : * const UDateFormat) -> * const UCalendar ; } extern "C" { pub fn udat_setCalendar_68 (fmt : * mut UDateFormat , calendarToSet : * const UCalendar) ; } extern "C" { pub fn udat_getNumberFormat_68 (fmt : * const UDateFormat) -> * const UNumberFormat ; } extern "C" { pub fn udat_getNumberFormatForField_68 (fmt : * const UDateFormat , field : UChar) -> * const UNumberFormat ; } extern "C" { pub fn udat_adoptNumberFormatForFields_68 (fmt : * mut UDateFormat , fields : * const UChar , numberFormatToSet : * mut UNumberFormat , status : * mut UErrorCode) ; } extern "C" { pub fn udat_setNumberFormat_68 (fmt : * mut UDateFormat , numberFormatToSet : * const UNumberFormat) ; } extern "C" { pub fn udat_adoptNumberFormat_68 (fmt : * mut UDateFormat , numberFormatToAdopt : * mut UNumberFormat) ; } extern "C" { pub fn udat_getAvailable_68 (localeIndex : i32) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn udat_countAvailable_68 () -> i32 ; } extern "C" { pub fn udat_get2DigitYearStart_68 (fmt : * const UDateFormat , status : * mut UErrorCode) -> UDate ; } extern "C" { pub fn udat_set2DigitYearStart_68 (fmt : * mut UDateFormat , d : UDate , status : * mut UErrorCode) ; } extern "C" { pub fn udat_toPattern_68 (fmt : * const UDateFormat , localized : UBool , result : * mut UChar , resultLength : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn udat_applyPattern_68 (format : * mut UDateFormat , localized : UBool , pattern : * const UChar , patternLength : i32) ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UDateFormatSymbolType { UDAT_ERAS = 0 , UDAT_MONTHS = 1 , UDAT_SHORT_MONTHS = 2 , UDAT_WEEKDAYS = 3 , UDAT_SHORT_WEEKDAYS = 4 , UDAT_AM_PMS = 5 , UDAT_LOCALIZED_CHARS = 6 , UDAT_ERA_NAMES = 7 , UDAT_NARROW_MONTHS = 8 , UDAT_NARROW_WEEKDAYS = 9 , UDAT_STANDALONE_MONTHS = 10 , UDAT_STANDALONE_SHORT_MONTHS = 11 , UDAT_STANDALONE_NARROW_MONTHS = 12 , UDAT_STANDALONE_WEEKDAYS = 13 , UDAT_STANDALONE_SHORT_WEEKDAYS = 14 , UDAT_STANDALONE_NARROW_WEEKDAYS = 15 , UDAT_QUARTERS = 16 , UDAT_SHORT_QUARTERS = 17 , UDAT_STANDALONE_QUARTERS = 18 , UDAT_STANDALONE_SHORT_QUARTERS = 19 , UDAT_SHORTER_WEEKDAYS = 20 , UDAT_STANDALONE_SHORTER_WEEKDAYS = 21 , UDAT_CYCLIC_YEARS_WIDE = 22 , UDAT_CYCLIC_YEARS_ABBREVIATED = 23 , UDAT_CYCLIC_YEARS_NARROW = 24 , UDAT_ZODIAC_NAMES_WIDE = 25 , UDAT_ZODIAC_NAMES_ABBREVIATED = 26 , UDAT_ZODIAC_NAMES_NARROW = 27 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct UDateFormatSymbols { _unused : [u8 ; 0] , } extern "C" { pub fn udat_getSymbols_68 (fmt : * const UDateFormat , type_ : UDateFormatSymbolType , symbolIndex : i32 , result : * mut UChar , resultLength : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn udat_countSymbols_68 (fmt : * const UDateFormat , type_ : UDateFormatSymbolType) -> i32 ; } extern "C" { pub fn udat_setSymbols_68 (format : * mut UDateFormat , type_ : UDateFormatSymbolType , symbolIndex : i32 , value : * mut UChar , valueLength : i32 , status : * mut UErrorCode) ; } extern "C" { pub fn udat_getLocaleByType_68 (fmt : * const UDateFormat , type_ : ULocDataLocaleType , status : * mut UErrorCode) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn udat_setContext_68 (fmt : * mut UDateFormat , value : UDisplayContext , status : * mut UErrorCode) ; } extern "C" { pub fn udat_getContext_68 (fmt : * const UDateFormat , type_ : UDisplayContextType , status : * mut UErrorCode) -> UDisplayContext ; } extern "C" { pub fn udat_toPatternRelativeDate_68 (fmt : * const UDateFormat , result : * mut UChar , resultLength : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn udat_toPatternRelativeTime_68 (fmt : * const UDateFormat , result : * mut UChar , resultLength : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn udat_applyPatternRelative_68 (format : * mut UDateFormat , datePattern : * const UChar , datePatternLength : i32 , timePattern : * const UChar , timePatternLength : i32 , status : * mut UErrorCode) ; } pub type UDateFormatOpener = :: std :: option :: Option < unsafe extern "C" fn (timeStyle : UDateFormatStyle , dateStyle : UDateFormatStyle , locale : * const :: std :: os :: raw :: c_char , tzID : * const UChar , tzIDLength : i32 , pattern : * const UChar , patternLength : i32 , status : * mut UErrorCode) -> * mut UDateFormat > ; extern "C" { pub fn udat_registerOpener_68 (opener : UDateFormatOpener , status : * mut UErrorCode) ; } extern "C" { pub fn udat_unregisterOpener_68 (opener : UDateFormatOpener , status : * mut UErrorCode) -> UDateFormatOpener ; } pub type UDateTimePatternGenerator = * mut :: std :: os :: raw :: c_void ; # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UDateTimePatternField { UDATPG_ERA_FIELD = 0 , UDATPG_YEAR_FIELD = 1 , UDATPG_QUARTER_FIELD = 2 , UDATPG_MONTH_FIELD = 3 , UDATPG_WEEK_OF_YEAR_FIELD = 4 , UDATPG_WEEK_OF_MONTH_FIELD = 5 , UDATPG_WEEKDAY_FIELD = 6 , UDATPG_DAY_OF_YEAR_FIELD = 7 , UDATPG_DAY_OF_WEEK_IN_MONTH_FIELD = 8 , UDATPG_DAY_FIELD = 9 , UDATPG_DAYPERIOD_FIELD = 10 , UDATPG_HOUR_FIELD = 11 , UDATPG_MINUTE_FIELD = 12 , UDATPG_SECOND_FIELD = 13 , UDATPG_FRACTIONAL_SECOND_FIELD = 14 , UDATPG_ZONE_FIELD = 15 , UDATPG_FIELD_COUNT = 16 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UDateTimePGDisplayWidth { UDATPG_WIDE = 0 , UDATPG_ABBREVIATED = 1 , UDATPG_NARROW = 2 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UDateTimePatternMatchOptions { UDATPG_MATCH_NO_OPTIONS = 0 , UDATPG_MATCH_HOUR_FIELD_LENGTH = 2048 , UDATPG_MATCH_MINUTE_FIELD_LENGTH = 4096 , UDATPG_MATCH_SECOND_FIELD_LENGTH = 8192 , UDATPG_MATCH_ALL_FIELDS_LENGTH = 65535 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UDateTimePatternConflict { UDATPG_NO_CONFLICT = 0 , UDATPG_BASE_CONFLICT = 1 , UDATPG_CONFLICT = 2 , UDATPG_CONFLICT_COUNT = 3 , } extern "C" { pub fn udatpg_open_68 (locale : * const :: std :: os :: raw :: c_char , pErrorCode : * mut UErrorCode) -> * mut UDateTimePatternGenerator ; } extern "C" { pub fn udatpg_openEmpty_68 (pErrorCode : * mut UErrorCode) -> * mut UDateTimePatternGenerator ; } extern "C" { pub fn udatpg_close_68 (dtpg : * mut UDateTimePatternGenerator) ; } extern "C" { pub fn udatpg_clone_68 (dtpg : * const UDateTimePatternGenerator , pErrorCode : * mut UErrorCode) -> * mut UDateTimePatternGenerator ; } extern "C" { pub fn udatpg_getBestPattern_68 (dtpg : * mut UDateTimePatternGenerator , skeleton : * const UChar , length : i32 , bestPattern : * mut UChar , capacity : i32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn udatpg_getBestPatternWithOptions_68 (dtpg : * mut UDateTimePatternGenerator , skeleton : * const UChar , length : i32 , options : UDateTimePatternMatchOptions , bestPattern : * mut UChar , capacity : i32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn udatpg_getSkeleton_68 (unusedDtpg : * mut UDateTimePatternGenerator , pattern : * const UChar , length : i32 , skeleton : * mut UChar , capacity : i32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn udatpg_getBaseSkeleton_68 (unusedDtpg : * mut UDateTimePatternGenerator , pattern : * const UChar , length : i32 , baseSkeleton : * mut UChar , capacity : i32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn udatpg_addPattern_68 (dtpg : * mut UDateTimePatternGenerator , pattern : * const UChar , patternLength : i32 , override_ : UBool , conflictingPattern : * mut UChar , capacity : i32 , pLength : * mut i32 , pErrorCode : * mut UErrorCode) -> UDateTimePatternConflict ; } extern "C" { pub fn udatpg_setAppendItemFormat_68 (dtpg : * mut UDateTimePatternGenerator , field : UDateTimePatternField , value : * const UChar , length : i32) ; } extern "C" { pub fn udatpg_getAppendItemFormat_68 (dtpg : * const UDateTimePatternGenerator , field : UDateTimePatternField , pLength : * mut i32) -> * const UChar ; } extern "C" { pub fn udatpg_setAppendItemName_68 (dtpg : * mut UDateTimePatternGenerator , field : UDateTimePatternField , value : * const UChar , length : i32) ; } extern "C" { pub fn udatpg_getAppendItemName_68 (dtpg : * const UDateTimePatternGenerator , field : UDateTimePatternField , pLength : * mut i32) -> * const UChar ; } extern "C" { pub fn udatpg_getFieldDisplayName_68 (dtpg : * const UDateTimePatternGenerator , field : UDateTimePatternField , width : UDateTimePGDisplayWidth , fieldName : * mut UChar , capacity : i32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn udatpg_setDateTimeFormat_68 (dtpg : * const UDateTimePatternGenerator , dtFormat : * const UChar , length : i32) ; } extern "C" { pub fn udatpg_getDateTimeFormat_68 (dtpg : * const UDateTimePatternGenerator , pLength : * mut i32) -> * const UChar ; } extern "C" { pub fn udatpg_setDecimal_68 (dtpg : * mut UDateTimePatternGenerator , decimal : * const UChar , length : i32) ; } extern "C" { pub fn udatpg_getDecimal_68 (dtpg : * const UDateTimePatternGenerator , pLength : * mut i32) -> * const UChar ; } extern "C" { pub fn udatpg_replaceFieldTypes_68 (dtpg : * mut UDateTimePatternGenerator , pattern : * const UChar , patternLength : i32 , skeleton : * const UChar , skeletonLength : i32 , dest : * mut UChar , destCapacity : i32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn udatpg_replaceFieldTypesWithOptions_68 (dtpg : * mut UDateTimePatternGenerator , pattern : * const UChar , patternLength : i32 , skeleton : * const UChar , skeletonLength : i32 , options : UDateTimePatternMatchOptions , dest : * mut UChar , destCapacity : i32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn udatpg_openSkeletons_68 (dtpg : * const UDateTimePatternGenerator , pErrorCode : * mut UErrorCode) -> * mut UEnumeration ; } extern "C" { pub fn udatpg_openBaseSkeletons_68 (dtpg : * const UDateTimePatternGenerator , pErrorCode : * mut UErrorCode) -> * mut UEnumeration ; } extern "C" { pub fn udatpg_getPatternForSkeleton_68 (dtpg : * const UDateTimePatternGenerator , skeleton : * const UChar , skeletonLength : i32 , pLength : * mut i32) -> * const UChar ; } extern "C" { pub fn udatpg_getDefaultHourCycle_68 (dtpg : * const UDateTimePatternGenerator , pErrorCode : * mut UErrorCode) -> UDateFormatHourCycle ; } # [repr (C)] # [derive (Debug , Default , Copy , Clone , Hash , PartialOrd , PartialEq)] pub struct UDataInfo { pub size : u16 , pub reservedWord : u16 , pub isBigEndian : u8 , pub charsetFamily : u8 , pub sizeofUChar : u8 , pub reservedByte : u8 , pub dataFormat : [u8 ; 4usize] , pub formatVersion : [u8 ; 4usize] , pub dataVersion : [u8 ; 4usize] , } # [test] fn bindgen_test_layout_UDataInfo () { assert_eq ! (:: std :: mem :: size_of :: < UDataInfo > () , 20usize , concat ! ("Size of: " , stringify ! (UDataInfo))) ; assert_eq ! (:: std :: mem :: align_of :: < UDataInfo > () , 2usize , concat ! ("Alignment of " , stringify ! (UDataInfo))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UDataInfo > ())) . size as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (UDataInfo) , "::" , stringify ! (size))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UDataInfo > ())) . reservedWord as * const _ as usize } , 2usize , concat ! ("Offset of field: " , stringify ! (UDataInfo) , "::" , stringify ! (reservedWord))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UDataInfo > ())) . isBigEndian as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (UDataInfo) , "::" , stringify ! (isBigEndian))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UDataInfo > ())) . charsetFamily as * const _ as usize } , 5usize , concat ! ("Offset of field: " , stringify ! (UDataInfo) , "::" , stringify ! (charsetFamily))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UDataInfo > ())) . sizeofUChar as * const _ as usize } , 6usize , concat ! ("Offset of field: " , stringify ! (UDataInfo) , "::" , stringify ! (sizeofUChar))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UDataInfo > ())) . reservedByte as * const _ as usize } , 7usize , concat ! ("Offset of field: " , stringify ! (UDataInfo) , "::" , stringify ! (reservedByte))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UDataInfo > ())) . dataFormat as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (UDataInfo) , "::" , stringify ! (dataFormat))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UDataInfo > ())) . formatVersion as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (UDataInfo) , "::" , stringify ! (formatVersion))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UDataInfo > ())) . dataVersion as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (UDataInfo) , "::" , stringify ! (dataVersion))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct UDataMemory { _unused : [u8 ; 0] , } pub type UDataMemoryIsAcceptable = :: std :: option :: Option < unsafe extern "C" fn (context : * mut :: std :: os :: raw :: c_void , type_ : * const :: std :: os :: raw :: c_char , name : * const :: std :: os :: raw :: c_char , pInfo : * const UDataInfo) -> UBool > ; extern "C" { pub fn udata_open_68 (path : * const :: std :: os :: raw :: c_char , type_ : * const :: std :: os :: raw :: c_char , name : * const :: std :: os :: raw :: c_char , pErrorCode : * mut UErrorCode) -> * mut UDataMemory ; } extern "C" { pub fn udata_openChoice_68 (path : * const :: std :: os :: raw :: c_char , type_ : * const :: std :: os :: raw :: c_char , name : * const :: std :: os :: raw :: c_char , isAcceptable : UDataMemoryIsAcceptable , context : * mut :: std :: os :: raw :: c_void , pErrorCode : * mut UErrorCode) -> * mut UDataMemory ; } extern "C" { pub fn udata_close_68 (pData : * mut UDataMemory) ; } extern "C" { pub fn udata_getMemory_68 (pData : * mut UDataMemory) -> * const :: std :: os :: raw :: c_void ; } extern "C" { pub fn udata_getInfo_68 (pData : * mut UDataMemory , pInfo : * mut UDataInfo) ; } extern "C" { pub fn udata_setCommonData_68 (data : * const :: std :: os :: raw :: c_void , err : * mut UErrorCode) ; } extern "C" { pub fn udata_setAppData_68 (packageName : * const :: std :: os :: raw :: c_char , data : * const :: std :: os :: raw :: c_void , err : * mut UErrorCode) ; } impl UDataFileAccess { pub const UDATA_DEFAULT_ACCESS : UDataFileAccess = UDataFileAccess :: UDATA_FILES_FIRST ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UDataFileAccess { UDATA_FILES_FIRST = 0 , UDATA_ONLY_PACKAGES = 1 , UDATA_PACKAGES_FIRST = 2 , UDATA_NO_FILES = 3 , UDATA_FILE_ACCESS_COUNT = 4 , } extern "C" { pub fn udata_setFileAccess_68 (access : UDataFileAccess , status : * mut UErrorCode) ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UFieldCategory { UFIELD_CATEGORY_UNDEFINED = 0 , UFIELD_CATEGORY_DATE = 1 , UFIELD_CATEGORY_NUMBER = 2 , UFIELD_CATEGORY_LIST = 3 , UFIELD_CATEGORY_RELATIVE_DATETIME = 4 , UFIELD_CATEGORY_DATE_INTERVAL = 5 , UFIELD_CATEGORY_COUNT = 6 , UFIELD_CATEGORY_LIST_SPAN = 4099 , UFIELD_CATEGORY_DATE_INTERVAL_SPAN = 4101 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct UFormattedValue { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct UListFormatter { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct UFormattedList { _unused : [u8 ; 0] , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UListFormatterField { ULISTFMT_LITERAL_FIELD = 0 , ULISTFMT_ELEMENT_FIELD = 1 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UListFormatterType { ULISTFMT_TYPE_AND = 0 , ULISTFMT_TYPE_OR = 1 , ULISTFMT_TYPE_UNITS = 2 , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UListFormatterWidth { ULISTFMT_WIDTH_WIDE = 0 , ULISTFMT_WIDTH_SHORT = 1 , ULISTFMT_WIDTH_NARROW = 2 , } extern "C" { pub fn ulistfmt_open_68 (locale : * const :: std :: os :: raw :: c_char , status : * mut UErrorCode) -> * mut UListFormatter ; } extern "C" { pub fn ulistfmt_openForType_68 (locale : * const :: std :: os :: raw :: c_char , type_ : UListFormatterType , width : UListFormatterWidth , status : * mut UErrorCode) -> * mut UListFormatter ; } extern "C" { pub fn ulistfmt_close_68 (listfmt : * mut UListFormatter) ; } extern "C" { pub fn ulistfmt_openResult_68 (ec : * mut UErrorCode) -> * mut UFormattedList ; } extern "C" { pub fn ulistfmt_resultAsValue_68 (uresult : * const UFormattedList , ec : * mut UErrorCode) -> * const UFormattedValue ; } extern "C" { pub fn ulistfmt_closeResult_68 (uresult : * mut UFormattedList) ; } extern "C" { pub fn ulistfmt_format_68 (listfmt : * const UListFormatter , strings : * const * const UChar , stringLengths : * const i32 , stringCount : i32 , result : * mut UChar , resultCapacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn ulistfmt_formatStringsToResult_68 (listfmt : * const UListFormatter , strings : * const * const UChar , stringLengths : * const i32 , stringCount : i32 , uresult : * mut UFormattedList , status : * mut UErrorCode) ; } pub type va_list = __builtin_va_list ; extern "C" { pub fn u_formatMessage_68 (locale : * const :: std :: os :: raw :: c_char , pattern : * const UChar , patternLength : i32 , result : * mut UChar , resultLength : i32 , status : * mut UErrorCode , ...) -> i32 ; } extern "C" { pub fn u_vformatMessage_68 (locale : * const :: std :: os :: raw :: c_char , pattern : * const UChar , patternLength : i32 , result : * mut UChar , resultLength : i32 , ap : * mut __va_list_tag , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn u_parseMessage_68 (locale : * const :: std :: os :: raw :: c_char , pattern : * const UChar , patternLength : i32 , source : * const UChar , sourceLength : i32 , status : * mut UErrorCode , ...) ; } extern "C" { pub fn u_vparseMessage_68 (locale : * const :: std :: os :: raw :: c_char , pattern : * const UChar , patternLength : i32 , source : * const UChar , sourceLength : i32 , ap : * mut __va_list_tag , status : * mut UErrorCode) ; } extern "C" { pub fn u_formatMessageWithError_68 (locale : * const :: std :: os :: raw :: c_char , pattern : * const UChar , patternLength : i32 , result : * mut UChar , resultLength : i32 , parseError : * mut UParseError , status : * mut UErrorCode , ...) -> i32 ; } extern "C" { pub fn u_vformatMessageWithError_68 (locale : * const :: std :: os :: raw :: c_char , pattern : * const UChar , patternLength : i32 , result : * mut UChar , resultLength : i32 , parseError : * mut UParseError , ap : * mut __va_list_tag , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn u_parseMessageWithError_68 (locale : * const :: std :: os :: raw :: c_char , pattern : * const UChar , patternLength : i32 , source : * const UChar , sourceLength : i32 , parseError : * mut UParseError , status : * mut UErrorCode , ...) ; } extern "C" { pub fn u_vparseMessageWithError_68 (locale : * const :: std :: os :: raw :: c_char , pattern : * const UChar , patternLength : i32 , source : * const UChar , sourceLength : i32 , ap : * mut __va_list_tag , parseError : * mut UParseError , status : * mut UErrorCode) ; } pub type UMessageFormat = * mut :: std :: os :: raw :: c_void ; extern "C" { pub fn umsg_open_68 (pattern : * const UChar , patternLength : i32 , locale : * const :: std :: os :: raw :: c_char , parseError : * mut UParseError , status : * mut UErrorCode) -> * mut UMessageFormat ; } extern "C" { pub fn umsg_close_68 (format : * mut UMessageFormat) ; } extern "C" { pub fn umsg_clone_68 (fmt : * const UMessageFormat , status : * mut UErrorCode) -> UMessageFormat ; } extern "C" { pub fn umsg_setLocale_68 (fmt : * mut UMessageFormat , locale : * const :: std :: os :: raw :: c_char) ; } extern "C" { pub fn umsg_getLocale_68 (fmt : * const UMessageFormat) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn umsg_applyPattern_68 (fmt : * mut UMessageFormat , pattern : * const UChar , patternLength : i32 , parseError : * mut UParseError , status : * mut UErrorCode) ; } extern "C" { pub fn umsg_toPattern_68 (fmt : * const UMessageFormat , result : * mut UChar , resultLength : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn umsg_format_68 (fmt : * const UMessageFormat , result : * mut UChar , resultLength : i32 , status : * mut UErrorCode , ...) -> i32 ; } extern "C" { pub fn umsg_vformat_68 (fmt : * const UMessageFormat , result : * mut UChar , resultLength : i32 , ap : * mut __va_list_tag , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn umsg_parse_68 (fmt : * const UMessageFormat , source : * const UChar , sourceLength : i32 , count : * mut i32 , status : * mut UErrorCode , ...) ; } extern "C" { pub fn umsg_vparse_68 (fmt : * const UMessageFormat , source : * const UChar , sourceLength : i32 , count : * mut i32 , ap : * mut __va_list_tag , status : * mut UErrorCode) ; } extern "C" { pub fn umsg_autoQuoteApostrophe_68 (pattern : * const UChar , patternLength : i32 , dest : * mut UChar , destCapacity : i32 , ec : * mut UErrorCode) -> i32 ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct UNumberFormatter { _unused : [u8 ; 0] , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct UFormattedNumber { _unused : [u8 ; 0] , } extern "C" { pub fn unumf_openForSkeletonAndLocale_68 (skeleton : * const UChar , skeletonLen : i32 , locale : * const :: std :: os :: raw :: c_char , ec : * mut UErrorCode) -> * mut UNumberFormatter ; } extern "C" { pub fn unumf_openForSkeletonAndLocaleWithError_68 (skeleton : * const UChar , skeletonLen : i32 , locale : * const :: std :: os :: raw :: c_char , perror : * mut UParseError , ec : * mut UErrorCode) -> * mut UNumberFormatter ; } extern "C" { pub fn unumf_openResult_68 (ec : * mut UErrorCode) -> * mut UFormattedNumber ; } extern "C" { pub fn unumf_formatInt_68 (uformatter : * const UNumberFormatter , value : i64 , uresult : * mut UFormattedNumber , ec : * mut UErrorCode) ; } extern "C" { pub fn unumf_formatDouble_68 (uformatter : * const UNumberFormatter , value : f64 , uresult : * mut UFormattedNumber , ec : * mut UErrorCode) ; } extern "C" { pub fn unumf_formatDecimal_68 (uformatter : * const UNumberFormatter , value : * const :: std :: os :: raw :: c_char , valueLen : i32 , uresult : * mut UFormattedNumber , ec : * mut UErrorCode) ; } extern "C" { pub fn unumf_resultAsValue_68 (uresult : * const UFormattedNumber , ec : * mut UErrorCode) -> * const UFormattedValue ; } extern "C" { pub fn unumf_resultToString_68 (uresult : * const UFormattedNumber , buffer : * mut UChar , bufferCapacity : i32 , ec : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unumf_resultNextFieldPosition_68 (uresult : * const UFormattedNumber , ufpos : * mut UFieldPosition , ec : * mut UErrorCode) -> UBool ; } extern "C" { pub fn unumf_resultGetAllFieldPositions_68 (uresult : * const UFormattedNumber , ufpositer : * mut UFieldPositionIterator , ec : * mut UErrorCode) ; } extern "C" { pub fn unumf_resultToDecimalNumber_68 (uresult : * const UFormattedNumber , dest : * mut :: std :: os :: raw :: c_char , destCapacity : i32 , ec : * mut UErrorCode) -> i32 ; } extern "C" { pub fn unumf_close_68 (uformatter : * mut UNumberFormatter) ; } extern "C" { pub fn unumf_closeResult_68 (uresult : * mut UFormattedNumber) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct UFormattedNumberRange { _unused : [u8 ; 0] , } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UPluralType { UPLURAL_TYPE_CARDINAL = 0 , UPLURAL_TYPE_ORDINAL = 1 , UPLURAL_TYPE_COUNT = 2 , } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct UPluralRules { _unused : [u8 ; 0] , } extern "C" { pub fn uplrules_open_68 (locale : * const :: std :: os :: raw :: c_char , status : * mut UErrorCode) -> * mut UPluralRules ; } extern "C" { pub fn uplrules_openForType_68 (locale : * const :: std :: os :: raw :: c_char , type_ : UPluralType , status : * mut UErrorCode) -> * mut UPluralRules ; } extern "C" { pub fn uplrules_close_68 (uplrules : * mut UPluralRules) ; } extern "C" { pub fn uplrules_select_68 (uplrules : * const UPluralRules , number : f64 , keyword : * mut UChar , capacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uplrules_selectFormatted_68 (uplrules : * const UPluralRules , number : * const UFormattedNumber , keyword : * mut UChar , capacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uplrules_selectForRange_68 (uplrules : * const UPluralRules , urange : * const UFormattedNumberRange , keyword : * mut UChar , capacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uplrules_selectWithFormat_68 (uplrules : * const UPluralRules , number : f64 , fmt : * const UNumberFormat , keyword : * mut UChar , capacity : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn uplrules_getKeywords_68 (uplrules : * const UPluralRules , status : * mut UErrorCode) -> * mut UEnumeration ; } extern "C" { pub fn u_getDataDirectory_68 () -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn u_setDataDirectory_68 (directory : * const :: std :: os :: raw :: c_char) ; } extern "C" { pub fn u_getTimeZoneFilesDirectory_68 (status : * mut UErrorCode) -> * const :: std :: os :: raw :: c_char ; } extern "C" { pub fn u_setTimeZoneFilesDirectory_68 (path : * const :: std :: os :: raw :: c_char , status : * mut UErrorCode) ; } extern "C" { pub fn u_charsToUChars_68 (cs : * const :: std :: os :: raw :: c_char , us : * mut UChar , length : i32) ; } extern "C" { pub fn u_UCharsToChars_68 (us : * const UChar , cs : * mut :: std :: os :: raw :: c_char , length : i32) ; } extern "C" { pub fn u_strlen_68 (s : * const UChar) -> i32 ; } extern "C" { pub fn u_countChar32_68 (s : * const UChar , length : i32) -> i32 ; } extern "C" { pub fn u_strHasMoreChar32Than_68 (s : * const UChar , length : i32 , number : i32) -> UBool ; } extern "C" { pub fn u_strcat_68 (dst : * mut UChar , src : * const UChar) -> * mut UChar ; } extern "C" { pub fn u_strncat_68 (dst : * mut UChar , src : * const UChar , n : i32) -> * mut UChar ; } extern "C" { pub fn u_strstr_68 (s : * const UChar , substring : * const UChar) -> * mut UChar ; } extern "C" { pub fn u_strFindFirst_68 (s : * const UChar , length : i32 , substring : * const UChar , subLength : i32) -> * mut UChar ; } extern "C" { pub fn u_strchr_68 (s : * const UChar , c : UChar) -> * mut UChar ; } extern "C" { pub fn u_strchr32_68 (s : * const UChar , c : UChar32) -> * mut UChar ; } extern "C" { pub fn u_strrstr_68 (s : * const UChar , substring : * const UChar) -> * mut UChar ; } extern "C" { pub fn u_strFindLast_68 (s : * const UChar , length : i32 , substring : * const UChar , subLength : i32) -> * mut UChar ; } extern "C" { pub fn u_strrchr_68 (s : * const UChar , c : UChar) -> * mut UChar ; } extern "C" { pub fn u_strrchr32_68 (s : * const UChar , c : UChar32) -> * mut UChar ; } extern "C" { pub fn u_strpbrk_68 (string : * const UChar , matchSet : * const UChar) -> * mut UChar ; } extern "C" { pub fn u_strcspn_68 (string : * const UChar , matchSet : * const UChar) -> i32 ; } extern "C" { pub fn u_strspn_68 (string : * const UChar , matchSet : * const UChar) -> i32 ; } extern "C" { pub fn u_strtok_r_68 (src : * mut UChar , delim : * const UChar , saveState : * mut * mut UChar) -> * mut UChar ; } extern "C" { pub fn u_strcmp_68 (s1 : * const UChar , s2 : * const UChar) -> i32 ; } extern "C" { pub fn u_strcmpCodePointOrder_68 (s1 : * const UChar , s2 : * const UChar) -> i32 ; } extern "C" { pub fn u_strCompare_68 (s1 : * const UChar , length1 : i32 , s2 : * const UChar , length2 : i32 , codePointOrder : UBool) -> i32 ; } extern "C" { pub fn u_strCompareIter_68 (iter1 : * mut UCharIterator , iter2 : * mut UCharIterator , codePointOrder : UBool) -> i32 ; } extern "C" { pub fn u_strCaseCompare_68 (s1 : * const UChar , length1 : i32 , s2 : * const UChar , length2 : i32 , options : u32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn u_strncmp_68 (ucs1 : * const UChar , ucs2 : * const UChar , n : i32) -> i32 ; } extern "C" { pub fn u_strncmpCodePointOrder_68 (s1 : * const UChar , s2 : * const UChar , n : i32) -> i32 ; } extern "C" { pub fn u_strcasecmp_68 (s1 : * const UChar , s2 : * const UChar , options : u32) -> i32 ; } extern "C" { pub fn u_strncasecmp_68 (s1 : * const UChar , s2 : * const UChar , n : i32 , options : u32) -> i32 ; } extern "C" { pub fn u_memcasecmp_68 (s1 : * const UChar , s2 : * const UChar , length : i32 , options : u32) -> i32 ; } extern "C" { pub fn u_strcpy_68 (dst : * mut UChar , src : * const UChar) -> * mut UChar ; } extern "C" { pub fn u_strncpy_68 (dst : * mut UChar , src : * const UChar , n : i32) -> * mut UChar ; } extern "C" { pub fn u_uastrcpy_68 (dst : * mut UChar , src : * const :: std :: os :: raw :: c_char) -> * mut UChar ; } extern "C" { pub fn u_uastrncpy_68 (dst : * mut UChar , src : * const :: std :: os :: raw :: c_char , n : i32) -> * mut UChar ; } extern "C" { pub fn u_austrcpy_68 (dst : * mut :: std :: os :: raw :: c_char , src : * const UChar) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn u_austrncpy_68 (dst : * mut :: std :: os :: raw :: c_char , src : * const UChar , n : i32) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn u_memcpy_68 (dest : * mut UChar , src : * const UChar , count : i32) -> * mut UChar ; } extern "C" { pub fn u_memmove_68 (dest : * mut UChar , src : * const UChar , count : i32) -> * mut UChar ; } extern "C" { pub fn u_memset_68 (dest : * mut UChar , c : UChar , count : i32) -> * mut UChar ; } extern "C" { pub fn u_memcmp_68 (buf1 : * const UChar , buf2 : * const UChar , count : i32) -> i32 ; } extern "C" { pub fn u_memcmpCodePointOrder_68 (s1 : * const UChar , s2 : * const UChar , count : i32) -> i32 ; } extern "C" { pub fn u_memchr_68 (s : * const UChar , c : UChar , count : i32) -> * mut UChar ; } extern "C" { pub fn u_memchr32_68 (s : * const UChar , c : UChar32 , count : i32) -> * mut UChar ; } extern "C" { pub fn u_memrchr_68 (s : * const UChar , c : UChar , count : i32) -> * mut UChar ; } extern "C" { pub fn u_memrchr32_68 (s : * const UChar , c : UChar32 , count : i32) -> * mut UChar ; } extern "C" { pub fn u_unescape_68 (src : * const :: std :: os :: raw :: c_char , dest : * mut UChar , destCapacity : i32) -> i32 ; } pub type UNESCAPE_CHAR_AT = :: std :: option :: Option < unsafe extern "C" fn (offset : i32 , context : * mut :: std :: os :: raw :: c_void) -> UChar > ; extern "C" { pub fn u_unescapeAt_68 (charAt : UNESCAPE_CHAR_AT , offset : * mut i32 , length : i32 , context : * mut :: std :: os :: raw :: c_void) -> UChar32 ; } extern "C" { pub fn u_strToUpper_68 (dest : * mut UChar , destCapacity : i32 , src : * const UChar , srcLength : i32 , locale : * const :: std :: os :: raw :: c_char , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn u_strToLower_68 (dest : * mut UChar , destCapacity : i32 , src : * const UChar , srcLength : i32 , locale : * const :: std :: os :: raw :: c_char , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn u_strToTitle_68 (dest : * mut UChar , destCapacity : i32 , src : * const UChar , srcLength : i32 , titleIter : * mut UBreakIterator , locale : * const :: std :: os :: raw :: c_char , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn u_strFoldCase_68 (dest : * mut UChar , destCapacity : i32 , src : * const UChar , srcLength : i32 , options : u32 , pErrorCode : * mut UErrorCode) -> i32 ; } extern "C" { pub fn u_strToWCS_68 (dest : * mut wchar_t , destCapacity : i32 , pDestLength : * mut i32 , src : * const UChar , srcLength : i32 , pErrorCode : * mut UErrorCode) -> * mut wchar_t ; } extern "C" { pub fn u_strFromWCS_68 (dest : * mut UChar , destCapacity : i32 , pDestLength : * mut i32 , src : * const wchar_t , srcLength : i32 , pErrorCode : * mut UErrorCode) -> * mut UChar ; } extern "C" { pub fn u_strToUTF8_68 (dest : * mut :: std :: os :: raw :: c_char , destCapacity : i32 , pDestLength : * mut i32 , src : * const UChar , srcLength : i32 , pErrorCode : * mut UErrorCode) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn u_strFromUTF8_68 (dest : * mut UChar , destCapacity : i32 , pDestLength : * mut i32 , src : * const :: std :: os :: raw :: c_char , srcLength : i32 , pErrorCode : * mut UErrorCode) -> * mut UChar ; } extern "C" { pub fn u_strToUTF8WithSub_68 (dest : * mut :: std :: os :: raw :: c_char , destCapacity : i32 , pDestLength : * mut i32 , src : * const UChar , srcLength : i32 , subchar : UChar32 , pNumSubstitutions : * mut i32 , pErrorCode : * mut UErrorCode) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn u_strFromUTF8WithSub_68 (dest : * mut UChar , destCapacity : i32 , pDestLength : * mut i32 , src : * const :: std :: os :: raw :: c_char , srcLength : i32 , subchar : UChar32 , pNumSubstitutions : * mut i32 , pErrorCode : * mut UErrorCode) -> * mut UChar ; } extern "C" { pub fn u_strFromUTF8Lenient_68 (dest : * mut UChar , destCapacity : i32 , pDestLength : * mut i32 , src : * const :: std :: os :: raw :: c_char , srcLength : i32 , pErrorCode : * mut UErrorCode) -> * mut UChar ; } extern "C" { pub fn u_strToUTF32_68 (dest : * mut UChar32 , destCapacity : i32 , pDestLength : * mut i32 , src : * const UChar , srcLength : i32 , pErrorCode : * mut UErrorCode) -> * mut UChar32 ; } extern "C" { pub fn u_strFromUTF32_68 (dest : * mut UChar , destCapacity : i32 , pDestLength : * mut i32 , src : * const UChar32 , srcLength : i32 , pErrorCode : * mut UErrorCode) -> * mut UChar ; } extern "C" { pub fn u_strToUTF32WithSub_68 (dest : * mut UChar32 , destCapacity : i32 , pDestLength : * mut i32 , src : * const UChar , srcLength : i32 , subchar : UChar32 , pNumSubstitutions : * mut i32 , pErrorCode : * mut UErrorCode) -> * mut UChar32 ; } extern "C" { pub fn u_strFromUTF32WithSub_68 (dest : * mut UChar , destCapacity : i32 , pDestLength : * mut i32 , src : * const UChar32 , srcLength : i32 , subchar : UChar32 , pNumSubstitutions : * mut i32 , pErrorCode : * mut UErrorCode) -> * mut UChar ; } extern "C" { pub fn u_strToJavaModifiedUTF8_68 (dest : * mut :: std :: os :: raw :: c_char , destCapacity : i32 , pDestLength : * mut i32 , src : * const UChar , srcLength : i32 , pErrorCode : * mut UErrorCode) -> * mut :: std :: os :: raw :: c_char ; } extern "C" { pub fn u_strFromJavaModifiedUTF8WithSub_68 (dest : * mut UChar , destCapacity : i32 , pDestLength : * mut i32 , src : * const :: std :: os :: raw :: c_char , srcLength : i32 , subchar : UChar32 , pNumSubstitutions : * mut i32 , pErrorCode : * mut UErrorCode) -> * mut UChar ; } pub type UReplaceable = * mut :: std :: os :: raw :: c_void ; # [repr (C)] # [derive (Debug , Default , Copy , Clone , Hash , PartialOrd , PartialEq)] pub struct UReplaceableCallbacks { pub length : :: std :: option :: Option < unsafe extern "C" fn (rep : * const UReplaceable) -> i32 > , pub charAt : :: std :: option :: Option < unsafe extern "C" fn (rep : * const UReplaceable , offset : i32) -> UChar > , pub char32At : :: std :: option :: Option < unsafe extern "C" fn (rep : * const UReplaceable , offset : i32) -> UChar32 > , pub replace : :: std :: option :: Option < unsafe extern "C" fn (rep : * mut UReplaceable , start : i32 , limit : i32 , text : * const UChar , textLength : i32) > , pub extract : :: std :: option :: Option < unsafe extern "C" fn (rep : * mut UReplaceable , start : i32 , limit : i32 , dst : * mut UChar) > , pub copy : :: std :: option :: Option < unsafe extern "C" fn (rep : * mut UReplaceable , start : i32 , limit : i32 , dest : i32) > , } # [test] fn bindgen_test_layout_UReplaceableCallbacks () { assert_eq ! (:: std :: mem :: size_of :: < UReplaceableCallbacks > () , 48usize , concat ! ("Size of: " , stringify ! (UReplaceableCallbacks))) ; assert_eq ! (:: std :: mem :: align_of :: < UReplaceableCallbacks > () , 8usize , concat ! ("Alignment of " , stringify ! (UReplaceableCallbacks))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UReplaceableCallbacks > ())) . length as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (UReplaceableCallbacks) , "::" , stringify ! (length))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UReplaceableCallbacks > ())) . charAt as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (UReplaceableCallbacks) , "::" , stringify ! (charAt))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UReplaceableCallbacks > ())) . char32At as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (UReplaceableCallbacks) , "::" , stringify ! (char32At))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UReplaceableCallbacks > ())) . replace as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (UReplaceableCallbacks) , "::" , stringify ! (replace))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UReplaceableCallbacks > ())) . extract as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (UReplaceableCallbacks) , "::" , stringify ! (extract))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UReplaceableCallbacks > ())) . copy as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (UReplaceableCallbacks) , "::" , stringify ! (copy))) ; } pub type UTransliterator = * mut :: std :: os :: raw :: c_void ; # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq , Eq)] pub enum UTransDirection { UTRANS_FORWARD = 0 , UTRANS_REVERSE = 1 , } # [repr (C)] # [derive (Debug , Default , Copy , Clone , Hash , PartialOrd , PartialEq)] pub struct UTransPosition { pub contextStart : i32 , pub contextLimit : i32 , pub start : i32 , pub limit : i32 , } # [test] fn bindgen_test_layout_UTransPosition () { assert_eq ! (:: std :: mem :: size_of :: < UTransPosition > () , 16usize , concat ! ("Size of: " , stringify ! (UTransPosition))) ; assert_eq ! (:: std :: mem :: align_of :: < UTransPosition > () , 4usize , concat ! ("Alignment of " , stringify ! (UTransPosition))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTransPosition > ())) . contextStart as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (UTransPosition) , "::" , stringify ! (contextStart))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTransPosition > ())) . contextLimit as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (UTransPosition) , "::" , stringify ! (contextLimit))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTransPosition > ())) . start as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (UTransPosition) , "::" , stringify ! (start))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < UTransPosition > ())) . limit as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (UTransPosition) , "::" , stringify ! (limit))) ; } extern "C" { pub fn utrans_openU_68 (id : * const UChar , idLength : i32 , dir : UTransDirection , rules : * const UChar , rulesLength : i32 , parseError : * mut UParseError , pErrorCode : * mut UErrorCode) -> * mut UTransliterator ; } extern "C" { pub fn utrans_openInverse_68 (trans : * const UTransliterator , status : * mut UErrorCode) -> * mut UTransliterator ; } extern "C" { pub fn utrans_clone_68 (trans : * const UTransliterator , status : * mut UErrorCode) -> * mut UTransliterator ; } extern "C" { pub fn utrans_close_68 (trans : * mut UTransliterator) ; } extern "C" { pub fn utrans_getUnicodeID_68 (trans : * const UTransliterator , resultLength : * mut i32) -> * const UChar ; } extern "C" { pub fn utrans_register_68 (adoptedTrans : * mut UTransliterator , status : * mut UErrorCode) ; } extern "C" { pub fn utrans_unregisterID_68 (id : * const UChar , idLength : i32) ; } extern "C" { pub fn utrans_setFilter_68 (trans : * mut UTransliterator , filterPattern : * const UChar , filterPatternLen : i32 , status : * mut UErrorCode) ; } extern "C" { pub fn utrans_countAvailableIDs_68 () -> i32 ; } extern "C" { pub fn utrans_openIDs_68 (pErrorCode : * mut UErrorCode) -> * mut UEnumeration ; } extern "C" { pub fn utrans_trans_68 (trans : * const UTransliterator , rep : * mut UReplaceable , repFunc : * const UReplaceableCallbacks , start : i32 , limit : * mut i32 , status : * mut UErrorCode) ; } extern "C" { pub fn utrans_transIncremental_68 (trans : * const UTransliterator , rep : * mut UReplaceable , repFunc : * const UReplaceableCallbacks , pos : * mut UTransPosition , status : * mut UErrorCode) ; } extern "C" { pub fn utrans_transUChars_68 (trans : * const UTransliterator , text : * mut UChar , textLength : * mut i32 , textCapacity : i32 , start : i32 , limit : * mut i32 , status : * mut UErrorCode) ; } extern "C" { pub fn utrans_transIncrementalUChars_68 (trans : * const UTransliterator , text : * mut UChar , textLength : * mut i32 , textCapacity : i32 , pos : * mut UTransPosition , status : * mut UErrorCode) ; } extern "C" { pub fn utrans_toRules_68 (trans : * const UTransliterator , escapeUnprintable : UBool , result : * mut UChar , resultLength : i32 , status : * mut UErrorCode) -> i32 ; } extern "C" { pub fn utrans_getSourceSet_68 (trans : * const UTransliterator , ignoreFilter : UBool , fillIn : * mut USet , status : * mut UErrorCode) -> * mut USet ; } extern "C" { pub fn utrans_open_68 (id : * const :: std :: os :: raw :: c_char , dir : UTransDirection , rules : * const UChar , rulesLength : i32 , parseError : * mut UParseError , status : * mut UErrorCode) -> * mut UTransliterator ; } extern "C" { pub fn utrans_getID_68 (trans : * const UTransliterator , buf : * mut :: std :: os :: raw :: c_char , bufCapacity : i32) -> i32 ; } extern "C" { pub fn utrans_unregister_68 (id : * const :: std :: os :: raw :: c_char) ; } extern "C" { pub fn utrans_getAvailableID_68 (index : i32 , buf : * mut :: std :: os :: raw :: c_char , bufCapacity : i32) -> i32 ; } pub type __builtin_va_list = [__va_list_tag ; 1usize] ; # [repr (C)] # [derive (Debug , Copy , Clone , Hash , PartialOrd , PartialEq)] pub struct __va_list_tag { pub gp_offset : :: std :: os :: raw :: c_uint , pub fp_offset : :: std :: os :: raw :: c_uint , pub overflow_arg_area : * mut :: std :: os :: raw :: c_void , pub reg_save_area : * mut :: std :: os :: raw :: c_void , } # [test] fn bindgen_test_layout___va_list_tag () { assert_eq ! (:: std :: mem :: size_of :: < __va_list_tag > () , 24usize , concat ! ("Size of: " , stringify ! (__va_list_tag))) ; assert_eq ! (:: std :: mem :: align_of :: < __va_list_tag > () , 8usize , concat ! ("Alignment of " , stringify ! (__va_list_tag))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < __va_list_tag > ())) . gp_offset as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (__va_list_tag) , "::" , stringify ! (gp_offset))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < __va_list_tag > ())) . fp_offset as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (__va_list_tag) , "::" , stringify ! (fp_offset))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < __va_list_tag > ())) . overflow_arg_area as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (__va_list_tag) , "::" , stringify ! (overflow_arg_area))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < __va_list_tag > ())) . reg_save_area as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (__va_list_tag) , "::" , stringify ! (reg_save_area))) ; } impl Default for __va_list_tag { fn default () -> Self { let mut s = :: std :: mem :: MaybeUninit :: < Self > :: uninit () ; unsafe { :: std :: ptr :: write_bytes (s . as_mut_ptr () , 0 , 1) ; s . assume_init () } } }